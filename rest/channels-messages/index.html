<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Ably API Documentation - Channels and Messages</title>
    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="stylesheet" type="text/css" href="/vendor/prettify/prettify.css" media="screen">
    <link rel="stylesheet" type="text/css" href="/stylesheet.css" media="screen">

    
      <link rel="canonical" href="https://www.ably.io/documentation/rest/channels-messages" />
    

    <script src="/vendor/javascripts/jquery-1-8-3-min.js" type="text/javascript"></script>
    <script src="/vendor/javascripts/jquery-cookie-1-3-1.js" type="text/javascript"></script>
    <script src="/vendor/javascripts/base64.js" type="text/javascript"></script>

    <script src="/vendor/prettify/prettify-lib.js" type="text/javascript"></script>

    <script src="//cdn.ably.io/lib/ably.min.js" type="text/javascript"></script>

    <script src="/javascripts/application.js" type="text/javascript"></script>
    <script src="/javascripts/lang-manager.js" type="text/javascript"></script>

    

    <!-- you don't need to keep this, but it's cool for stats! -->
    <meta name="generator" content="nanoc 3.7.5">
  </head>
  <body>
    <div class="canonical-notice">
      <img src="/images/icon-alert.png">
      <span class="canonical-notice-text">
        You are viewing our bleeding edge unstable documentation. We recommend you use our <a href="https://www.ably.io/documentation">stable documentation Â»</a>
      </span>
      <img src="/images/icon-alert.png">
    </div>
    <div class="fork-banner"><a href="https://github.com/ably/docs"><img src="/images/forkme.png" alt="Fork me on GitHub"></a></div>

  <div id="documentation">
    
      <nav class="jump-to-nav">
        <div class="form">
          <select id="jump-to-nav">
            <option>Jump to ...</option>
            <optgroup label='Help with'>
<option id="anchor-getting-started">Getting started</option>
<option id="anchor-channels">Channels</option>
<option id="anchor-channel-namespaces">Channel namespaces</option>
<option id="anchor-message-subscription">Subscribing to messages</option>
<option id="anchor-message-publish">Publishing messages</option>
<option id="anchor-message-history">Retrieving message history</option>
</optgroup>
<optgroup label='Channel API properties'>
<option id="anchor-name">name</option>
<option id="anchor-presence">presence</option>
</optgroup>
<optgroup label='Channel API methods'>
<option id="anchor-publish">publish</option>
<option id="anchor-history">history</option>
</optgroup>
          </select>
        </div>
      </nav>
    
    <header>
      
        <div class="breadcrumb"><a href="/rest/">REST Client Library API</a><span class="separator">/</span></div>
      
      
        <h1 id="title">Channels and Messages</h1>
      
    </header>
    <article>
      <p>The Ably Realtime service organises the message traffic within applications into named channels. Channels are the &#8220;unit&#8221; of message distribution; clients attach to channels to subscribe to messages, and every message published to a unique channel is broadcast by Ably to all subscribers. This scalable and resilient messaging pattern is commonly called <a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">pub/sub</a>.</p>
<h2 id="getting-started">Getting started</h2>
<p>The Ably REST client library provides a straightforward API for publishing and retrieve history messages on a channel.</p>
<pre class="code-editor open-jsbin open-jsbin-ugobiz" lang="javascript"><code class="code-editor open-jsbin open-jsbin-ugobiz" lang="javascript">var rest = new Ably.Rest('{{API_KEY}}');
var channel = rest.channels.get('{{RANDOM_CHANNEL_NAME}}');
channel.publish('example', 'message data', function() {
  channel.history(function(err, resultPage) {
    console.log('Last published message:' + resultPage.items[0]);
  });
});</code></pre>
<pre class="code-editor open-jsbin open-jsbin-ugobiz" lang="nodejs"><code class="code-editor open-jsbin open-jsbin-ugobiz" lang="nodejs">var rest = new Ably.Rest('{{API_KEY}}');
var channel = rest.channels.get('{{RANDOM_CHANNEL_NAME}}');
channel.publish('example', 'message data', function() {
  channel.history(function(err, resultPage) {
    console.log('Last published message:' + resultPage.items[0]);
  });
});</code></pre>
<pre lang="ruby"><code lang="ruby">rest = Ably::Rest.new('{{API_KEY}}')
channel = rest.channels.get('{{RANDOM_CHANNEL_NAME}}')
channel.publish 'example', 'message data'
result_page = channel.history()
puts "Last published message: #{result_page.items.first}"</code></pre>
<pre lang="python"><code lang="python">rest = AblyRest('{{API_KEY}}')
channel = rest.channels.get('{{RANDOM_CHANNEL_NAME}}')
channel.publish(u'example', u'message data')
result_page = channel.history()
print("Last published message data: " + result_page.items[0].data)</code></pre>
<pre lang="php"><code lang="php">$rest = new Ably\AblyRest('{{API_KEY}}');
$channel = $rest-&gt;channels-&gt;get('{{RANDOM_CHANNEL_NAME}}');
$channel-&gt;publish('example', 'message data');
$resultPage = $channel-&gt;history();
echo("Last published data: " . $resultPage-&gt;items[0]-&gt;data);</code></pre>
<pre lang="java"><code lang="java">AblyRest rest = new AblyRest("{{API_KEY}}");
Channel channel = rest.channels.get("{{RANDOM_CHANNEL_NAME}}");
channel.publish("example", "message data");
PaginatedResult&lt;Message&gt; resultPage = channel.history(null);
System.out.println("Last published message ID: " + resultPage.items[0].id);</code></pre>
<pre lang="objc"><code lang="objc">ARTRest *rest = [[ARTRest alloc] initWithKey:@"{{API_KEY}}"];
ARTRestChannel *channel = [rest.channels get:@"{{RANDOM_CHANNEL_NAME}}"];
[channel publish:@"example" data:@"message data"];
[channel history:^(ARTPaginatedResult&lt;ARTMessage *&gt; *resultPage, ARTErrorInfo *error) {
    NSLog(@"Last published message ID: %@", resultPage.items[0].id);
}];</code></pre>
<pre lang="swift"><code lang="swift">let rest = ARTRest(key: "{{API_KEY}}")
let channel = rest.channels.get("{{RANDOM_CHANNEL_NAME}}")
channel.publish("example", data: "message data")
channel.history { resultPage, error in
    print("Last published message ID: \(resultPage!.items[0].id)")
}</code></pre>
<h2 id="channels">Channels</h2>
<p>In order to publish, retrieve message history or access presence history, you must first obtain a REST channel instance.</p>
<h3>Obtaining a channel instance</h3>
<p>A <code>Channel</code> object is a reference to a single channel. A channel instance is obtained from the <a href="/rest/usage/#channels"><code>channels</code> collection</a> of the <span lang="ruby"><code>Rest::Client</code></span><span lang="php"><code>AblyRest</code></span><span lang="default"><code>Rest</code></span> instance, and is uniquely identified by its unicode string name. Find out more about <a href="https://support.ably.io/solution/articles/3000046824-what-restrictions-exist-for-the-name-field-of-a-channel">channel naming</a></p>
<pre lang="javascript"><code lang="javascript">var channel = rest.channels.get('channelName');</code></pre>
<pre lang="nodejs"><code lang="nodejs">var channel = rest.channels.get('channelName');</code></pre>
<pre lang="java"><code lang="java">Channel channel = rest.channels.get("channelName");</code></pre>
<pre lang="ruby"><code lang="ruby">channel = rest.channels.get('channelName')</code></pre>
<pre lang="python"><code lang="python">channel = rest.channels.get('channelName')</code></pre>
<pre lang="php"><code lang="php">$channel = $rest-&gt;channels-&gt;get('channelName');</code></pre>
<pre lang="objc"><code lang="objc">ARTRestChannel *channel = [realtime.channels get:@"channelName"];</code></pre>
<pre lang="swift"><code lang="swift">let channel = realtime.channels.get("channelName")</code></pre>
<p>To find out more about subscribing to messages published on channels in realtime, see the <a href="/realtime/channels-messages">Realtime channel API</a>.</p>
<h4>Setting channel options and encryption</h4>
<p>A set of <a href="#channel-options">channel options</a> may also be passed to configure a channel for encryption. Find out more about <a href="/rest/encryption">symmetric message encryption</a>.</p>
<pre lang="javascript"><code lang="javascript">Crypto.generateRandomKey(function(err, key) {
  var options = { cipher: { key: key } };
  var channel = rest.channels.get('channelName', options);
});</code></pre>
<pre lang="nodejs"><code lang="nodejs">Crypto.generateRandomKey(function(err, key) {
  var options = { cipher: { key: key } };
  var channel = rest.channels.get('channelName', options);
});</code></pre>
<pre lang="java"><code lang="java">CipherParams params = Crypto.getDefaultParams(key);
ChannelOptions options = new ChannelOptions();
options.cipher = params;
Channel channel = rest.channels.get("channelName", channelOpts);</code></pre>
<pre lang="ruby"><code lang="ruby">key = Ably::Util::Crypto.generate_random_key
options = { cipher: { key: key } }
channel = rest.channels.get('channelName', options)</code></pre>
<pre lang="python"><code lang="python">key = ably.util.crypto.generate_random_key()
channel = rest.channels.get('channelName', cipher={'key': key})</code></pre>
<pre lang="php"><code lang="php">$key = Ably\Crypto-&gt;generate_random_key();
$options = array('cipher' =&gt; array('key' =&gt; key));
$channel = $rest-&gt;channels-&gt;get('channelName', $options);</code></pre>
<pre lang="objc"><code lang="objc">NSData *key = [ARTCrypto generateRandomKey];
ARTChannelOptions *options = [[ARTChannelOptions alloc] initWithCipherKey:key];
ARTRestChannel *channel = [rest.channels get:@"channelName" options:options];</code></pre>
<pre lang="swift"><code lang="swift">let key = ARTCrypto.generateRandomKey()
let options = ARTChannelOptions(cipherKey: key)
let channel = rest.channels.get("channelName", options: options)</code></pre>
<h3>Channel namespaces</h3>
<p>One or more channel namespaces, or channel name prefixes, may be <a href="https://support.ably.io/solution/articles/3000030053-how-do-i-access-my-app-dashboard">configured for an app in your dashboard</a>. When a channel is created whose name is prefixed with one of the namespaces, the channel assumes certain configured attributes associated with that namespace. For example, a channel namespace named &#8220;<code>private</code>&#8221; would match channels named &#8220;<code>private</code>&#8221;, &#8220;<code>private:chat</code>&#8221;, &#8220;<code>private:chat:mike</code>&#8221;.</p>
<p>Namespace-prefixed channel names are delimited by a single colon <code>:</code>; the first component of the channel name (from the start up to and including the last character before the colon) is the namespace. A channel name may validly contain a colon even if the namespace component does not correspond to a namespace; also, a channel may contain multiple colons and only the component up to the first colon will be matched with a namespace. The only restriction on channel names is that a channel name may not start with a colon <code>:</code>, an open square bracket <code>[</code> and it may not be empty.</p>
<p>Namespaces are defined and configured via the <a href="https://support.ably.io/solution/articles/3000030057-what-are-channel-rules-and-how-can-i-use-them-in-my-app">application dashboard settings</a>. The namespace attributes that can be configured are:</p>
<ul>
	<li><b>Persisted messages</b> &#8211; If enabled, all messages within this namespace will be stored according to the storage rules for your account. You can access stored messages via the <a href="/realtime/history">history API</a></li>
	<li><b>Require identification</b> &#8211; if enabled, clients will not be permitted to subscribe to matching channels unless they are both authenticated and identified (they have an assigned client ID). Anonymous clients are not permitted to join these channels. Find out more about <a href="https://support.ably.io/solution/articles/3000038608-authenticated-clients">authenticated and identified clients</a></li>
	<li><b>Require TLS</b> &#8211; if enabled, only clients who have connected to Ably over TLS will be allowed to join the channel</li>
</ul>
<p>Key or token capabilities can also specify access rights based on channel namespace, find out more about <a href="/general/authentication">authentication</a></p>
<h2>Messages</h2>
<p>Each message published has an optional event <code>name</code> <span lang="default">property</span><span lang="java">member</span><span lang="ruby">attribute</span> and a <code>data</code> <span lang="default">property</span><span lang="java">member</span><span lang="ruby">attribute</span> carrying the payload of the message. Various primitive and object types are portably defined and supported in all clients, enabling clients to be interoperable despite being hosted in different languages or environments.</p>
<p>The supported payload types are Strings, JSON objects and arrays, buffers containing arbitrary binary data, and Null objects. Client libraries detect the supplied message payload and encode the message appropriately.</p>
<h3 id="message-subscription">Subscribing to messages</h3>
<p>The REST client library does not offer message realtime subscription but instead provides access to the &#8220;live&#8221; history using the <a href="/rest/history">REST history API</a>. Find out more about <a href="/realtime/channels-messages#message-subscription">subscribing to messages in realtime using the Realtime API</a>.</p>
<p>The <code>name</code> <span lang="default">property</span><span lang="java">member</span><span lang="ruby">attribute</span> of published messages does not affect the distribution of a channel message to clients but may be used as a subscription filter, allowing a client to register a listener that only sees a subset of the messages received on the channel. Find out more about <a href="/realtime/channels-messages#subscribe">registering listeners using the Realtime API</a>.</p>
<h3 id="message-publish">Publishing messages</h3>
<p>Channels expose a <code>publish</code> method whereby a client can publish either a single message or an array of messages to a channel over <a href="/rest-api#publish">REST</a>.</p>
<pre class="code-editor open-jsbin open-jsbin-ojanow" lang="javascript"><code class="code-editor open-jsbin open-jsbin-ojanow" lang="javascript">channel.publish('event', 'This is my payload', function(err) {
  if(err) {
    console.log('Unable to publish message; err = ' + err.message);
  } else {
    console.log('Message successfully sent');
  }
});</code></pre>
<pre class="code-editor open-jsbin open-jsbin-ojanow" lang="nodejs"><code class="code-editor open-jsbin open-jsbin-ojanow" lang="nodejs">channel.publish('event', 'This is my payload', function(err) {
  if(err) {
    console.log('Unable to publish message; err = ' + err.message);
  } else {
    console.log('Message successfully sent');
  }
});</code></pre>
<pre lang="ruby"><code lang="ruby">channel.publish('event', 'This is my payload')</code></pre>
<pre lang="python"><code lang="python">channel.publish(u'event', u'This is my payload')</code></pre>
<pre lang="php"><code lang="php">$channel-&gt;publish('event', 'This is my payload');</code></pre>
<pre lang="java"><code lang="java">channel.publish("event", "This is my payload");</code></pre>
<pre lang="objc"><code lang="objc">[channel publish:@"event" data:@"This is my payload"];</code></pre>
<pre lang="swift"><code lang="swift">channel.publish("event", data: "This is my payload")</code></pre>
<h3 id="message-history">Retrieving message history</h3>
<p>Channels expose a <a href="#history"><code>history</code></a> method providing a means for clients to obtain messages previously sent on the channel. Channel history can be used to return continuous message history up to the exact point a realtime channel was attached.</p>
<p>History provides access to instantaneous &#8220;live&#8221; history as well as the longer term persisted history for attached channels. If <a href="/rest/history#persisted-history">persisted history</a> is enabled for the channel, then messages will <a href="https://support.ably.io/solution/articles/3000030059-how-long-are-messages-stored-for">typically be stored for 24 &#8211; 72 hours</a>. If persisted history is not enabled, Ably retains the last two minutes of message history in memory.</p>
<p>The following example retrieves the first two pages of historical messages published up until the point the channel was attached.</p>
<pre lang="javascript"><code lang="javascript">channel.history(function(err, resultPage) {
  if(err) {
    console.log('Unable to get channel history; err = ' + err.message);
  } else {
    console.log(resultPage.items.length + ' messages received in first page');
    if(resultPage.hasNext()) {
      resultPage.next(function(err, nextPage) { ... });
    }
  }
});</code></pre>
<pre lang="nodejs"><code lang="nodejs">channel.history(function(err, resultPage) {
  if(err) {
    console.log('Unable to get channel history; err = ' + err.message);
  } else {
    console.log(resultPage.items.length + ' messages received in first page');
    if(resultPage.hasNext()) {
      resultPage.next(function(err, nextPage) { ... });
    }
  }
});</code></pre>
<pre lang="java"><code lang="java">PaginatedResult&lt;Message&gt; resultPage = channel.history(null);
System.out.println(resultPage.items().length + " messages received in first page");
if(resultPage.hasNext()) {
  PaginatedResult&lt;Message&gt; nextPage = resultPage.next();
  System.out.println(nextPage.items().length + " messages received in second page");
}</code></pre>
<pre lang="ruby"><code lang="ruby">result_page = channel.history
puts "#{result_page.items.length} messages received in first page"
if result_page.has_next?
  next_page = result_page.next
  puts "#{next_page.items.length} messages received in second page"
end</code></pre>
<pre lang="python"><code lang="python">result_page = channel.history()
print str(len(result_page.items)) + ' messages received in first page'
if result_page.has_next():
  next_page = result_page.next()
  print str(len(next_page.items)) + ' messages received in second page'</code></pre>
<pre lang="php"><code lang="php">$resultPage = channel-&gt;history();
echo(count($resultPage-&gt;items) . 'messages received in first page');
if($resultPage-&gt;hasMext()) {
  $nextPage = $resultPage.next();
  echo(count($resultPage-&gt;items) . 'messages received in second page');
}</code></pre>
<pre lang="objc"><code lang="objc">[channel history:^(ARTPaginatedResult&lt;ARTMessage *&gt; *resultPage, ARTErrorInfo *error) {
    NSLog(@"%lu messages received in first page", (unsigned long)[resultPage.items count]);
    if (resultPage.hasNext) {
        [resultPage next:^(ARTPaginatedResult&lt;ARTMessage *&gt; *nextPage, ARTErrorInfo *error) {
            // ...
        }];
    }
}];</code></pre>
<pre lang="swift"><code lang="swift">channel.history { resultPage, error in
    let resultPage = resultPage!
    print("\(resultPage.items.count) messages received in first page")
    if resultPage.hasNext {
        resultPage.next { nextPage, error in
            // ...
        }
    }
}</code></pre>
<p>See the <a href="/rest/history">history</a> documentation for further details of the supported query parameters.</p>
<h2>Presence</h2>
<p>Channels expose a <code>presence</code> member which a client can use to obtain present members and presence event history for the channel itself. See the <a href="/rest/presence">REST presence</a> documentation for details.</p>
<h1>Channel API Reference</h1>
<div class="inline-toc">
<ul><li>Channel reference
<ul>
<li>
Methods
<ul>
<li><a href='#publish-data'>publish(name, data)</a></li>
<li><a href='#publish-msg-array'>publish(messages)</a></li>
<li><a href='#history'>history(options)</a></li>
</ul>
</li>
<li>
Properties
<ul>
<li><a href='#name'>name</a></li>
<li><a href='#presence'>presence</a></li>
</ul>
</li>
<li>
Related types
<ul>
<li><a href='#message'>Message</a></li>
<li><a href='#channel-options'>ChannelOptions</a></li>
<li><a href='#paginated-result'>PaginatedResult</a></li>
<li><a href='#param'>Param</a></li>
</ul>
</li>
</ul>
</li></ul>
</div><h2 id="properties"><span lang='default'>Channel Properties</span><span lang='python'>Channel Attributes</span><span lang='php'>Ably\Channel Properties</span><span lang='objc,swift'>ARTRestChannel Properties</span><span lang='ruby'>Ably::Rest::Channel Attributes</span><span lang='java'>io.ably.lib.rest.Channel Members</span></h2>
<p>The <code>Channel</code> object exposes the following public <span lang="default">properties</span><span lang="ruby,python">attributes</span><span lang="java">members</span>:</p>
<h6 id="name">name</h6>
<p>The name String unique to this channel.</p>
<h6 id="presence">presence</h6>
<p>Provides access to the <a href="/rest/presence">REST Presence</a> object for this channel which can be used to get members present on the channel, or retrieve presence event history.</p>
<h2>Methods</h2>
<h6 id="publish">publish</h6>
<p>There are two overloaded versions of this method:</p>
<blockquote class="definition" id="publish-data">
<p class="definition" id="publish-data"><span lang='default'>publish(String name, Object data, callback(<a href="/realtime/types#error-info">ErrorInfo</a> err))</span><span lang='ruby,php'>publish(String name, Object data)</span><span lang='python'>publish(name=Unicode, data=Object)</span><span lang='java'>public void publish(String name, Object data)</span><span lang='objc,swift'>publish(name: String?, data: AnyObject?, callback: ((<a href="/realtime/types#error-info">ARTErrorInfo</a>?) &#8594; Void)?)</span></p>
</blockquote>
<p>Publish a single message on this channel based on a given event name and payload. <span lang="javascript,nodejs,,java,objc,swift">A <span lang="default">callback</span><span lang="java">listener</span> may optionally be passed in to this call to be notified of success <span lang="default">or failure</span><span lang="ruby"></span> of the operation.</span></p>
<blockquote class="definition" id="publish-msg-array">
<p class="definition" id="publish-msg-array"><span lang='default'>publish(Object[] messages, callback(<a href="/realtime/types#error-info">ErrorInfo</a> err))</span><span lang='ruby,php'>publish(<a href="#message">Message</a>[] messages)</span><span lang='python'>publish(messages=List&lt;<a href="#message">Message</a>&gt;)</span><span lang='java'>public void publish(<a href="#message">Message</a>[] messages)</span><span lang='objc,swift'>publish(messages: [ <a href="#message">ARTMessage</a> ], callback: ((<a href="/realtime/types#error-info">ARTErrorInfo</a>?) &#8594; Void)?)</span></p>
</blockquote>
<p>Publish several messages on this channel. <span lang="javascript,nodejs,,java,objc,swift">A <span lang="default">callback</span><span lang="java">listener</span> may optionally be passed in to this call to be notified of success <span lang="default">or failure</span><span lang="ruby"></span> of the operation.</span></p>
<h4>Parameters</h4>
<dl>
	<dt>name</dt>
	<dd>event name for the published message<br><span lang="default"><i>Type: <code>String</code></i></span><span lang="python"><i>Type: <code>Unicode</code> for Python 2, <code>String</code> for Python 3</i></span></dd>
	<dt><div lang="javascript,nodejs">data</div></dt>
	<dd>data payload for the message. The supported payload types are Strings, JSON objects and arrays, buffers containing arbitrary binary data, and null.<br><i>Type: <code>Object</code></i></dd>
	<dt><div lang="java">data</div></dt>
	<dd>data payload for the message. The supported payload types are Strings, JsonObject, binary data as byte arrays, and null.<br><i>Type: <code>Object</code></i></dd>
	<dt><div lang="ruby">data</div></dt>
	<dd>data payload for the message. The supported payload types are Strings, Hash or Array objects that can be serialised to JSON using <code>to_json</code>, binary data as <code>ASCII-8BIT</code> byte arrays, and null.<br><i>Type: <code>Object</code></i></dd>
	<dt><div lang="python">data</div></dt>
	<dd>data payload for the message. The supported payload types are unicode Strings, Dict, or List objects that can be serialised to JSON using <code>json.dumps</code>, binary data as <code>bytearray</code> (in Python 3, <code>bytes</code> also works), and None.<br><i>Type: <code>Object</code></i></dd>
	<dt><div lang="objc,swift">data</div></dt>
	<dd>data payload for the message. The supported payload types are <span lang="objc"><code>NS</code></span><code>String</code>, <span lang="objc"><code>NS</code></span><code>Dictionary</code> or <span lang="objc"><code>NS</code></span><code>Array</code> objects that can be serialised to JSON, binary data as <code>NSData</code>, and <code>nil</code>.<br><i>Type: <code>Object</code></i></dd>
	<dt><div lang="php">data</div></dt>
	<dd>data payload for the message. The supported payload types are Strings, Associative Array or Array objects that can be serialised to JSON, binary data as byte arrays, and null.<br><i>Type: <code>Object</code></i></dd>
</dl>
<dl>
	<dt>messages</dt>
	<dd>An array of message objects to publish<br><i>Type: <a href="#message"><code>Message []</code></a></i></dd>
</dl>
<dl>
	<dt><div lang="javascript,nodejs">callback</div></dt>
	<dd>is a function of the form <code>function(err)</code> which is called upon completion</dd>
	<dt><div lang="objc,swift">callback</div></dt>
	<dd>called upon publishing the message, or with an error</dd>
</dl>


<div lang="javascript,nodejs,,swift,objc"> <!-- start javascript,nodejs,,swift,objc language block -->
<h4>Callback result</h4>
<p>On successful publish of the message, <code>err</code> is null. On failure to publish the message, <code>err</code> contains an <a href="#error-info"><code>ErrorInfo</code></a> object describing the failure reason.</p>

</div> <!-- /end javascript,nodejs,,swift,objc language block -->



<div lang="java,ruby,php"> <!-- start java,ruby,php language block -->
<h4>Failure</h4>
<p>On failure to publish the message, an <a href="/rest/types#ably-exception"><code>AblyException</code></a> will be raised.</p>

</div> <!-- /end java,ruby,php language block -->

<h6 id="history">history</h6>
<blockquote class="definition">
<p class="definition"><span lang='default'>history(Object options, callback(<a href="/realtime/types#error-info">ErrorInfo</a> err, <a href="#paginated-result">PaginatedResult</a>&lt;<a href="#message">Message</a>&gt; resultPage))</span><span lang='ruby'><a href="#paginated-result">PaginatedResult</a>&lt;<a href="#message">Message</a>&gt; history(Hash options)</span><span lang='ruby'><a href="#paginated-result">PaginatedResult</a>&lt;<a href="#message">Message</a>&gt; history(kwargs_options)</span><span lang='php'><a href="#paginated-result">PaginatedResult</a>&lt;<a href="#message">Message</a>&gt; history(Array options)</span><span lang='java'>public <a href="#paginated-result">PaginatedResult</a>&lt;<a href="#message">Message</a>&gt; history(<a href="#param">Param</a>[] options)</span><span lang='objc,swift'>history(query: ARTRealtimeHistoryQuery?, callback: (<a href="#paginated-result">ARTPaginatedResult</a>&lt;<a href="#message">ARTMessage</a>&gt;?, ARTErrorInfo?) &#8594; Void) throws</span></p>
</blockquote>
<p>Gets a <a href="#paginated-result">paginated</a> set of historical messages for this channel. If the <a href="https://support.ably.io/support/solutions/articles/3000030059-how-long-are-messages-stored-for">channel is configured to persist messages to disk</a>, then message history will <a href="https://support.ably.io/solution/articles/3000030059-how-long-are-messages-stored-for">typically be available for 24 &#8211; 72 hours</a>. If not, messages are only retained in memory by the Ably service for two minutes.</p>
<h4>Parameters</h4>
<dl>
	<dt><span lang="default">options</span><span lang="objc,swift">query</span><span lang="java"><a href="#param">Param</a>[] options</span></dt>
	<dd><span lang="default">an optional object containing the query parameters</span><span lang="python">optional keyword arguments containing the query parameters</span><span lang="ruby">an optional set of key value pairs containing the query parameters</span><span lang="php">an optional Associative Array containing the query parameters</span>, as specified in the <a href="/rest/history#channel-history">message history API documentation</a>.</dd>
</dl>
<dl>
	<dt><div lang="javascript,nodejs">callback</div></dt>
	<dd>is a function of the form: <code>function(err, resultPage)</code></dd>
	<dt><div lang="swift,objc">callback</div></dt>
	<dd>called with a <a href="#paginated-result">ARTPaginatedResult</a>&lt;<a href="#message">ARTMessage</a>&gt; object or an error</dd>
</dl>


<div lang="javascript,nodejs,,objc,swift"> <!-- start javascript,nodejs,,objc,swift language block -->
<h4>Callback result</h4>
<p>On success, <code>resultPage</code> contains a <a href="#paginated-result"><code>PaginatedResult</code></a> encapsulating an array of <a href="#message"><code>Message</code></a> objects corresponding to the current page of results. <a href="#paginated-result"><code>PaginatedResult</code></a> supports pagination using <a href="#paginated-result"><code>next()</code></a> and <a href="#paginated-result"><code>first()</code></a> methods.</p>
<p>On failure to retrieve message history, <code>err</code> contains an <a href="#error-info"><code>ErrorInfo</code></a> object with the failure reason.</p>

</div> <!-- /end javascript,nodejs,,objc,swift language block -->



<div lang="java,ruby,php,python"> <!-- start java,ruby,php,python language block -->
<h4>Returns</h4>
<p>On success, the returned <a href="#paginated-result"><code>PaginatedResult</code></a> encapsulates an array of <a href="#message"><code>Message</code></a> objects corresponding to the current page of results. <a href="#paginated-result"><code>PaginatedResult</code></a> supports pagination using <a href="#paginated-result"><code>next</code></a> and <a href="#paginated-result"><code>first</code></a> methods.</p>
<p>Failure to retrieve the message history will raise an <a href="/realtime/types/#ably-exception"><code>AblyException</code></a></p>

</div> <!-- /end java,ruby,php,python language block -->

<h2 id="related-types">Related types</h2>
<h3 id="message"><span lang='default'>Message</span><span lang='objc,swift'>ARTMessage</span><span lang='ruby'>Ably::Models::Message</span><span lang='php'>Ably\Models\Message</span><span lang='java'>io.ably.lib.types.Message</span></h3>
<p>A <code>Message</code> represents an individual message that is sent to or received from Ably.</p>
<h4><span lang='default'>Properties</span><span lang='java'>Members</span><span lang='ruby'>Attributes</span><span lang='python'>Attributes</span></h4>
<dl>
	<dt>name</dt>
	<dd>Event name, if provided<br><i>Type: <code>String</code></i></dd>
</dl>
<dl>
	<dt><div lang="default">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>String</code>, <code>StringBuffer</code>, <code>JSON Object</code></i></dd>
	<dt><div lang="java">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>String</code>, <code>ByteArray</code>, <code>JSONObject</code>, <code>JSONArray</code></i></dd>
	<dt><div lang="ruby">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>String</code>, <code>Binary</code> (ASCII-8BIT String), <code>Hash</code>, <code>Array</code></i></dd>
	<dt><div lang="python">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>String</code>, <code>Bytearray</code>, <code>Dict</code>, <code>List</code></i></dd>
	<dt><div lang="php">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>String</code>, <code>Binary String</code>, <code>Associative Array</code>, <code>Array</code></i></dd>
	<dt><div lang="objc">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>NSString *</code>, <code>NSData *</code>, <code>NSDictionary *</code>, <code>NSArray *</code></i></dd>
	<dt><div lang="swift">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>String</code>, <code>NSData</code>, <code>Dictionary</code>, <code>Array</code></i></dd>
</dl>
<dl>
	<dt>id</dt>
	<dd>Unique ID assigned by Ably to this message<br><i>Type: <code>String</code></i></dd>
</dl>
<dl>
	<dt><span lang="default">clientId</span><span lang="ruby,python">client_id</span></dt>
	<dd>The client ID of the publisher of this message<br><i>Type: <code>String</code></i></dd>
</dl>
<dl>
	<dt><span lang="default">connectionId</span><span lang="ruby,python">connection_id</span></dt>
	<dd>The connection ID of the publisher of this message<br><i>Type: <code>String</code></i></dd>
</dl>
<dl>
	<dt>timestamp</dt>
	<dd>Timestamp when the presence update was received by the Ably the realtime service, as <span lang="default">milliseconds since the epoch</span><span lang="ruby">a <code>Time</code> object</span><br><i>Type: <span lang="default"><code>Integer</code></span><span lang="java"><code>Long Integer</code></span><span lang="ruby"><code>Time</code></span><span lang="objc,swift"><code>NSDate</code></span></i></dd>
</dl>
<dl>
	<dt>encoding</dt>
	<dd>This will typically be empty as all messages received from Ably are automatically decoded client-side using this value. However, if the message encoding cannot be processed, this attribute will contain the remaining transformations not applied to the <code>data</code> payload<br><i>Type: <code>String</code></i></dd>
</dl>
<h3 id="channel-options"><span lang='default'>ChannelOptions Object</span><span lang='objc,swift'>ARTChannelOptions</span><span lang='ruby'>ChannelOptions Hash</span><span lang='python'>ChannelOptions keyword arguments</span><span lang='php'>ChannelOptions Array</span><span lang='java'>io.ably.lib.types.ChannelOptions</span></h3>
<p>Currently the supported channel options are only used for <a href="/realtime/encryption">configuring encryption</a>.</p>


<div lang="javascript,nodejs"> <!-- start javascript,nodejs language block -->
<p><code>ChannelOptions</code>, a plain Javascript object, may optionally be specified when instancing a <a href="/realtime/channels-messages"><code>Channel</code></a>, and this may be used to specify channel-specific options. The following attributes can be defined on the object:</p>

</div> <!-- /end javascript,nodejs language block -->



<div lang="ruby"> <!-- start ruby language block -->
<p><code>ChannelOptions</code>, a Hash object, may optionally be specified when instancing a <a href="/realtime/channels-messages"><code>Channel</code></a>, and this may be used to specify channel-specific options. The following key symbol values can be added to the Hash:</p>

</div> <!-- /end ruby language block -->



<div lang="php"> <!-- start php language block -->
<p><code>ChannelOptions</code>, an Associative Array, may optionally be specified when instancing a <a href="/realtime/channels-messages"><code>Channel</code></a>, and this may be used to specify channel-specific options. The following named keys and values can be added to the Associated Array:</p>

</div> <!-- /end php language block -->



<div lang="java,swift,objc"> <!-- start java,swift,objc language block -->
<p><span lang="swift,objc"><code>ART</code></span><span lang="java"><code>io.ably.lib.types.</code></span><code>ChannelOptions</code> may optionally be specified when instancing a <a href="/realtime/channels-messages"><code>Channel</code></a>, and this may be used to specify channel-specific options.</p>

</div> <!-- /end java,swift,objc language block -->

<h4><span lang='default'>Properties</span><span lang='java'>Members</span><span lang='ruby'>Attributes</span></h4>
<dl>
	<dt><span lang="default">cipher</span><span lang="ruby">:cipher</span></dt>
	<dd>Requests encryption for this channel when not null, and specifies encryption-related parameters (such as algorithm, chaining mode, key length and key). See <a href="/realtime/encryption#getting-started">an example</a><br><i>Type: <a href="/realtime/encryption#cipher-params"><code>CipherParams</code></a><span lang="javascript,nodejs,,java,ruby,php"> or <span lang="javascript,nodejs">an options object</span><span lang="java">a <code>Param[]</code> list</span><span lang="ruby">an options hash</span><span lang="php">an Associative Array</span> containing at a minimum a <code>key</code></span></i></dd>
</dl>


<div lang="java"> <!-- start java language block -->
<h4>Static methods</h4>
<h6 id="with-cipher-key">withCipherKey</h6>
<blockquote class="definition">
<p class="definition">public static ChannelOptions.withCipherKey(Byte[] or String key)</p>
</blockquote>
<p>A helper method to generate a <code>ChannelOptions</code> for the simple case where you only specify a key.</p>
<h4>Parameters</h4>
<dl>
	<dt>key</dt>
	<dd>A binary <code>Byte[]</code> array or a base64-encoded <code>String</code>.</dd>
</dl>
<h4>Returns</h4>
<p>On success, the method returns a complete <code>ChannelOptions</code> object. Failure will raise an <a href="/realtime/types/#ably-exception"><code>AblyException</code></a>.</p>

</div> <!-- /end java language block -->

<h3 id="paginated-result"><span lang='default'>PaginatedResult</span><span lang='objc,swift'>ARTPaginatedResult</span><span lang='ruby'>Ably::Models::PaginatedResult</span><span lang='php'>Ably\Models\PaginatedResult</span><span lang='java'>io.ably.lib.types.PaginatedResult</span></h3>
<p>A <code>PaginatedResult</code> is a type that represents a page of results for all message and presence history, stats and REST presence requests. The response from a <a href="/rest-api/#pagination">Ably REST API paginated query</a> is accompanied by metadata that indicates the relative queries available to the <code>PaginatedResult</code> object.</p>
<h4><span lang='default'>Properties</span><span lang='java'>Members</span><span lang='ruby'>Attributes</span><span lang='python'>Attributes</span></h4>
<dl>
	<dt>items</dt>
	<dd>contains a page of results (for example an Array of <a href="#message"><code>Message</code></a> or <a href="#presence-message"><code>PresenceMessage</code></a> objects for a channel history request)<br><span lang="default"><i>Type: <code>Array &lt;Message, Presence, Stats&gt;</code></i></span><span lang="python"><i>Type: <code>List &lt;Message, Presence, Stats&gt;</code></i></span></dd>
</dl>
<dl>
	<dt><div lang="default">isLast</div></dt>
	<dd><code>true</code> if this page is the last page<br><i>Type: <code>Boolean</code></i></dd>
	<dt><div lang="ruby">last?</div></dt>
	<dd><code>true</code> if this page is the last page<br><i>Type: <code>Boolean</code></i></dd>
	<dt><div lang="php">isLast()</div></dt>
	<dd><code>true</code> if this page is the last page<br><i>Type: <code>Boolean</code></i></dd>
	<dt><div lang="python">is_last()</div></dt>
	<dd><code>True</code> if this page is the last page<br><i>Type: <code>Boolean</code></i></dd>
</dl>
<dl>
	<dt><div lang="default">hasNext</div></dt>
	<dd><code>true</code> if there are further pages<br><i>Type: <code>Boolean</code></i></dd>
	<dt><div lang="ruby">has_next?</div></dt>
	<dd><code>true</code> if there are further pages<br><i>Type: <code>Boolean</code></i></dd>
	<dt><div lang="php">hasNext()</div></dt>
	<dd><code>true</code> if there are further pages<br><i>Type: <code>Boolean</code></i></dd>
	<dt><div lang="python">has_next()</div></dt>
	<dd><code>True</code> if there are further pages<br><i>Type: <code>Boolean</code></i></dd>
</dl>
<h4>Methods</h4>
<h6>first</h6>
<blockquote class="definition">
<p class="definition"><span lang='default'>first(callback(<a href="/realtime/types#error-info">ErrorInfo</a> err, <a href="/realtime/types#paginated-result">PaginatedResult</a> resultPage))</span><span lang='ruby'><a href="/realtime/types#paginated-result">PaginatedResult</a> first</span><span lang='php'><a href="/realtime/types#paginated-result">PaginatedResult</a> first()</span><span lang='python'><a href="/realtime/types#paginated-result">PaginatedResult</a> first()</span><span lang='java'>public <a href="/realtime/types#paginated-result">PaginatedResult</a> first()</span><span lang='swift,objc'>first(callback: (ARTPaginatedResult?, ARTErrorInfo?) &#8594; Void)</span></p>
</blockquote>
<p>Returns a new <code>PaginatedResult</code> for the first page of results. <span lang="ruby">When using the Realtime library, the <code>first</code> method returns a <a href="/realtime/types#deferrable">Deferrable</a> and yields a <a href="/realtime/types#paginated-result">PaginatedResult</a>.</span></p>
<h6>items</h6>
<blockquote class="definition">
<p class="definition"><span lang='default'>Object[] items()</span><span lang='python'>List items()</span><span lang='ruby'>Object[] items</span><span lang='java'>public Object[] items()</span><span lang='swift, objc'>items: [AnyObject]</span></p>
</blockquote>
<p>Returns the current page of results as <span lang="default">an Array</span><span lang="python">a <code>List</code></span>. The type of the objects in the <span lang="default">array</span><span lang="python">list</span> is determined by the operation that provided the <code>PaginatedResult</code>. For example, a <a href="/realtime/channels-messages#history">Message#history</a> request will return <span lang="default">an array</span><span lang="python">a list</span> of <code>Message</code> objects.</p>
<h6>next</h6>
<blockquote class="definition">
<p class="definition"><span lang='default'>next(callback(<a href="/realtime/types#error-info">ErrorInfo</a> err, <a href="/realtime/types#paginated-result">PaginatedResult</a> resultPage))</span><span lang='ruby'><a href="/realtime/types#paginated-result">PaginatedResult</a> next</span><span lang='php'><a href="/realtime/types#paginated-result">PaginatedResult</a> next()</span><span lang='python'><a href="/realtime/types#paginated-result">PaginatedResult</a> next()</span><span lang='java'>public <a href="/realtime/types#paginated-result">PaginatedResult</a> next()</span><span lang='swift,objc'>next(callback: (ARTPaginatedResult?, ARTErrorInfo?) &#8594; Void)</span></p>
</blockquote>
<p>Returns a new <code>PaginatedResult</code> loaded with the next page of results. If there are no further pages, then <span lang="default"><code>null</code></span><span lang="java"><code>Null</code></span><span lang="python"><code>None</code></span><span lang="ruby,objc,swift"><code>nil</code></span> is returned. <span lang="ruby">When using the Realtime library, the <code>first</code> method returns a <a href="/realtime/types#deferrable">Deferrable</a> and yields a <a href="/realtime/types#paginated-result">PaginatedResult</a>.</span></p>
<h4>Example</h4>
<pre lang="javascript"><code lang="javascript">channel.history(function(err, paginatedResult) {
  console.log('Page 0 item 0:' + paginatedResult.items[0].data);
  paginatedResult.next(function(err, nextPage) {
    console.log('Page 1 item 1: ' + nextPage.items[1].data);
    console.log('Last page?: ' + nextPage.isLast;
  });
});</code></pre>
<pre lang="nodejs"><code lang="nodejs">channel.history(function(err, paginatedResult) {
  console.log('Page 0 item 0:' + paginatedResult.items[0].data);
  paginatedResult.next(function(err, nextPage) {
    console.log('Page 1 item 1: ' + nextPage.items[1].data);
    console.log('Last page?: ' + nextPage.isLast;
  });
});</code></pre>
<pre lang="java"><code lang="java">PaginatedResult firstPage = channel.history();
System.out.println("Page 0 item 0:" + firstPage.items[0].data);
if (firstPage.hasNext) {
  PaginatedResult nextPage = firstPage.next();
  System.out.println("Page 1 item 1:" + nextPage.items[1].data);
  System.out.println("More pages?:" + Strong.valueOf(nextpage.hasNext()));
});</code></pre>
<pre lang="ruby"><code lang="ruby"># When using the REST sync library
first_page = channel.history
puts "Page 0 item 0: #{first_page.items[0].data}"
if first_page.has_next?
  next_page = first_page.next
  puts "Page 1 item 1: #{next_page.items[1].data}"
  puts "Last page?: #{next_page.is_last?}"
end

# When using the Realtime EventMachine library
channel.history do |first_page|
  puts "Page 0 item 0: #{first_page.items[0].data}"
  if first_page.has_next?
    first_page.next do |next_page|
      puts "Page 1 item 1: #{next_page.items[1].data}"
      puts "Last page?: #{next_page.is_last?}"
    end
  end
end</code></pre>
<pre lang="python"><code lang="python">result_page = channel.history()
print 'Page 0 item 0: ' + str(result_page.items[0].data)
if result_page.has_next():
  next_page = result_page.next()
  print 'Page 1 item 1: ' + str(next_page.items[1].data)
  print 'Last page?: ' + str(next_page.is_last())</code></pre>
<pre lang="php"><code lang="php">$firstPage = $channel.history();
echo("Page 0 item 0: " . $firstPage-&gt;items[0]-&gt;data);
if ($firstPage-&gt;hasNext()) {
  $nextPage = $firstPage-&gt;next();
  echo("Page 1 item 1: " . $nextPage-&gt;items[1]-&gt;data);
  echo("Last page?: " . $nextPage-&gt;isLast());
}</code></pre>
<pre lang="objc"><code lang="objc">[channel history:^(ARTPaginatedResult&lt;ARTMessage *&gt; *paginatedResult, ARTErrorInfo *error) {
    NSLog(@"Page 0 item 0: %@", paginatedResult.items[0].data);
    [paginatedResult next:^(ARTPaginatedResult&lt;ARTMessage *&gt; *nextPage, ARTErrorInfo *error) {
        NSLog(@"Page 1 item 1: %@", nextPage.items[1].data);
        NSLog(@"Last page?: %d", nextPage.isLast);
    }];
}];</code></pre>
<pre lang="swift"><code lang="swift">channel.history { paginatedResult, error in
    let paginatedResult = paginatedResult!
    print("Page 0 item 0: \((paginatedResult.items[0] as! ARTMessage).data)")
    paginatedResult.next { nextPage, error in
        let nextPage = nextPage!
        print("Page 0 item 0: \((nextPage.items[1] as! ARTMessage).data)")
        print("Last page? \(nextPage.isLast)")
    }
}</code></pre>
<h3 id="param"><span lang='java'>io.ably.lib.types.Param</span></h3>


<div lang="java"> <!-- start java language block -->
<p><code>Param</code> is a type encapsulating a key/value pair. This type is used frequently in method parameters allowing key/value pairs to be used more flexible, see <a href="/realtime/history#channel-history"><code>Channel#history</code></a> for an example.</p>
<p>Please note that <code>key</code> and <code>value</code> attributes are always strings. If an <code>Integer</code> or other value type is expected, then you must coerce that type into a <code>String</code>.</p>
<h4><span lang='java'>Members</span></h4>
<dl>
	<dt>key</dt>
	<dd>The key value<br><i>Type: <code>String</code></i></dd>
	<dt>value</dt>
	<dd>The value associated with the <code>key</code><br><i>Type: <code>String</code></i></dd>
</dl>

</div> <!-- /end java language block -->


    </article>
    <hr class="back">
    <a href="#documentation">Back to top</a>
  </div>
  <div id="sidebar">
  <a href="/" title="API Documentation Home"><img src="/images/ably-logo.png" class="ably-logo" title="API Documentation Home"></a>
  <ul>
<li class=''><a href='/quick-start-guide/'>Quickstart Guide</a></li>
<li class=''><a href='/how-ably-works/'>How Ably works</a></li>
</ul>
  <h2><a href="/realtime/">Realtime client lib</a></h2>
<ul>
<li class=''><a href='/realtime/usage/'>Using the Realtime library</a></li>
<li class=''><a href='/realtime/connection/'>Connection</a></li>
<li class=''><a href='/realtime/channels-messages/'>Channels and Messages</a></li>
<li class=''><a href='/realtime/presence/'>Presence</a></li>
<li class=''><a href='/realtime/authentication/'>Authentication</a></li>
<li class=''><a href='/realtime/history/'>History</a></li>
<li class=''><a href='/realtime/encryption/'>Encryption</a></li>
<li class=''><a href='/realtime/statistics/'>Statistics</a></li>
<li class=''><a href='/realtime/types/'>Types</a></li>
</ul>
  <h2><a href="/rest/">REST client lib</a></h2>
<ul>
<li class=''><a href='/rest/usage/'>Using the REST library</a></li>
<li class='selected'><a href='/rest/channels-messages/'>Channels and Messages</a></li>
<li class=''><a href='/rest/presence/'>Presence</a></li>
<li class=''><a href='/rest/authentication/'>Authentication</a></li>
<li class=''><a href='/rest/history/'>History</a></li>
<li class=''><a href='/rest/encryption/'>Encryption</a></li>
<li class=''><a href='/rest/statistics/'>Statistics</a></li>
<li class=''><a href='/rest/types/'>Types</a></li>
</ul>
  <h2><a href="/rest-api/">REST API</a></h2>
<ul>
</ul>
  <h2>General</h2>
<ul>
<li class=''><a href='/general/authentication/'>Authentication</a></li>
<li class=''><a href='/general/channel-rules-namespaces/'>Channel Rules and Namespaces</a></li>
<li class=''><a href='/general/push-notifications/'>Mobile push notifications</a></li>
<li class=''><a href='/general/webhooks/'>Receiving WebHooks</a></li>
<li class=''><a href='/general/statistics/'>Application Statistics</a></li>
</ul>
  <h2><a href="/client-lib-development-guide/">Library Development</a></h2>
<ul>
<li class=''><a href='/client-lib-development-guide/features/'>Features spec v0.9</a></li>
<li class=''><a href='/client-lib-development-guide/feature-prioritisation/'>Feature prioritisation</a></li>
<li class=''><a href='/client-lib-development-guide/protocol/'>Realtime Protocol Definition</a></li>
<li class=''><a href='/client-lib-development-guide/rest-api/'>REST API Definition</a></li>
<li class=''><a href='/client-lib-development-guide/test-api/'>Sandbox Test API</a></li>
<li class=''><a href='/client-lib-development-guide/encryption/'>Encryption</a></li>
<li class=''><a href='/client-lib-development-guide/websocket/'>WebSocket Transport</a></li>
<li class=''><a href='/client-lib-development-guide/comet/'>Comet Transport</a></li>
<li class=''><a href='/client-lib-development-guide/connection-recovery/'>Connection Recovery</a></li>
<li class=''><a href='/client-lib-development-guide/connection-manager/'>Connection Manager</a></li>
<li class=''><a href='/client-lib-development-guide/connection-fallback/'>Connection host fallback</a></li>
<li class=''><a href='/client-lib-development-guide/documentation-formatting-guide/'>Documentation Formatting Guide</a></li>
<li class=''><a href='/code-index/'>Code Examples List</a></li>
</ul>
  <ul>
<li><a href="https://www.ably.io">Visit Ably.io</a></li>
</ul>
</div>

</body>
</html>
