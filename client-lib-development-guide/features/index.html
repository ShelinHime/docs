<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Ably API Documentation - Features spec v0.8</title>
    <link rel="shortcut icon" href="/assets/favicon.ico">

    <link rel="stylesheet" type="text/css" href="/assets/vendor/prettify/prettify.css" media="screen">
    <link rel="stylesheet" type="text/css" href="/assets/stylesheet.css" media="screen">

    <script src="/assets/vendor/javascripts/jquery-1-8-3-min.js" type="text/javascript"></script>
    <script src="/assets/vendor/javascripts/jquery-cookie-1-3-1.js" type="text/javascript"></script>
    <script src="/assets/vendor/javascripts/base64.js" type="text/javascript"></script>

    <script src="/assets/vendor/prettify/prettify-lib.js" type="text/javascript"></script>

    <script src="//cdn.ably.io/lib/ably.min.js" type="text/javascript"></script>

    <script src="/assets/javascripts/application.js" type="text/javascript"></script>
    <script src="/assets/javascripts/lang-manager.js" type="text/javascript"></script>

    <!-- you don't need to keep this, but it's cool for stats! -->
    <meta name="generator" content="nanoc 3.7.5">
  </head>
  <body>
    <div class="canonical-notice">
      <img src="/assets/icon-alert.png">
      <span class="canonical-notice-text">
        You are viewing our bleeding edge unstable documentation. We recommend you use of our <a href="https://www.ably.io/documentation">stable documentation Â»</a>
      </span>
      <img src="/assets/icon-alert.png">
    </div>
    <div class="fork-banner"><a href="https://github.com/ably/docs"><img src="/assets/forkme.png" alt="Fork me on GitHub"></a></div>

  <div id="documentation">
    
      <nav class="jump-to-nav">
        <div class="form">
          <select id="jump-to-nav">
            <option>Jump to ...</option>
            <optgroup label='General'>
<option id="anchor-test-guidelines">Test guidelines</option>
</optgroup>
<optgroup label='REST client library'>
<option id="anchor-restclient">RestClient</option>
<option id="anchor-rest-auth">Auth</option>
<option id="anchor-rest-channels">Channels</option>
<option id="anchor-rest-channel">Channel</option>
<option id="anchor-rest-presence">Presence</option>
</optgroup>
<optgroup label='Realtime client library'>
<option id="anchor-realtimeclient">RealtimeClient</option>
<option id="anchor-realtime-connection">Connection</option>
<option id="anchor-realtime-channels">Channels</option>
<option id="anchor-realtime-channel">Channel</option>
<option id="anchor-realtime-presence">Presence</option>
<option id="anchor-eventemitter">EventEmitter</option>
</optgroup>
<optgroup label='Types'>
<option id="anchor-types">Data types</option>
<option id="anchor-options">Options</option>
</optgroup>
          </select>
        </div>
      </nav>
    
    <header>
      
        <div class="breadcrumb"><a href="/client-lib-development-guide/">Client Library Development Guide</a><span class="separator">/</span></div>
      
      
        <h1 id="title">Features spec v0.8</h1>
      
    </header>
    <article>
      <p>A detailed <a href="https://github.com/ably/ably-ruby/blob/master/SPEC.md">test specification</a> that applies to all client libraries is generated from the Ably Ruby client library&#8217;s acceptance and test suites.  Whilst every official Ably client library has test coverage, the amount of test coverage varies, and as such our recommendation is to refer to the official <a href="https://github.com/ably/ably-ruby/blob/master/SPEC.md">test specification</a> when developing a client library.</p>
<p>However, we have found the <a href="https://github.com/ably/ably-ruby/blob/master/SPEC.md">test specification</a> can be difficult as a reference because of both its breadth and the fact that it applies to the Ruby client library which may be unfamiliar as a language for a lot of developers.</p>
<p>As a result, this document outlines the complete feature set of both the REST and Realtime client libraries.  It is expected that every client library developer refers to this document to ensure that their client library provides the same API and features as the existing Ably client libraries. In addition to this, it is essential that there is test coverage over all of the features described below. We recommend you use the <a href="https://github.com/ably/ably-java">Ably Java</a> library as a reference when reviewing how the API has been implemented as the implementation is straightforward and Java is a language most people are familiar with.</p>
<h2 id="test-guidelines">Test guidelines</h2>
<ul>
	<li><code>(G1)</code> Every test should be executed using all supported protocols (i.e. JSON and <a href="http://msgpack.org/">MessagePack</a> if supported).  This includes both sending &amp; receiving data.</li>
	<li><code>(G2)</code> All tests by default are run against a special Ably sandbox environment.  This environment allows apps to be provisioned without any authentication that can then be used for client library testing. Bear in mind that all apps created in the sandbox environment are automatically deleted after 60 minutes and have low limits to prevent abuse. Apps are configured by sending a <code>POST</code> request to <code>https://sandbox-rest.ably.io/apps</code> with a JSON body that specifies the keys and their associated capabilities, channel namespace rules and any presence fixture data that is required; see <a href="https://github.com/ably/ably-common/blob/master/test-resources/test-app-setup.json">ably-common test-app-setup.json</a>.  See the <a href="https://github.com/ably/ably-java/blob/master/test/io/ably/test/rest/RestSetup.java">Java test setup</a>. Presence fixture data is necessary for the REST library presence tests as there is no way to register presence on a channel in the REST library.</li>
	<li><code>(G3)</code> Testing statistics can be tricky due to timing issues and slow test suites as a result of sending requests to generate statistics.  As such, we provide a special stats endpoint in our sandbox environment that allows stats to be injected into our metrics system so that stats tests can make predictable assertions.  To create stats you must send an authenticated <code>POST</code> request to the stats JSON to <code>https://sandbox-rest.ably.io/stats</code> with the stats data you wish to create. See the <a href="https://github.com/ably/ably-js/blob/4e65d4e13eb8750a375b9511e4dd059092c0e481/spec/rest/stats.test.js#L8-L51">Javascript stats fixture</a> and <a href="https://github.com/ably/ably-js/blob/4e65d4e13eb8750a375b9511e4dd059092c0e481/spec/common/modules/testapp_manager.js#L158-L182">setup helper</a> as an example.</li>
</ul>
<h2 id="rest">REST client library</h2>
<p>Client library developers &#8211; clone our <a href="https://docs.google.com/spreadsheets/d/1vBzr9N-0ovtVZ0mxTeg7zLMEhcgj5lB9ivmkOcO-9J0/edit?usp=sharing">REST client library Google Doc spec</a> when developing a REST client library to help you keep track of feature compliance and test coverage.</p>
<h3 id="restclient">RestClient</h3>
<ul>
	<li><code>(RSC1)</code> The constructor accepts either an API key, a token string, or a set of <a href="#options"><code>ClientOptions</code></a>.  An exception is raised if invalid arguments are provided such as no API key, token and no means to create a token</li>
	<li><code>(RSC2)</code> The logger by default outputs to <code>STDOUT</code> (or other logging medium as appropriate to the platform) and the log level is set to warning</li>
	<li><code>(RSC3)</code> The log level can be changed</li>
	<li><code>(RSC4)</code> A custom logger can be provided in the constructor</li>
	<li><code>(RSC5)</code> <code>RestClient#auth</code> attribute provides access to the <code>Auth</code> object that was instanced with the <code>ClientOptions</code> provided in the <code>RestClient</code> constructor</li>
	<li><code>(RSC6)</code> <code>RestClient#stats</code> function:
	<ul>
		<li><code>(RSC6a)</code> Returns a <code>PaginatedResult</code> page containing <code>Stats</code> objects in the <code>PaginatedResult#items</code> attribute returned from the stats request</li>
		<li><code>(RSC6b)</code> Supports the following params:
		<ul>
			<li><code>(RSC6b1)</code> <code>start</code> and <code>end</code> are timestamp fields represented as milliseconds since epoch, or where suitable to the language, Date or Time objects. <code>start</code> must be equal to or less than <code>end</code> and is unaffected by the request direction</li>
			<li><code>(RSC6b2)</code> <code>direction</code> backwards or forwards; if omitted the direction defaults to the REST API default (backwards)</li>
			<li><code>(RSC6b3)</code> <code>limit</code> supports up to 1,000 items; if omitted the limit defaults to the REST API default (100)</li>
			<li><code>(RSC6b4)</code> <code>unit</code> is the period for which the stats will be aggregated by, values supported are <code>minute</code>, <code>hour</code>, <code>day</code> or <code>month</code>; if omitted the unit defaults to the REST API default (<code>minute</code>)</li>
		</ul></li>
	</ul></li>
	<li><code>(RSC16)</code> <code>RestClient#time</code> function sends a get request to <code>rest.ably.io/time</code> and returns the server time in milliseconds since epoch or as a Date/Time object where suitable</li>
	<li><code>(RSC7)</code> Sends REST requests over HTTP and HTTPS to the REST end-point <code>rest.ably.io</code></li>
	<li><code>(RSC18)</code> If <code>ClientOptions#tls</code> is true, then all communication is over HTTPS. If false, all communication is over HTTP however Basic Auth over HTTP will raise an exception as private keys cannot be submitted over an insecure connection. See <code>Auth</code> below</li>
	<li><code>(RSC8)</code> Supports two protocols:
	<ul>
		<li><code>(RSC8a)</code> <a href="http://msgpack.org/">MessagePack</a> binary protocol (this is the default for environments having a suitable level or support for binary data)</li>
		<li><code>(RSC8b)</code> JSON text protocol (used when <code>useBinaryProtocol</code> option is false)</li>
	</ul></li>
	<li><code>(RSC9)</code> Uses <code>Auth</code> to establish what authentication scheme to use, how to authenticate, and automatic issuing of tokens when necessary</li>
	<li><code>(RSC10)</code> If a REST request responds with 401 with code 40140, then the server is indicating the token is no longer valid. Using the <code>Auth</code> class a token should be automatically issued if possible, otherwise an error should be indicated (e.g. exception raised or an error passed in callback as appropriate to the language).</li>
	<li><code>(RSC11)</code> Requests are sent to the default endpoint <code>rest.ably.io</code>. However, if the <code>host</code> option is set, the client will send requests to the specified host. If <code>environment</code> option is configured, the environment name is prefixed to the default host endpoint and the <code>host</code> is set accordingly. For example, if the <code>environment</code> is set to sandbox, then the <code>host</code> endpoint will become <code>sandbox-rest.ably.io</code></li>
	<li><code>(RSC12)</code> REST endpoint host is configurable in the Client constructor with the option <code>restHost</code></li>
	<li><code>(RSC13)</code> The client library must use the connection and request timeouts specified in the <code>ClientOptions</code>, falling back to the defaults described in <code>ClientOptions</code> below</li>
	<li><code>(RSC14)</code> Authentication
	<ul>
		<li><code>(RSC14a)</code> Supports basic authentication when an API key is provided with the <code>key</code> option.  The API key follows the format <code>"KEY_NAME:KEY_SECRET"</code> so when authenticating using basic auth, the key name can be used as the username and the key secret as the password.</li>
		<li><code>(RSC14b)</code> Supports token authentication if one or more of <code>token</code>, <code>tokenDetails</code>, <code>authCallback</code> or <code>authUrl</code> are provided.  If <code>useTokenAuth</code> is true or a <code>clientId</code> is provided when the library is instanced, then token authentication is always used.</li>
		<li><code>(RSC14c)</code> When a <code>token</code> or <code>tokenDetails</code> is used to instance the library, and no means to renew the token is provided (either an API key, <code>authCallback</code> or <code>authUrl</code>), if the server responds with 40140 (token expired) to a request, the client library should indicate an error and not retry the request.</li>
		<li><code>(RSC14d)</code> When the client does have a means to renew the token automatically, and the token has expired or the server has responded with 40140 (token expired), then the client should automatically renew the token and resend the request.</li>
	</ul></li>
	<li><code>(RSC15)</code> Host Fallback
	<ul>
		<li><code>(RSC15a)</code> All HTTP requests sent to Ably are fault-tolerant and will fallback to an alternative host name if the default host endpoint is unreachable, or indicates that it is unserviceable with a 500 to 504 status code. This ensures that a client library is able to work around routing or other problems with the user&#8217;s closest data center.  For example, if a <code>POST</code> request to <code>rest.ably.io</code> fails because the default endpoint is unreachable or unserviceable, then the <code>POST</code> request should be retried again against all the fallback hosts <code>[a-e].ably-realtime.com</code>.</li>
		<li><code>(RSC15b)</code> This fallback behaviour only applies to the default <code>rest.ably.io</code> endpoint; if either <code>host</code> or <code>environment</code> options are set, no fallback host is used.</li>
		<li><code>(RSC15c)</code> See the <a href="https://github.com/ably/ably-java/blob/master/src/io/ably/transport/Defaults.java#L7">default fallback hosts</a> and the <a href="https://github.com/ably/ably-java/blob/master/src/io/ably/http/Http.java#L204-L224">fallback mechanism implemented in Java for POST requests</a> as an example.</li>
		<li><code>(RSC15d)</code> Automatic retries to fallback hosts will not occur for any other HTTP status codes. For example, if the credentials are invalid or the maxmimum message length has been exceeded, then resending the request to an alternative data center will not fix the problem and will only increase the load on other data centers. See the <a href="https://github.com/ably/ably-common/blob/master/protocol/errors.json#L11">complete list of Ably error codes</a> and a <a href="https://github.com/ably/ably-java/issues/14">discussion in the Java library about this</a></li>
	</ul></li>
	<li><code>(RSC17)</code> When instancing the library, if a <code>clientId</code> attribute is set in <code>ClientOptions</code>, then the <code>Auth#clientId</code> attribute will contain the provided <code>clientId</code></li>
</ul>
<h3 id="rest-auth">Auth</h3>
<ul>
	<li><code>(RSA1)</code> Basic Auth connects over HTTPS by default.  If HTTP and Basic Auth are used, an exception will be raised</li>
	<li><code>(RSA11)</code> When using Basic Auth, the API key is Base64 encoded and included in an <code>Authorization</code> header, as specified in <a href="https://tools.ietf.org/html/rfc7235">RFC7235</a></li>
	<li><code>(RSA2)</code> Basic Auth is the default authentication scheme if an API key exists</li>
	<li><code>(RSA3)</code> Token Auth:
	<ul>
		<li><code>(RSA3a)</code> Can be used over HTTP or HTTPs</li>
		<li><code>(RSA3b)</code> For REST requests, the token string is Base64 encoded and used in the <code>Authorization: Bearer</code> header</li>
		<li><code>(RSA3c)</code> For Realtime connections, the querystring param <code>access_token</code> is appended to the URL endpoint</li>
	</ul></li>
	<li><code>(RSA4)</code> Token Auth is used if <code>useTokenAuth</code> is set to true, or if <code>useTokenAuth</code> is unspecified and any one of the following conditions cause token auth to be selected as the default: a <code>clientId</code> is specified; <code>authUrl</code> or <code>authCallback</code> is provided; an explicit <code>token</code> or <code>TokenDetails</code> is provided</li>
	<li><code>(RSA14)</code> If Token Auth is selected, an exception will be raised if a token is not provided or there is no means to generate a token. For example, if only the option <code>useTokenAuth</code> is specified, and a <code>key</code> is not provided, then the client library is unable to authenticate or issue a token</li>
	<li><code>(RSA15)</code> If Token Auth is selected and <code>clientId</code> has been set in the <code>ClientOptions</code> when the library was instanced:
	<ul>
		<li><code>(RSA15a)</code> Any <code>clientId</code> provided in <code>ClientOptions</code> must match any non <code>null</code> <code>clientId</code> value in <code>TokenDetails</code> or <code>connectionDetails</code> of the <code>CONNECTED</code> <code>ProtocolMessage</code>, where applicable</li>
		<li><code>(RSA15b)</code> If the <code>clientId</code> from <code>TokenDetails</code> or <code>connectionDetails</code> contains only a wildcard string <code>'*'</code>, then the client is permitted to be either unauthenticated (effectively anonymous without a <code>clientId</code>) or authenticated providing a <code>clientId</code> when communicating with Ably</li>
		<li><code>(RSA15c)</code> Following an auth request which uses a <code>TokenDetails</code> or <code>TokenRequest</code> object that contains an incompatible <code>clientId</code>, the library should change the connection state to <code>FAILED</code> and emit an error</li>
	</ul></li>
	<li><code>(RSA5)</code> TTL for new tokens is specified in milliseconds and defaults to the REST API default (1 hour)</li>
	<li><code>(RSA6)</code> The <code>capability</code>, if not specified, defaults to allow all operations permitted for the key associated with the token</li>
	<li><code>(RSA7)</code> <code>clientId</code> and authenticated clients:
	<ul>
		<li><code>(RSA7a)</code> If a <code>clientId</code> is provided in the <code>ClientOptions</code>, or is present in the current authentication token, then the client is considered to be authenticated (it has a <code>clientId</code> that is implicit in all operations). Note that an authentication token <code>clientId</code> wildcard value of <code>'*'</code> is the exception where the client is not necessarily authenticated and any <code>clientId</code> is permitted. The following applies to authenticated clients:
		<ul>
			<li><code>(RSA7a1)</code> All operations (such as message publishing or presence) will have an implicit <code>clientId</code>. The Ably service automatically updates the <code>clientId</code> attribute (when empty) for all <code>Message</code> and <code>PresenceMessage</code> messages received from that authenticated client, and any messages then published from the Ably service, will have the <code>clientId</code> attribute populated. It is therefore expected that Ably client libraries do not explicitly set the <code>clientId</code> field on messages published when <code>clientId</code> is implicit in the connection or authentication scheme</li>
			<li><code>(RSA7a2)</code> If <code>clientId</code> is provided in <code>ClientOptions</code>, and an API key is provided along with no other means to generate a token, the client library will authenticate with Ably and obtain a token using the provided <code>clientId</code> ensuring the token is restricted to operations for that <code>clientId</code></li>
			<li><code>(RSA7a3)</code> <code>Auth#clientId</code> attribute returns a string value for the authenticated client&#8217;s <code>clientId</code></li>
		</ul></li>
		<li><code>(RSA12)</code> <code>Auth#clientId</code> attribute is <code>null</code>, when following authentication, the <code>clientId</code> attribute of the <code>TokenDetails</code> is a wildcard <code>'*'</code>, indicating that any <code>clientId</code> can be used by this client</li>
		<li><code>(RSA7b)</code> <code>Auth#clientId</code> is not <code>null</code> when:
		<ul>
			<li><code>(RSA7b1)</code> A <code>clientId</code> is provided in the <code>ClientOptions</code>. <code>clientId</code> should be a string</li>
			<li><code>(RSA7b2)</code> Token authentication is being used, and the <code>TokenRequest</code> or <code>TokenDetails</code> object, used for authentication, has a <code>clientId</code> value that is not <code>null</code> or a wildcard string <code>'*'</code></li>
			<li><code>(RSA7b3)</code> Following a realtime connection being established, if the <code>CONNECTED</code> <code>ProtocolMessages</code> contains a <code>clientId</code> that is both not <code>null</code> and not a wildcard string <code>'*'</code>. <code>clientId</code> is an attribute of <code>ProtocolMessage#connectionDetails</code> within a <code>CONNECTED</code> <code>ProtocolMessage</code></li>
		</ul></li>
		<li><code>(RSA7c)</code> A <code>clientId</code> provided in the <code>ClientOptions</code> when instancing the library must be either <code>null</code> or a string, and cannot contain only a wilcard <code>'*'</code> value which is reserved</li>
	</ul></li>
	<li><code>(RSA8)</code> <code>Auth#requestToken</code> function:
	<ul>
		<li><code>(RSA8e)</code> Method signature is <code>requestToken(TokenParams, AuthOptions)</code>. <code>TokenParams</code> and <code>AuthOptions</code> are optional. When provided, the values supersede matching client library configured params and options.</li>
		<li><code>(RSA8a)</code> Implicitly creates a <code>TokenRequest</code> if required, and requests a token from Ably if required. Returns a <code>TokenDetails</code> object</li>
		<li><code>(RSA8b)</code> Supports all <code>TokenParams</code> in the function arguments, which override defaults for <code>Client</code> <code>Auth</code>.</li>
		<li><code>(RSA8c)</code> When <code>authUrl</code> option is set, it will query the provided URL to obtain a <code>TokenRequest</code> or the token itself (either a token string or a <code>TokenDetails</code>). The query is performed using the given URL using the HTTP method in <code>authMethod</code>, headers (from <code>authHeaders</code>) and supplementary params (from <code>authParams</code>). The token retrieved is assumed by the library to be a token string if the response has <code>Content-Type</code> <code>"text/plain"</code>, or taken to be a <code>TokenRequest</code> or <code>TokenDetails</code> object if the response has <code>Content-Type</code> <code>"application/json"</code>. <code>authMethod</code> can be either <code>GET</code> or <code>POST</code>, or if not specified, will default to <code>GET</code>. It can be quite difficult to add test coverage for these scenarios &#8211; as such, we have developed a simple echo server that can be used in your tests, see the <a href="https://github.com/ably/ably-js/commit/e77b2c6c197bc71f3d27084fe54524724a00bc92">ably-js authUrl echo tests</a>
		<ul>
			<li><code>(RSA8c1)</code> <code>TokenParams</code> and any configured <code>authParams</code> are always sent to the <code>authUrl</code> as follows:
			<ul>
				<li><code>(RSA8c1a)</code> When the <code>authMethod</code> is <code>GET</code> or unspecified, the combined params are appened to the URL as query string params</li>
				<li><code>(RSA8c1b)</code> When the <code>authMethod</code> is <code>POST</code>, the combined params are sent in the body of the <code>POST</code> request</li>
			</ul></li>
			<li><code>(RSA8c2)</code> <code>TokenParams</code> take precedence over any configured <code>authParams</code> when a name conflict occurs</li>
			<li><code>(RSA8c3)</code> Specifying <code>authParams</code> as part of <code>AuthOptions</code> replaces any configured <code>authParams</code> specified in <code>ClientOptions</code>. As the key/value pairs are not merged, this enables a developer to delete <code>authParams</code> where necessary by providing an entire new set of <code>authParams</code></li>
		</ul></li>
		<li><code>(RSA8d)</code> When <code>authCallback</code> option is set, it will invoke the callback, passing in the <code>TokenParams</code>, and expects either a token string, a <code>TokenDetails</code> object or a <code>TokenRequest</code> object to be returned, which will in turn be used to request a token from Ably</li>
		<li><code>(RSA8f)</code> A test should exist for the following:
		<ul>
			<li><code>(RSA8f1)</code> Request a token with a <code>null</code> value <code>clientId</code>, authenticate a client with the token, publish a message without an explicit <code>clientId</code>, and ensure the message published does not have a <code>clientId</code>. Check that <code>Auth#clientId</code> is <code>null</code></li>
			<li><code>(RSA8f2)</code> Request a token with a <code>null</code> value <code>clientId</code>, authenticate a client with the token, publish a message with an explicit <code>clientId</code> value, and ensure that the message is rejected</li>
			<li><code>(RSA8f3)</code> Request a token with a wildcard <code>'*'</code> value <code>clientId</code>, authenticate a client with the token, publish a message without an explicit <code>clientId</code>, and ensure the message published does not have a <code>clientId</code>. Check that <code>Auth#clientId</code> is <code>null</code></li>
			<li><code>(RSA8f4)</code> Request a token with a wildcard <code>'*'</code> value <code>clientId</code>, authenticate a client with the token, publish a message with an explicit <code>clientId</code> value, and ensure that the message published has the provided <code>clientId</code></li>
		</ul></li>
	</ul></li>
	<li><code>(RSA9)</code> <code>Auth#createTokenRequest</code> function:
	<ul>
		<li><code>(RSA9h)</code> Method signature is <code>createTokenRequest(TokenParams, AuthOptions)</code>. <code>TokenParams</code> and <code>AuthOptions</code> are optional. When provided, the values supersede any client library configured params and options.</li>
		<li><code>(RSA9a)</code> Returns a signed <code>TokenRequest</code> object that can be used to obtain a token from Ably. This is useful for servers that can create a <code>TokenRequest</code> signed with the API key without communicating with Ably directly. The <code>TokenRequest</code> can then be passed to a designated client that is then responsible for communicating with Ably and requesting a token for authentication from that <code>TokenRequest</code></li>
		<li><code>(RSA9b)</code> Supports all <code>AuthOptions</code></li>
		<li><code>(RSA9c)</code> Generates a unique 16+ character <code>nonce</code> if none is provided; the nonce is used to protect against replay attacks</li>
		<li><code>(RSA9d)</code> Generates a <code>timestamp</code> from current time if not provided, will retrieve the server time if <code>queryTime</code> is true</li>
		<li><code>(RSA9e)</code> TTL is optional and specified in milliseconds</li>
		<li><code>(RSA9f)</code> Capability JSON text can be provided that specifies the rights of the token in terms of the channel(s) authorised and the permitted operations on each</li>
		<li><code>(RSA9g)</code> A valid HMAC is created using the key secret  to sign the <code>TokenRequest</code> so that it can be used by any client to request a token without having or exchanging any secrets</li>
		<li><code>(RSA9i)</code> Adheres to all requirements in <code>RSA8</code> relating to <code>TokenParams</code>, <code>authCallback</code> and <code>authUrl</code></li>
	</ul></li>
	<li><code>(RSA10)</code> <code>Auth#authorise</code> function:
	<ul>
		<li><code>(RSA10a)</code> Instructs the library to create a token if needed and uses Token Auth for all future requests</li>
		<li><code>(RSA10j)</code> Method signature is <code>authorise(TokenParams, AuthOptions)</code>. <code>TokenParams</code> and <code>AuthOptions</code> are optional. When provided, the values supersede any client library configured params and options.</li>
		<li><code>(RSA10b)</code> Supports all <code>AuthOptions</code> and <code>TokenParams</code> in the function arguments</li>
		<li><code>(RSA10c)</code> Will not create a new token unless no previous token exists or current token has expired. Please note that a buffer of 15s for token expiry is recommended to avoid race conditions where the token is valid at the time of the request, but invalid when it reaches the server. Therefore, we recommend that a token is considered expired 15s before the time field `expires`</li>
		<li><code>(RSA10d)</code> If the <code>AuthOption</code> argument&#8217;s <code>force</code> attribute is true, it will force <code>Auth#authorise</code> to issue a new token even if an existing token exists</li>
		<li><code>(RSA10e)</code> Adheres to the implementation of <code>requestToken</code> when issuing new tokens</li>
		<li><code>(RSA10f)</code> Returns a <code>TokenDetails</code> object that contains the token string + token metadata</li>
		<li><code>(RSA10g)</code> Stores the <code>AuthOptions</code> and <code>TokenParams</code> arguments as defaults for subsequent authorisations</li>
		<li><code>(RSA10h)</code> Will use the configured <code>Auth#clientId</code> by default, if not <code>null</code></li>
		<li><code>(RSA10i)</code> Adheres to all requirements in <code>RSA8</code> relating to <code>TokenParams</code>, <code>authCallback</code> and <code>authUrl</code></li>
	</ul></li>
</ul>
<h3 id="rest-channels">Channels</h3>
<ul>
	<li><code>(RSN1)</code> <code>Channels</code> is a collection of <code>Channel</code> objects accessible through <code>Rest#channels</code></li>
	<li><code>(RSN2)</code> Methods should exist to check if a channel exists or iterate through the existing channels</li>
	<li><code>(RSN3)</code> <code>Channels#get</code> function:
	<ul>
		<li><code>(RSN3a)</code> Creates a new <code>Channel</code> object for the specified channel if none exists, or returns the existing channel. <code>ChannelOptions</code> can be specified when instancing a new <code>Channel</code></li>
		<li><code>(RSN3b)</code> If options are provided, the options are set on the <code>Channel</code></li>
		<li><code>(RSN3c)</code> Accessing an existing <code>Channel</code> with options in the form <code>Channels#get(channel, options)</code> will update the options on the channel and then return the existing <code>Channel</code> object</li>
	</ul></li>
	<li><code>(RSN4)</code> <code>Channels#release</code> function:
	<ul>
		<li><code>(RSN4a)</code> Releases the channel resource i.e. it&#8217;s deleted and can then be garbage collected</li>
	</ul></li>
</ul>
<h3 id="rest-channel">Channel</h3>
<ul>
	<li><code>(RSL1)</code> <code>Channels#publish</code> function:
	<ul>
		<li><code>(RSL1a)</code> Expects either an array of <code>Message</code> objects or a <code>name</code> string and <code>data</code> payload.</li>
		<li><code>(RSL1b)</code> When <code>name</code> and <code>data</code> is provided, a single message is published to Ably</li>
		<li><code>(RSL1c)</code> When an array of <code>Message</code> objects is provided, a single request is made to Ably. When publishing multiple messages, this approach is more efficient. However, a yet to be implemented feature should limit the total number of messages bundled in a single POST based on the default max request size, and would reject the publish and indicate an error if any single message exceeds that limit</li>
		<li><code>(RSL1d)</code> Indicates an error if the message was not successfully published to Ably</li>
		<li><code>(RSL1e)</code> Allows <code>name</code> and or <code>data</code> to be <code>null</code>.  If any of the values are null, then key is not sent to Ably i.e. a payload with a <code>null</code> value for <code>data</code> would be sent as follows <code>{ "name": "click" }</code></li>
		<li><code>(RSL1f)</code> Unauthenticated clients using basic auth without a <code>clientId</code> (i.e. any <code>clientId</code> is permitted):
		<ul>
			<li><code>(RSL1f1)</code> When a <code>Message</code> with a <code>clientId</code> value is published, Ably will accept and publish that message with the provided <code>clientId</code>. A test should assert via the history API that the <code>clientId</code> of the published <code>Message</code> is correct for both authentication schemes (token and basic)</li>
		</ul></li>
		<li><code>(RSL1g)</code> Authenticated clients with a <code>clientId</code> (as a result of either an explicitly configured <code>clientId</code> in <code>ClientOptions</code>, or implicitly through token auth):
		<ul>
			<li><code>(RSL1g1)</code> When publishing a <code>Message</code> with the <code>clientId</code> attribute set to <code>null</code>:
			<ul>
				<li><code>(RSL1g1a)</code> It is unnecessary for the client to set the <code>clientId</code> of the <code>Message</code> before publishing</li>
				<li><code>(RSL1g1b)</code> Ably is expected to automatically assign a <code>clientId</code> upon receiving the <code>Message</code>. A test should assert via the history API that the <code>clientId</code> value is populated for the <code>Message</code> when received</li>
			</ul></li>
			<li><code>(RSL1g2)</code> When publishing a <code>Message</code> with the <code>clientId</code> attribute value set to the authenticated client&#8217;s <code>clientId</code>, Ably will accept the message and publish it. A test should assert that the <code>clientId</code> value is populated for the <code>Message</code> when received</li>
			<li><code>(RSL1g3)</code> When publishing a <code>Message</code> with a different <code>clientId</code> attribute value to the authenticated <code>clientId</code>, the client library should reject the message, and indicate an error. The connection and channel remains available for further operations</li>
			<li><code>(RSL1g4)</code> When publishing a message with an explicit <code>clientId</code> that is incompatible with the <code>clientId</code> (either inferred or explicitly configured in the token or <code>ClientOptions</code>), the library will reject the message immediately and indicate an error</li>
		</ul></li>
		<li><code>(RSL1h)</code> Where the library language permits, the <code>Channel#publish(name, data)</code> method should provide an optional argument that allows the <code>clientId</code> value to be specified such as <code>Channel#publish('event', 'data', { clientId: 'John' })</code></li>
	</ul></li>
	<li><code>(RSL2)</code> <code>Channel#history</code> function:
	<ul>
		<li><code>(RSL2a)</code> Returns a <code>PaginatedResult</code> page containing the first page of messages in the <code>PaginatedResult#items</code> attribute returned from the history request</li>
		<li><code>(RSL2b)</code> Supports the following params:
		<ul>
			<li><code>(RSL2b1)</code> <code>start</code> and <code>end</code> are timestamp fields represented as milliseconds since epoch, or where suitable to the language, Time objects. <code>start</code> must be equal to or less than <code>end</code> and is unaffected by the request direction.</li>
			<li><code>(RSL2b2)</code> <code>direction</code> backwards or forwards; if omitted the direction defaults to the REST API default (backwards)</li>
			<li><code>(RSL2b3)</code> <code>limit</code> supports up to 1,000 items; if omitted the direction defaults to the REST API default (100)</li>
		</ul></li>
	</ul></li>
	<li><code>(RSL3)</code> <code>Channel#presence</code> attribute returns a <code>Presence</code> object for this channel</li>
	<li><code>(RSL4)</code> Message encoding
	<ul>
		<li><code>(RSL4a)</code> Payloads must be binary, strings, or objects capable of JSON representation, or can be empty (omitted). Any other data type should not be permitted and an exception should be raised</li>
		<li><code>(RSL4b)</code> If a message is encoded, the <code>encoding</code> attribute represents the encoding(s) applied in right to left format i.e. &#8220;utf-8/base64&#8221; indicates that the original payload has &#8220;utf-8&#8221; encoding and has subsequently been encoded in Base64 format.</li>
		<li><code>(RSL4c)</code> When using MessagePack Message encoding
		<ul>
			<li><code>(RSL4c1)</code> a binary Message payload is encoded as MessagePack binary type</li>
			<li><code>(RSL4c2)</code> a string Message payload is encoded as MessagePack string type</li>
			<li><code>(RSL4c3)</code> a JSON Message payload is stringified either as a JSON Object or Array and encoded as MessagePack string type and the <code>encoding</code> attribute is set to &#8220;json&#8221;</li>
			<li><code>(RSL4c4)</code> All messages received will deliver payloads in the format they were sent in i.e. binary, string, or a structured type containing the parsed JSON</li>
		</ul></li>
		<li><code>(RSL4d)</code> When using JSON Message encoding
		<ul>
			<li><code>(RSL4d1)</code> a binary Message payload is encoded as Base64 and represented as a JSON string the <code>encoding</code> attribute is set to &#8220;base64&#8221;</li>
			<li><code>(RSL4d2)</code> a string Message payload is represented as a JSON string</li>
			<li><code>(RSL4d3)</code> a JSON Message payload is stringified either as a JSON Object or Array and represented as a JSON string and the <code>encoding</code> attribute is set to &#8220;json&#8221;</li>
			<li><code>(RSL4d4)</code> All messages received will be decoded based on the <code>encoding</code> field and deliver payloads in the format they were sent in i.e. binary, string, or a structured type containing the parsed JSON</li>
		</ul></li>
	</ul></li>
	<li><code>(RSL5)</code> Message payload encryption
	<ul>
		<li><code>(RSL5a)</code> When a <code>Channel</code> is instanced with the option <code>encrypted</code> true, message payloads will be automtically encrypted when sent to Ably and decrypted when received on this channel. The cipher configuration is set with the <code>cipherParams</code></li>
		<li><code>(RSL5b)</code> AES 256 and 128 CBC encryption must be supported</li>
		<li><code>(RSL5c)</code> Tests must exist that encrypt and decrypt the following fixture data for <a href="https://github.com/ably/ably-common/blob/master/test-resources/crypto-data-128.json">AES 128</a> and <a href="https://github.com/ably/ably-common/blob/master/test-resources/crypto-data-256.json">AES 256</a> to ensure the client library encryption is compatible across libraries</li>
	</ul></li>
	<li><code>(RSL6)</code> Message decoding
	<ul>
		<li><code>(RSL6a)</code> All messages received will be decoded automatically based on the <code>encoding</code> field and the payloads will be converted into the format they were originally sent using i.e. binary, string, or JSON</li>
		<li><code>(RSL6b)</code> If, for example, incompatible encryption details are provided or invalid Base64 is detected in the message payload, an error message will be sent to the logger, but the message will still be delivered with last successful decoding and the <code>encoding</code> field. For example, if a message had a decoding of &#8220;utf-8/cipher+aes-128-cbc/base64&#8221;, and the payload was successfully Base64 decoded but the payload could not be encrypted because the <code>CipherParam</code> details were not configured, the message would be delivered with a binary payload and an <code>encoding</code> with the value &#8220;utf-8/cipher+aes-128-cbc&#8221;</li>
	</ul></li>
</ul>
<h3 id="rest-presence">Presence</h3>
<ul>
	<li><code>(RSP1)</code> Presence object is associated with a single channel and is accessible through <code>Channel#presence</code></li>
	<li><code>(RSP2)</code> There is no way to register a member as present on a channel via the REST API</li>
	<li><code>(RSP3)</code> <code>Presence#get</code> function:
	<ul>
		<li><code>(RSP3a)</code> Returns a <code>PaginatedResult</code> page containing the first page of members present in the <code>PaginatedResult#items</code> attribute returned from the presence request. Each member is represented as a <code>PresenceMessage</code>
		<ul>
			<li><code>(RSP3a1)</code> <code>limit</code> supports up to 1,000 items; if unspecified it defaults to the REST API default (100)</li>
			<li><code>(RSP3a2)</code> <code>clientId</code> filters members by the provided <code>clientId</code></li>
			<li><code>(RSP3a3)</code> <code>connectionId</code> filters members by the provided <code>connectionId</code></li>
		</ul></li>
	</ul></li>
	<li><code>(RSP4)</code> <code>Presence#history</code> function:
	<ul>
		<li><code>(RSP4a)</code> Returns a <code>PaginatedResult</code> page containing the first page of messages in the <code>PaginatedResult#items</code> attribute returned from the presence request</li>
		<li><code>(RSP4b)</code> Supports the following params:
		<ul>
			<li><code>(RSP4b1)</code> <code>start</code> and <code>end</code> are timestamp fields represented as milliseconds since epoch, or where appropriate to the language, Date/Time objects. <code>start</code> must be equal to or less than <code>end</code> and is unaffected by the request direction.</li>
			<li><code>(RSP4b2)</code> <code>direction</code> backwards or forwards; if unspecified defaults to the REST API default (backwards)</li>
			<li><code>(RSP4b3)</code> <code>limit</code> supports up to 1,000 items; if unspecified defaults to the REST API default (100)</li>
		</ul></li>
	</ul></li>
	<li><code>(RSP5)</code> Presence Messages retrieved are decoded in the same way that messages are decoded</li>
</ul>
<h2 id="realtime">Realtime client library features</h2>
<p>The Ably Realtime client libraries establish and maintain a persistent connection to Ably and provide methods to publish and subscribe to messages over a low latency realtime connection.</p>
<p>The Realtime library is a superset of the REST library and as such all Realtime libaries provide the functionality available in the REST library in addition to Realtime-specific features.</p>
<p>The threading and/or asynchronous model for each realtime library will vary by language and it is therefore up to the developer to decide on the best approach for each given client library. For example, Node.js and Ruby (EventMachine) use a similar callback single threaded evented approach that ensures all public methods are non-blocking. Java and .NET use a threaded model whereby the <code>Connection</code> runs in its own thread. Go makes extensive use of goroutines and channels.</p>
<h3 id="realtimeclient">RealtimeClient</h3>
<ul>
	<li><code>(RTC1)</code> Supports all the same <code>ClientOptions</code> as the <code>RestClient</code> in addition to:
	<ul>
		<li><code>(RTC1a)</code> <code>echoMessages</code> boolean is true by default. If false, it prevents messages originating from this connection being echoed back on the same connection</li>
		<li><code>(RTC1b)</code> <code>autoConnect</code> boolean is true by default. If true, as soon as the client library is instanced, it will connect to Ably. If false, the client library will wait for an explicit <code>Connection#connect</code> to be called before connecting</li>
		<li><code>(RTC1c)</code> <code>recover</code> string, when set, will attempt to recover the connection state of a previous connection</li>
		<li><code>(RTC1d)</code> <code>realtimeHost</code> string, when set, will modify the realtime endpoint host used by this client library</li>
		<li><code>(RTC1e)</code> <code>environment</code> string, when set, will modify both the REST and realtime endpoint hosts by prefixing the environment to the default endpoint host with a hypen delimiter. For example, a <code>RealtimeClient</code> with an <code>environment</code> of &#8220;sandbox&#8221;, would use &#8220;sandbox-rest.ably.io&#8221; as the <code>restHost</code> and <code>sandbox-realtime.ably.io</code> as the <code>realtimeHost</code></li>
	</ul></li>
	<li><code>(RTC2)</code> <code>RealtimeClient#connection</code> attribute provides access to the underlying <code>Connection</code> object</li>
	<li><code>(RTC3)</code> <code>RealtimeClient#channels</code> attribute provides access to the underlying <code>Channels</code> object</li>
	<li><code>(RTC4)</code> <code>RealtimeClient#auth</code> attribute provides access to the <code>Auth</code> object that was instanced with the <code>ClientOptions</code> provided in the <code>RealtimeClient</code> constructor
	<ul>
		<li><code>(RTC4a)</code> Unlike the stateless REST client library, the <code>Auth#clientId</code> may be populated when the connection is established.  The <code>CONNECTED</code> <code>ProtocolMessage</code> may contain a <code>clientId</code> that notifies the <code>RealtimeClient</code> that all further operations are implicitly for that <code>clientId</code>, and operations for any other <code>clientId</code> are no longer permitted. See <code>RSA7b</code> for complete details</li>
	</ul></li>
	<li><code>(RTC5)</code> <code>RealtimeClient#stats</code> function:
	<ul>
		<li><code>(RTC5a)</code> Proxy to <code>RestClient#stats</code> presented with an async or threaded interface as appropriate</li>
		<li><code>(RTC5b)</code> Accepts all the same params as <code>RestClient#stats</code> and provides all the same functionality</li>
	</ul></li>
	<li><code>(RTC6)</code> <code>RealtimeClient#time</code> function:
	<ul>
		<li><code>(RTC6a)</code> Proxy to <code>RestClient#time</code> presented with an async or threaded interface as appropriate</li>
	</ul></li>
	<li><code>(RTC7)</code> The client library must use the configured timeouts specified in the <code>ClientOptions</code>, falling back to the <a href="#defaults">client library defaults</a> and defaults described in <code>ClientOptions</code> below</li>
</ul>
<h3 id="realtime-connection">Connection</h3>
<ul>
	<li><code>(RTN1)</code> <code>Connection</code> connects to the Ably service using a websocket connection. The <a href="https://github.ably.io/ably/ably-js">ably-js library</a> supports additional transports such as Comet and XHR streaming; however non-browser client libraries typically use only a websocket transport</li>
	<li><code>(RTN2)</code> The default host used for realtime websocket connections is <code>realtime.ably.io</code>, and the following query string params should be used when opening a new connection:
	<ul>
		<li><code>(RTN2a)</code> <code>format</code> should be <code>msgpack</code> (default) or <code>json</code></li>
		<li><code>(RTN2b)</code> <code>echo</code> should be <code>true</code> by default; <code>false</code> will prevent messages published by the client being echoed back</li>
		<li><code>(RTN2c)</code> <code>timestamp</code> should contain the milliseconds since the epoch</li>
		<li><code>(RTN2d)</code> <code>clientId</code> contains the provided <code>clientId</code> option of <code>ClientOptions</code>, unless <code>clientId</code> is <code>null</code></li>
		<li><code>(RTN2e)</code> Depending on the authentication scheme, either <code>accessToken</code> contains the token string, or <code>key</code> contains the API key</li>
	</ul></li>
	<li><code>(RTN3)</code> If connection option <code>autoConnect</code> is true, a connection is initiated immediately; otherwise a connection is only initiated following an explicit call to <code>connect()</code>.</li>
	<li><code>(RTN4)</code> EventEmitter and states:
	<ul>
		<li><code>(RTN4a)</code> Implements <code>EventEmitter</code> and emits events for state changes <code>INITIALIZED</code>, <code>CONNECTING</code>, <code>CONNECTED</code>, <code>DISCONNECTED</code>, <code>SUSPENDED</code>, <code>CLOSING</code>, <code>CLOSED</code>, <code>FAILED</code></li>
		<li><code>(RTN4b)</code> A new connection will emit the following events in order when connecting: <code>CONNECTING</code>, then <code>CONNECTED</code></li>
		<li><code>(RTN4c)</code> A connection will emit the following events when closing the connection: <code>CLOSING</code>, then <code>CLOSED</code></li>
		<li><code>(RTN4d)</code> <code>Connection#state</code> attribute is the current state of the connection</li>
		<li><code>(RTN4e)</code> A <code>ConnectionStateChange</code> object is emitted as the first argument for every connection state change</li>
		<li><code>(RTN4f)</code> Additionally, a <code>ConnectionStateChange</code> can be emitted that contains an <code>errorReason</code> which contains an <code>ErrorInfo</code> object with details of the error that has occurred for the <code>Connection</code>.</li>
	</ul></li>
	<li><code>(RTN5)</code> A test should exist that instances many (50+) clients simultaneously and performs a few basic operations such as attaching to a channel, publishing a message, and expecting all of those messages to arrive on all clients to ensure that there are no concurrency issues with the client library</li>
	<li><code>(RTN6)</code> A <code>Connection</code> is successful and considered <code>CONNECTED</code> once the websocket connection is open and the intial <code>CONNECTED</code> <code>ProtocolMessage</code> has been received</li>
	<li><code>(RTN19)</code> If the <code>CONNECTED</code> <code>ProtocolMessage</code> contains a <code>connectionDetails</code> property, the attributes within <code>ConnectionDetails</code> will be used as the defaults for this client library, overriding any configured options at the time the <code>CONNECTED</code> <code>ProtocolMessage</code> is received</li>
	<li><code>(RTN7)</code> <code>ACK</code> and <code>NACK</code>:
	<ul>
		<li><code>(RTN7a)</code> All <code>ProtocolMessage</code> <code>Presence</code> and <code>Message</code> objects sent to Ably expect either an <code>ACK</code> or <code>NACK</code> from Ably to confirm successful receipt and acceptance or failure respectively</li>
		<li><code>(RTN7b)</code> Every <code>ProtocolMessage</code> sent must contain a unique serially incrementing <code>msgSerial</code> integer value starting at zero. The <code>msgSerial</code> along with the <code>count</code> for incoming <code>ACK</code> and <code>NACK</code> <code>ProtocolMessages</code> indicates which messages succeeded or failed to be delivered</li>
		<li><code>(RTN7c)</code> If a connection enters the <code>CLOSED</code> or <code>FAILED</code> state, or if the connection state is lost, and a <code>ACK</code> or <code>NACK</code> has not yet been received for a message, the client should consider the delivery of those messages as failed</li>
	</ul></li>
	<li><code>(RTN8)</code> <code>Connection#id</code> attribute:
	<ul>
		<li><code>(RTN8a)</code> Is <code>null</code> until connected</li>
		<li><code>(RTN8b)</code> Is a unique string provided by Ably. You should have a test to ensure multiple connected clients have unique connection IDs</li>
	</ul></li>
	<li><code>(RTN9)</code> <code>Connection#key</code> attribute:
	<ul>
		<li><code>(RTN9a)</code> Is Null until connected</li>
		<li><code>(RTN9b)</code> Is a unique private connection key provided by Ably that is used to reconnect and retain connection state following an unexpected disconnection. You should have a test to ensure multiple connected clients have unique connection keys</li>
	</ul></li>
	<li><code>(RTN10)</code> <code>Connection#serial</code> attribute:
	<ul>
		<li><code>(RTN10a)</code> Is set to -1 once <code>CONNECTED</code></li>
		<li><code>(RTN10b)</code> Is always 0 when the first message has been sent and an <code>ACK</code> has been received confirming receipt of the message. The <code>serial</code> is updated whenever a <code>ProtocolMessage</code> is received that contains a <code>connectionSerial</code> value. A test should exist that checks that the serial number is not updated when a message is sent, but then increments by one when the <code>ACK</code> is received</li>
		<li><code>(RTN10c)</code> The last known <code>ProtocolMessage</code> <code>connectionSerial</code> is used when restoring connection state</li>
	</ul></li>
	<li><code>(RTN11)</code> <code>Connection#connect</code> function:
	<ul>
		<li><code>(RTN11a)</code> Explicitly connects to the Ably service if not already connected.</li>
		<li><code>(RTN11b)</code> An error will be indicated if the state is <code>CLOSING</code> as the connection must complete the close request before reconnecting</li>
		<li><code>(RTN11c)</code> Where the language permits, a callback with a success and failure state can be provided</li>
	</ul></li>
	<li><code>(RTN12)</code> <code>Connection#close</code> function:
	<ul>
		<li><code>(RTN12a)</code> Sends a <code>CLOSE</code> <code>ProtocolMessage</code> to the server, sets the state to <code>CLOSING</code> and waits for a <code>CLOSED</code> <code>ProtocolMessage</code> to be received</li>
		<li><code>(RTN12b)</code> If the <code>CLOSED</code> <code>ProtocolMessage</code> is not received within the <a href="#defaults">default realtime request timeout</a>, the transport will be disconnected and the connection will automatically move to the <code>CLOSED</code> state</li>
		<li><code>(RTN12c)</code> If the transport is abruptly closed following a <code>CLOSE</code> <code>ProtocolMessage</code> being sent, then the connection will automatically move to the <code>CLOSED</code> state</li>
	</ul></li>
	<li><code>(RTN13)</code> <code>Connection#ping</code> function:
	<ul>
		<li><code>(RTN13a)</code> Will send a <code>ProtocolMessage</code> with action <code>HEARTBEAT</code> the Ably service when connected and expects a <code>HEARTBEAT</code> message in response. If the client library language supports callbacks, then the callback will be called with the response time or error</li>
		<li><code>(RTN13b)</code> Will immediately indicate an error if in the <code>CLOSED</code> or <code>FAILED</code> state</li>
		<li><code>(RTN13c)</code> Will fail if a <code>HEARTBEAT</code> <code>ProtocolMessage</code> is not received within the <a href="#defaults">default realtime request timeout</a></li>
	</ul></li>
	<li><code>(RTN14)</code> <code>Connection</code> opening failures:
	<ul>
		<li><code>(RTN14a)</code> If an API key is invalid, then the connection will enter the <code>FAILED</code> state and the <code>errorReason</code> will be set on the <code>Connection</code> object as well as the emitted <code>ConnectionStateChange</code></li>
		<li><code>(RTN14b)</code> If a connection request fails because the token has expired, and the token is renewable, then a new token will be created and subsequent requests will be made without changing the state or emitting an error. If the token is not renewable, the connection will transition to the <code>FAILED</code> state</li>
		<li><code>(RTN14c)</code> A new connection attempt will fail if not connected within the <a href="#defaults">default realtime request timeout</a></li>
		<li><code>(RTN14d)</code> If a connection attempt fails for any recoverable reason (i.e. not an authentication failure), the <code>Connection#state</code> will change to <code>DISCONNECTED</code>, the <code>Connection#errorReason</code> will be updated, a <code>ConnectionStateChange</code> with the <code>errorReason</code> will be emitted, and new connection attempts will periodically be made until the maximum time in that state threshold is reached.  The <code>retryIn</code> attribute of the <code>ConnectionStateChange</code> object will contain the time in milliseconds until the next connection attempt. See the <code>disconnectedRetryTimeout</code> of <code>ClientOptions</code> below. Each time a new connection attempt is made the state will change to <code>CONNECTING</code> and then to <code>CONNECTED</code> if successful, or <code>DISCONNECTED</code> if unsuccessful and the <a href="#defaults">default <code>connectionStateTtl</code></a> has not been exceeded.</li>
		<li><code>(RTN14e)</code> Once the connection state has been in the <code>DISCONNECTED</code> state for more than the <a href="#defaults">default <code>connectionStateTtl</code></a>, the state will change to <code>SUSPENDED</code> and be emitted with the <code>errorReason</code>, and the <code>Connection#errorReason</code> will be updated. In this state, a new connection attempt will be made periodically as specified within <code>suspendedRetryTimeout</code> of <code>ClientOptions</code></li>
		<li><code>(RTN14f)</code> The connection will remain in the <code>SUSPENDED</code> state indefinitely, whilst periodically attempting to reestablish a connection</li>
	</ul></li>
	<li><code>(RTN15)</code> <code>Connection</code> failures once <code>CONNECTED</code>:
	<ul>
		<li><code>(RTN15a)</code> If a <code>Connection</code> transport is disconnected unexpectedly or if a token expires, then the <code>Connection</code> manager will immediately attempt to reconnect and restore the connection state. Connection state recovery is provided by the Ably service and ensures that whilst the client is disconnected, all events are queued and channel state is retained on the Ably servers. When a new connection is made with the correct connection recovery key, the client is able to catch up by receiving the queued <code>ProtocolMessages</code> from Ably. Connection state is only maintained for a brief period, up to a minute, so if a client is disconnected for a longer period connection state cannot be resumed</li>
		<li><code>(RTN15b)</code> In order for a connection to be resumed and connection state to be recovered, the client library reconnects to the websocket endpoint with two additional querystring params:
		<ul>
			<li><code>(RTN15b1)</code> <code>resume</code> is the private connection key assigned to the connection when the first <code>CONNECTED</code> <code>ProtocolMessage</code> was received</li>
			<li><code>(RTN15b2)</code> <code>connection_serial</code> is the most recent <code>ProtocolMessage#connectionSerial</code> received from Ably or <code>Connection#serial</code> which should be identical</li>
		</ul></li>
		<li><code>(RTN15c)</code> The system&#8217;s response to a resume request will be one of the following:
			<ul>
				<li><code>(RTN15c1)</code> <code>CONNECTED</code> <code>ProtocolMessage</code> with the same <code>connectionId</code> as the current client, and no <code>error</code>. In this case, the server is indicating that the resume succeeded, all channels are still attached, and all backlog messages are available</li>
				<li><code>(RTN15c2)</code> <code>CONNECTED</code> <code>ProtocolMessage</code> with the same <code>connectionId</code> as the current client, and an <code>error</code>. In this case, the server is indicating that the resume succeeded but with a non-fatal error, all channels are still attached, and some backlog messages may be unavailable. The <code>ErrorInfo</code> received should be emitted on the client <code>Connection</code> as well as all <code>ATTACHED</code> <code>Channel</code> objects.</li>
				<li><code>(RTN15c3)</code> <code>CONNECTED</code> <code>ProtocolMessage</code> with a new <code>connectionId</code>, and an error in <code>error</code>. In this case, a new connection has been established, the resume has failed, the channels are no longer attached, and the error indicates the resume problem which should be emitted. The client library should immediately detach all channels and set the <code>errorReason</code> on each detached <code>Channel</code></li>
				<li><code>(RTN15c4)</code> <code>ERROR</code> <code>ProtocolMessage</code> indicating a fatal error in the connection. The server will close the transport immediately after. If the <code>ERROR</code> is non-recoverable, the client will move to the <code>FAILED</code> state triggering all attached channels to move to the <code>FAILED</code> state as well</li>
			</ul></li>
		<li><code>(RTN15g)</code> When the connection resume has failed, all channels should be detached with a suitable error reason</li>
		<li><code>(RTN15f)</code> <code>ACK</code> and <code>NACK</code> responses for published messages can only ever be received on the transport connection on which those messages were sent. Therefore, once a transport drops, the client library must either fail the publish attempt, or re-attempt by re-sending the messages on a new transport if the resume was successful (i.e. the <code>CONNECTED</code> response includes the expected <code>connectionId</code>)</li>
		<li><code>(RTN15d)</code> Client libraries should have test coverage to ensure connection state recovery is working as expected by forciby disconnecting a client and checking that messages published on channels are delivered once the connection is resumed</li>
		<li><code>(RTN15e)</code> When a connection is resumed, the <code>Connection#key</code> may change and will be provided in the first <code>CONNECTED</code> <code>ProtocolMessage#connectionDetails</code> when the connection is established. The client library must update the <code>Connection#key</code> value with the new <code>connectionKey</code> value every time</li>
	</ul></li>
	<li><code>(RTN20)</code> When the client library can subscribe to the Operating System events for network/internet connectivity changes:
	<ul>
		<li><code>(RTN20a)</code> When <code>CONNECTED</code>, <code>CONNECTING</code> or <code>DISCONNECTING</code>, if the operating system indicates that the underlying internet connection is no longer available, then the client library should immediately change state to <code>DISCONNECTED</code> with a suitable <code>errorReason</code>. This state change will automatically trigger the client library to attempt to reconnect, see <code>RTN15</code> above</li>
		<li><code>(RTN20b)</code> When <code>DISCONNECTED</code> or <code>SUSPENDED</code>, if the operating system indicates that the underlying internet connection is now available, the client library should immediately attempt to connect</li>
	</ul></li>
	<li><code>(RTN16)</code> <code>Connection</code> recovery:
	<ul>
		<li><code>(RTN16a)</code> Connection recovery is similar to the automatic connection resume except that connection state is recovered explicitly because a <code>recover</code> key is passed to the Realtime library when instanced. Once a connection is recovered, all channels must be explicitly attached by the developer, and any messages queued to be delivered whilst the client was disconnected will be delivered</li>
		<li><code>(RTN16b)</code> <code>Connection#recoveryKey</code> is an attribute composed of the connection key and latest serial received on the connection</li>
		<li><code>(RTN16c)</code> <code>Connection#recoveryKey</code> becomes <code>Null</code> when a connection is explicitly <code>CLOSED</code> or <code>CLOSED</code> by the server, as connection state is not retained for connections closed intentionally. The <code>Connection#key</code> and <code>Connection#id</code> is set to <code>Null</code></li>
		<li><code>(RTN16d)</code> When a connection is successfully recovered, the <code>Connection#id</code> and <code>Connection#key</code> will be identical to the <code>id</code> &amp; <code>key</code> of the connection that was recovered</li>
		<li><code>(RTN16e)</code> If the <code>recover</code> option is missing or no longer valid when connecting to Ably, the client will connect anyway, but emit a <code>ConnectionStateChange</code> with an <code>errorReason</code>, and will additionally set the <code>Connection#errorReason</code> with an <code>ErrorInfo</code> object describing the failure</li>
	</ul></li>
	<li><code>(RTN17)</code> Host Fallback
	<ul>
		<li><code>(RTN17a)</code> All requests sent to Ably are fault-tolerant and will fallback to an alternative host if the default host is unreachable, or indicates that it is unserviceable with a 500 to 504 status code. This ensures that a client library is able to work around routing or other problems with the user&#8217;s closest datacenter. For example, if a connection attempt to <code>realtime.ably.io</code> fails because the default endpoint is unreachable or unserviceable, then the <code>Connection</code> manager should check if an internet connection is available by sending a request to our CDN <code>internet-up.ably-realtime.com/is-the-internet-up.txt</code> and looking for the text &#8220;yes&#8221; in the response.  If the text &#8220;yes&#8221; is included in the response, then the client library can assume it has a viable internet connection and should then immediately retry the connection against all the fallback hosts <code>[a-e].ably-realtime.com</code> in attempt to find an alternate healthy datacenter.</li>
		<li><code>(RTN17b)</code> The fallback behaviour only applies to the default <code>realtime.ably.io</code> endpoint; if either <code>host</code> or <code>environment</code> options are set, no fallback host is used.</li>
		<li><code>(RTN17c)</code> See the <a href="https://github.com/ably/ably-java/blob/master/src/io/ably/transport/Defaults.java#L7">default fallback hosts</a> and the <a href="https://github.com/ably/ably-java/blob/39f3f0226bd995bd6baffa1df47a0a4957d29c43/src/io/ably/transport/ConnectionManager.java#L428-L455">fallback mechanism implemented in the Java ConnectionManager</a> as an example.</li>
	</ul></li>
	<li><code>(RTN18)</code> Connection state change side effects:
	<ul>
		<li><code>(RTN18a)</code> When a connection enters the <code>DISCONNECTED</code> state, it will have no effect on the the channel states. Channels in the <code>ATTACHED</code> state will queue messages that are sent as soon as the connection is resumed</li>
		<li><code>(RTN18b)</code> When a connection enters the <code>SUSPENDED</code> state, all channels will move to the <code>DETACHED</code> state. Channels in the <code>DETACHED</code> state should reject publishing of messages</li>
		<li><code>(RTN18c)</code> When a channel enters the <code>FAILED</code> state, all channels will move to the <code>FAILED</code> state. Channels in the <code>FAILED</code> state should reject publishing of messages</li>
	</ul></li>
	<li><code>(RTN19)</code> Transport state side effects &#8211; when a transport is upgraded or disconnected for any reason:
	<ul>
		<li><code>(RTN19a)</code> Any <code>ProtocolMessage</code> that is awaiting an <code>ACK</code>/<code>NACK</code> on the old transport will not receive the <code>ACK</code>/<code>NACK</code> on the new transport. The client library must therefore resend any <code>ProtocolMessage</code> that is awaiting a <code>ACK</code>/<code>NACK</code> to Ably in order to receive the expected <code>ACK</code>/<code>NACK</code> for that message. The Ably service is responsible for keeping track of messages, ignoring duplicates and responding with suitable <code>ACK</code>/<code>NACK</code> messages</li>
		<li><code>(RTN19b)</code> If there are any pending channels i.e. in the <code>ATTACHING</code> or <code>DETACHING</code> state, the respective <code>ATTACH</code> or <code>DETACH</code> message should be resent to Ably</li>
		<li><code>(RTN19b)</code> If a <code>SYNC</code> is underway, ensure the client library adheres to <code>RTP3</code></li>
	</ul></li>
</ul>
<h3 id="realtime-channels">Channels</h3>
<ul>
	<li><code>(RTS1)</code> <code>Channels</code> is a collection of <code>Channel</code> objects accessible through <code>Realtime#channels</code></li>
	<li><code>(RTS2)</code> Methods should exist to check if a channel exists or iterate through the existing channels</li>
	<li><code>(RTS3)</code> <code>Channels#get</code> function:
	<ul>
		<li><code>(RTS3a)</code> Creates a new <code>Channel</code> object for the specified channel if none exists, or returns the existing channel. <code>ChannelOptions</code> can be specified when instancing a new <code>Channel</code></li>
		<li><code>(RTS3b)</code> If options are provided, the options are set on the <code>Channel</code> when creaing a new <code>Channel</code></li>
		<li><code>(RTS3c)</code> Accessing an existing <code>Channel</code> with options in the form <code>Channels#get(channel, options)</code> will update the options on the channel and then return the existing <code>Channel</code> object</li>
	</ul></li>
	<li><code>(RTS4)</code> <code>Channels#release</code> function:
	<ul>
		<li><code>(RTS4a)</code> Detaches the channel and then releases the channel resource i.e. it&#8217;s deleted and can then be garbage collected</li>
	</ul></li>
</ul>
<h3 id="realtime-channel">Channel</h3>
<ul>
	<li><code>(RTL1)</code> As soon as a <code>Channel</code> becomes attached, all incoming messages and presence messages are processed and emitted where applicable.  <code>PRESENCE</code> and <code>SYNC</code> messages are passed to the <code>Presence</code> object ensuring it maintains a map of current members on a channel in realtime.</li>
	<li><code>(RTL2)</code> EventEmitter and states:
	<ul>
		<li><code>(RTL2a)</code> Implements <code>EventEmitter</code> and emits events for state changes <code>INITIALIZED</code>, <code>ATTACHING</code>, <code>ATTACHED</code>, <code>DETACHING</code>, <code>DETACHED</code>, <code>FAILED</code></li>
		<li><code>(RTL2b)</code> <code>Channel#state</code> attribute is the current state of the channel</li>
		<li><code>(RTL2c)</code> Additionally, an <code>ERROR</code> event is emitted that contains an <code>ErrorInfo</code> object with details on an error that has occurred for the <code>Channel</code></li>
	</ul></li>
	<li><code>(RTL3)</code> Connection state change side effects:
	<ul>
		<li><code>(RTL3a)</code> If the connection state changes to <code>FAILED</code> then an <code>ATTACHING</code> or <code>ATTACHED</code> channel state will transition to <code>FAILED</code>, set the <code>errorReason</code> and emit the error event</li>
		<li><code>(RTL3b)</code> If the connection state changes to <code>CLOSED</code> then an <code>ATTACHING</code> or <code>ATTACHED</code> channel state will transition to <code>CLOSED</code></li>
	</ul></li>
	<li><code>(RTL4)</code> <code>Channel#attach</code> function:
	<ul>
		<li><code>(RTL4a)</code> If already <code>ATTACHED</code> or <code>ATTACHING</code> nothing is done</li>
		<li><code>(RTL4b)</code> If the connection state is <code>CLOSED</code>, <code>CLOSING</code>, <code>SUSPENDED</code> or <code>FAILED</code>, an exception should be thrown immediately</li>
		<li><code>(RTL4c)</code> Otherwise an <code>ATTACH</code> ProtocolMessage is sent to the server, the state changes to <code>ATTACHING</code> and the channel becomes <code>ATTACHED</code> when the confirmation <code>ATTACHED</code> ProtocolMessage is received</li>
		<li><code>(RTL4f)</code> Once an <code>ATTACH</code> <code>ProtocolMessage</code> is sent, if an <code>ATTACHED</code> <code>ProtocolMessage</code> is not received within the <a href="#defaults">default realtime request timeout</a>, the attach request should be treated as though it has failed</li>
		<li><code>(RTL4d)</code> If the language permits, a callback can be provided that is called when the channel is attached successfully or the attach fails and the the <code>ErrorInfo</code> error is passed as an argument to the callback.</li>
		<li><code>(RTL4e)</code> If the user does not have sufficient permissions to attach to the channel, the channel state <code>FAILED</code> is emitted with the error <code>ErrorInfo</code>. An error event is also emitted, and the <code>errorReason</code> attribute of the <code>Channel</code> is set to the error <code>ErrorInfo</code> object</li>
	</ul></li>
	<li><code>(RTL5)</code> <code>Channel#detach</code> function:
	<ul>
		<li><code>(RTL5a)</code> If state is <code>INITIALISED</code>, <code>DETACHED</code> or <code>DETACHING</code> nothing is done</li>
		<li><code>(RTL5b)</code> If state is <code>FAILED</code> an exception should be thrown immediately</li>
		<li><code>(RTL5d)</code> Otherwise a <code>DETACH</code> ProtocolMessage is sent to the server, the state changes to <code>DETACHING</code> and the channel becomes <code>DETACHED</code> when the confirmation <code>DETACHED</code> ProtocolMessage is received</li>
		<li><code>(RTL5f)</code> Once a <code>DETACH</code> <code>ProtocolMessage</code> is sent, if a <code>DETACHED</code> <code>ProtocolMessage</code> is not received within the <a href="#defaults">default realtime request timeout</a>, the detach request should be treated as though it has failed</li>
		<li><code>(RTL5e)</code> If the language permits, a callback can be provided that is called when the channel is detached successfully or the detach fails and the the <code>ErrorInfo</code> error is passed as an argument to the callback.</li>
	</ul></li>
	<li><code>(RTL6)</code> <code>Channel#publish</code> function:
	<ul>
		<li><code>(RTL6a)</code> Messages are encoded in the same way as the REST <code>Channel#publish</code> method</li>
		<li><code>(RTL6b)</code> An optional callback can be provided to the <code>#publish</code> method that is called when the message is successfully delivered or upon failure with the appropriate <code>ErrorInfo</code> error. A test should exist to publish lots of messages on a few connections to ensure all message success callbacks are called for all messages published</li>
		<li><code>(RTL6i)</code> Expects either an array of <code>Message</code> objects or a <code>name</code> string and <code>data</code> payload:</li>
		<li><code>(RTL6i1)</code> When <code>name</code> and <code>data</code> is provided, a single <code>ProtocolMessage</code> containing one <code>Message</code> is published to Ably</li>
		<li><code>(RTL6i2)</code> When an array of <code>Message</code> objects is provided, a single <code>ProtocolMessage</code> is used to publish all <code>Message</code> objects in the array. However, a yet to be implemented feature should limit the total number of messages bundled in a single ProtocolMessage based on the default max message size.</li>
		<li><code>(RTL6i3)</code> Allows <code>name</code> and or <code>data</code> to be <code>null</code>.  If any of the values are null, then key is not sent to Ably i.e. a payload with a <code>null</code> value for <code>data</code> would be sent as follows <code>{ "name": "click" }</code></li>
		<li><code>(RTL6c)</code> Connection state conditions:
		<ul>
			<li><code>(RTL6c1)</code> If the connection is <code>CONNECTED</code> then the messages are published immediately</li>
			<li><code>(RTL6c2)</code> If the connection is <code>CONNECTING</code> or <code>DISCONNECTED</code>, and <code>ClientOptions#queueMessages</code> has not been explicitly set to false, then the message will be queued and delivered as soon as the connection state returns to <code>CONNECTED</code></li>
			<li><code>(RTL6c3)</code> Else an exception is raised preventing the message publishing</li>
		</ul></li>
		<li><code>(RTL6d)</code> Messages are delivered using a single <code>ProtocolMessage</code> where possible by bundling in all messages for that channel into the <code>ProtocolMessage#messages</code> array. However, a yet to be implemented feature should limit the total number of messages bundled per <code>ProtocolMessage</code> based on the default max message size, and would reject the publish and indicate an error if any single message exceeds that limit</li>
		<li><code>(RTL6e)</code> Unauthenticated clients using basic auth without a <code>clientId</code> (i.e. any <code>clientId</code> is permitted):
		<ul>
			<li><code>(RTL6e1)</code>When a <code>Message</code> with a <code>clientId</code> value is published, Ably will accept and publish that message with the provided <code>clientId</code>. A test should assert that the <code>clientId</code> of the published <code>Message</code> is correct for both authentication schemes (token and basic)</li>
		</ul></li>
		<li><code>(RTL6g)</code> Authenticated clients with a <code>clientId</code> (as a result of either an explicitly configured <code>clientId</code> in <code>ClientOptions</code>, or implicitly through token auth):
		<ul>
			<li><code>(RTL6g1)</code> When publishing a <code>Message</code> with the <code>clientId</code> attribute set to <code>null</code>:
			<ul>
				<li><code>(RTL6g1a)</code> It is unnecessary for the client to set the <code>clientId</code> of the <code>Message</code> before publishing</li>
				<li><code>(RTL6g1b)</code> Ably is expected to automatically assign a <code>clientId</code> upon receiving the <code>Message</code>. A test should assert that the <code>clientId</code> value is populated for the <code>Message</code> when received</li>
			</ul></li>
			<li><code>(RTL6g2)</code> When publishing a <code>Message</code> with the <code>clientId</code> attribute value set to the authenticated client&#8217;s <code>clientId</code>, Ably will accept the message and publish it. A test should assert that the <code>clientId</code> value is populated for the <code>Message</code> when received</li>
			<li><code>(RTL6g3)</code> When publishing a <code>Message</code> with a different <code>clientId</code> attribute value to the authenticated <code>clientId</code>, the client library should reject publishing immediately. The message should not be sent to Ably and the errr callback should be called. The connection and channel must remain available for further publishing and other operations</li>
			<li><code>(RTL6g4)</code> When using token auth, unless a <code>clientId</code> has been provided in <code>ClientOptions</code> or inferred following authentication, the client library will not be constrained when publishing messages with any explicit <code>clientId</code>. If a <code>Message</code> with a <code>clientId</code> value is published before the <code>clientId</code> is configured or inferred following authentication, the client library should not reject any explicit <code>clientId</code> specified in a message. A test should instance a library without an explicit <code>clientId</code> and an <code>authCallback</code> that returns a <code>tokenDetails</code> object with a <code>clientId</code>, then publish a message with the same <code>clientId</code> before authentication, and ensure that the message is published following authentication and received back with the <code>clientId</code> intact. A further test should follow the same sequence of events, but should instead use an incompatible <code>clientId</code> in the message, expecting that the message is rejected by the Ably service and the message error should contain the server error message, and the connection and channel should remain available for further operations</li>
		</ul></li>
		<li><code>(RTL6h)</code> Where the library language permits, the <code>Channel#publish(name, data)</code> method should provide an optional argument that allows the <code>clientId</code> value to be specified such as <code>Channel#publish('event', 'data', { clientId: 'John' })</code></li>
		<li><code>(RTL6f)</code> <code>Message#connectionId</code> should match the current <code>Connection#id</code> for all published messages, a test should exist to ensure the <code>connectionId</code> for received messages matches that of the publisher</li>
	</ul></li>
	<li><code>(RTL7)</code> <code>Channel#subscribe</code> function:
	<ul>
		<li><code>(RTL7a)</code> Subscribe with no arguments subscribes a listener to all messages</li>
		<li><code>(RTL7b)</code> Subscribe with a single name argument subscribes a listener to only messages whose <code>name</code> member matches the string name</li>
		<li><code>(RTL7c)</code> Implicitly attaches the channel if not attached</li>
		<li><code>(RTL7d)</code> Messages delivered are automatically decoded based on the <code>encoding</code> attribute; see REST <code>Channel</code> encoding features. If there is an error decoding a message, the message is still delivered, but in addition to sending an error message to the logger, an <code>ErrorInfo</code> error object is emitted as an error on the <code>Channel</code>. Tests should exist to publish and subscribe to encoded messages using the <a href="https://github.com/ably/ably-common/blob/master/test-resources/crypto-data-128.json">AES 128</a> and <a href="https://github.com/ably/ably-common/blob/master/test-resources/crypto-data-256.json">AES 256</a> fixture test data</li>
		<li><code>(RTL7e)</code> If a message cannot be decoded or decrypted successfully, it should be delivered to the listener with the <code>encoding</code> attribute set indicating the residual encoding state, and an error should be emitted on the channel</li>
		<li><code>(RTL7f)</code> A test should exist ensuring published messages are not echoed back to the subscriber when <code>echoMessages</code> is set to false in the <code>Realtime</code> library constructor</li>
	</ul></li>
	<li><code>(RTL8)</code> <code>Channel#unsubscribe</code> function:
	<ul>
		<li><code>(RTL8a)</code> Unsubscribe with no arguments unsubscribes the provided listener to all messages if subscribed</li>
		<li><code>(RTL8b)</code> Unsubscribe with a single name argument unsubscribes the provided listener if previously subscribed with a name-specific subscription</li>
	</ul></li>
	<li><code>(RTL9)</code> <code>Channel#presence</code> attribute:
	<ul>
		<li><code>(RTL9a)</code> Returns the <code>Presence</code> object for this channel</li>
	</ul></li>
	<li><code>(RTL10)</code> <code>Channel#history</code> function:
	<ul>
		<li><code>(RTL10a)</code> Supports all the same params as REST <code>Channel#history</code></li>
		<li><code>(RTL10b)</code> Additionally supports the param <code>untilAttach</code>, which if true, will only retrive messages prior to the moment that the channel was attached. This bound is specified by passing the querystring param <code>from_serial</code> with the serial number assigned to the channel in the <code>ATTACHED</code> <code>ProtocolMessage</code>. If the <code>untilAttach</code> param is specified when the channel is not attached an exception should be raised.</li>
		<li><code>(RTL10c)</code> Returns a <code>PaginatedResult</code> page containing the first page of messages in the <code>PaginatedResult#items</code> attribute returned from the history request.</li>
		<li><code>(RTL10d)</code> A test should exist that publishes messages from one client, and upon confirmation of message delivery, a history request should be made on another client to ensure all messages are available</li>
	</ul></li>
</ul>
<h3 id="realtime-presence">Presence</h3>
<ul>
	<li><code>(RTP1)</code> When a channel <code>ATTACHED</code> <code>ProtocolMessage</code> is received, the <code>ProtocolMessage</code> may contain a bit flag with value 1 indicating that there are currently members present on the channel. If members are present, subsequent <code>ProtocolMessage SYNC</code> messages will be delivered with presence members (messages) until the <code>SYNC</code> operation is complete. If there is no flag or the right most bit is zero, then the presence map should be considered in sync immediately as there are no members present on the channel at the time of attach</li>
	<li><code>(RTP2)</code> A <a href="https://github.com/ably/ably-java/blob/master/src/io/ably/realtime/Presence.java#L384-L529">PresenceMap</a> should be used to maintain a list of members present on a channel. As there are no guarantees that during the <code>SYNC</code> phase presence events will arrive in order i.e. a leave event for a member can arrive before that member is later registered as as present as part of the initial <code>SYNC</code> operation. As such, until the <code>SYNC</code> operation is complete, timestamps must be recorded for all members to ensure the most recent present state is used, see the <a href="https://github.com/ably/ably-java/blob/master/src/io/ably/realtime/Presence.java#L418-L431">Java implementation</a>.  Once a <code>SYNC</code> event is complete, the members that are now considered <code>ABSENT</code> can be removed from the map, see the <a href="https://github.com/ably/ably-java/blob/master/src/io/ably/realtime/Presence.java#L504-L509">Java implementation</a></li>
	<li><code>(RTP3)</code> If a <code>SYNC</code> operation is underway but not yet complete, and the transport is disconnected unexpectedly, then if the connection is resumed successfully, it is the responsibility of the client library to complete the <code>SYNC</code> operation. The client library requests a <code>SYNC</code> resume by sending a <code>SYNC</code> <code>ProtocolMessage</code> with the last received sync serial number. See the <a href="https://github.com/ably/ably-ruby/blob/7b18a20/lib/ably/realtime/presence/members_map.rb#L169-L176">Ruby implementation</a> and the <a href="https://github.com/ably/ably-ruby/blob/7b18a20/spec/acceptance/realtime/presence_spec.rb#L1338-L1357">Ruby test</a></li>
	<li><code>(RTP4)</code> Ensure a test exists that enters 250 members using <code>Presence#enterClient</code> on a single connection, and checks for <code>PRESENT</code> events to be emitted on another connection for each member, and once sync is complete, all 250 members should be present in a <code>Presence#get</code> request</li>
	<li><code>(RTP5)</code> Channel state change side effects:
	<ul>
		<li><code>(RTP5a)</code> If the channel enters the <code>DETACHED</code> or <code>FAILED</code> state then all queued presence messages will fail immediately</li>
		<li><code>(RTP5b)</code> If a channel enters the <code>ATTACHED</code> state then all queued presence messages will be sent immediately and a presence <code>SYNC</code> will be initiated implicitly</li>
	</ul></li>
	<li><code>(RTP16)</code> Connection state conditions:
	<ul>
		<li><code>(RTP16a)</code> If the connection is <code>CONNECTED</code> then all presence messages are published immediately</li>
		<li><code>(RTP16b)</code> If the connection is <code>CONNECTING</code> or <code>DISCONNECTED</code>, and <code>ClientOptions#queueMessages</code> has not been explicitly set to false, then all presence messages will be queued and delivered as soon as the connection state returns to <code>CONNECTED</code></li>
		<li><code>(RTP16c)</code> Else an exception is raised preventing any presence messages being published</li>
	</ul></li>
	<li><code>(RTP6)</code> <code>Presence#subscribe</code> function:
	<ul>
		<li><code>(RTP6a)</code> Subscribe with no arguments subscribes a listener to all presence messages</li>
		<li><code>(RTP6b)</code> Subscribe with a single action argument &#8211; such as <code>ENTER</code>, <code>LEAVE</code>, <code>UPDATE</code> or <code>PRESENT</code> &#8211; subscribes a listener to receive only presence messages with that action</li>
		<li><code>(RTP6c)</code> Implicitly attaches the channel if not attached</li>
	</ul></li>
	<li><code>(RTP7)</code> <code>Presence#unsubscribe</code> function:
	<ul>
		<li><code>(RTP7a)</code> Unsubscribe with no arguments unsubscribes the listener if previously subscribed with an action-specific subscription</li>
		<li><code>(RTP7b)</code> Unsubscribe with a single action argument unsubscribes the provided listener to all presence messages for that action</li>
	</ul></li>
	<li><code>(RTP8)</code> <code>Presence#enter</code> function:
	<ul>
		<li><code>(RTP8a)</code> Enters the current client into this channel, optionally with the data provided</li>
		<li><code>(RTP8b)</code> Optionally a callback can be provided that is called for both success or failure to enter</li>
		<li><code>(RTP8c)</code> A <code>PRESENCE ProtocolMessage</code> with a <code>PresenceMessage</code> with the action <code>ENTER</code> is sent to the Ably service. The <code>clientId</code> attribute of the <code>PresenceMessage</code> must not be present. Entering without an explicit <code>PresenceMessage#clientId</code>, implicitly uses the <code>clientId</code> for the current connection</li>
		<li><code>(RTP8d)</code> Implicitly attaches to the channel if not attached</li>
		<li><code>(RTP8e)</code> Optional data can be included when entering a channel that will be encoded / decoded as with normal messages. A test should exist to ensure data used with enter is encoded &amp; decoded correctly. Also, when data is provided when entering, but no data is provided when leaving, the data attribute should be emitted in the <code>LEAVE</code> event for this client</li>
		<li><code>(RTP8f)</code> Raises an exception if the client library is not authenticated (i.e. no <code>clientId</code> is configured)</li>
		<li><code>(RTP8g)</code> Raises an exception if the channel is <code>DETACHED</code> or <code>FAILED</code></li>
		<li><code>(RTP8h)</code> Fails and emits an error if the client does not have required presence permission</li>
		<li><code>(RTP8i)</code> Fails and emits an error if the current client is not authenticated, and no implicit <code>clientId</code> is assigned by the Ably service</li>
	</ul></li>
	<li><code>(RTP9)</code> <code>Presence#update</code> function:
	<ul>
		<li><code>(RTP9a)</code> Updates the data for the present member with a value or <code>null</code></li>
		<li><code>(RTP9b)</code> If the client was not already entered, it enters this client into this channel</li>
		<li><code>(RTP9c)</code> Optionally a callback can be provided that is called for both success or failure to update</li>
		<li><code>(RTP9d)</code> A <code>PRESENCE ProtocolMessage</code> with a <code>PresenceMessage</code> with the action <code>UPDATE</code> is sent to the Ably service. The <code>clientId</code> attribute of the <code>PresenceMessage</code> must not be present. Updating without an explicit <code>PresenceMessage#clientId</code>, implicitly uses the <code>clientId</code> for the current connection</li>
		<li><code>(RTP9e)</code> In all other ways, this method is identical to <code>Presence#enter</code> and should have matching tests</li>
	</ul></li>
	<li><code>(RTP10)</code> <code>Presence#leave</code> function:
	<ul>
		<li><code>(RTP10a)</code> Leaves this client from the channel and the data will be updated with the value provided. If the language permits the data argument to be omitted, then the previously set data value will be omitted as a convenience</li>
		<li><code>(RTP10b)</code> Optionally a callback can be provided that is called for both success or failure to leave</li>
		<li><code>(RTP10c)</code> A <code>PRESENCE ProtocolMessage</code> with a <code>PresenceMessage</code> with the action <code>LEAVE</code> is sent to the Ably service. The <code>clientId</code> attribute of the <code>PresenceMessage</code> must not be present. Leaving without an explicit <code>PresenceMessage#clientId</code>, implicitly uses the <code>clientId</code> for the current connection</li>
		<li><code>(RTP10d)</code> If the client is not currently <code>ENTERED</code> then an exception is raised</li>
		<li><code>(RTP10e)</code> In all other ways, this method is identical to <code>Presence#enter</code> and should have matching tests</li>
	</ul></li>
	<li><code>(RTP11)</code> <code>Presence#get</code> function:
	<ul>
		<li><code>(RTP11a)</code> Returns the list of current members on the channel in a callback and, by default, will not wait for the <code>SYNC</code> to be completed</li>
		<li><code>(RTP11b)</code> Raises an exception if the channel is <code>DETACHED</code> or <code>FAILED</code></li>
		<li><code>(RTP11c)</code> An optional set of params can be provided:
		<ul>
			<li><code>(RTP11c1)</code> <code>waitForSync</code> when true, will wait until <code>SYNC</code> is complete before returning a list of members</li>
			<li><code>(RTP11c2)</code> <code>clientId</code> filters members by the provided <code>clientId</code></li>
			<li><code>(RTP11c3)</code> <code>connectionId</code> filters members by the provided <code>connectionId</code></li>
		</ul></li>
	</ul></li>
	<li><code>(RTP12)</code> <code>Presence#history</code> function:
	<ul>
		<li><code>(RTP12a)</code> Supports all the same params as REST <code>Presence#history</code></li>
		<li><code>(RTP12b)</code> Additionally supports the param <code>untilAttach</code>, which if true, will only retrive messages up to the moment that the channel was attached. This bound is specified by passing the querystring param <code>from_serial</code> with the serial number assigned to the channel in the <code>ATTACHED</code> <code>ProtocolMessage</code>. If the <code>untilAttach</code> param is specified when the channel is not attached an exception should be raised.</li>
		<li><code>(RTP12c)</code> Returns a <code>PaginatedResult</code> page containing the first page of messages in the <code>PaginatedResult#items</code> attribute returned from the history request.</li>
		<li><code>(RTP12d)</code> A test should exist that registers presence with a few clients, and upon confirmation of entering the channel for all clients, a presence history request should be made using another client to ensure all presence events are available</li>
	</ul></li>
	<li><code>(RTP13)</code> <code>Presence#syncComplete</code> returns true if the initial <code>SYNC</code> operation has completed for the members present on the channel</li>
	<li><code>(RTP14)</code> <code>Presence#enterClient</code> function:
	<ul>
		<li><code>(RTP14a)</code> Enters into presence on a channel on behalf of another <code>clientId</code>. This allows a single client with suitable permissions to register presence on behalf of any number of clients using a single connection</li>
		<li><code>(RTP14b)</code> Optionally a callback can be provided that is called for both success or failure to enter</li>
		<li><code>(RTP14c)</code> Data can optionally be provided when entering and will follow the normal encoding &amp; decoding rules</li>
		<li><code>(RTP14d)</code> A test should exist that registers a number of members each with a different <code>clientId</code> on a presence channel, and then a <code>Presence#get</code> should be used to verify that all members are present as expected</li>
	</ul></li>
	<li><code>(RTP15)</code> <code>Presence#enterClient</code> <code>Presence#updateClient</code> and <code>Presence#leaveClient</code> function:
	<ul>
		<li><code>(RTP15a)</code> Performs an enter, update or leave for given <code>clientId</code>. These methods apply if the Realtime library was not initialised with a specific <code>clientId</code>. This allows a single client with suitable permissions to update presence on behalf of any number of clients using a single connection. Otherwise these are functionality equivalent to the corresponding <code>enter</code>, <code>update</code> and <code>leave</code> methods, and equivalent test coverage should be provided</li>
		<li><code>(RTP15b)</code> Tests should use <code>enterClient</code>, <code>updateClient</code> and <code>leaveClient</code> for many members from one <code>Realtime</code> client and check that the operations are reflected in the presence map and the expected events are emitted on a separate client.</li>
		<li><code>(RTP15c)</code> Tests should also ensure that using these methods has no side effects on a client that has entered normally using <code>Presence#enter</code></li>
		<li><code>(RTP15d)</code> A callback can be provided that will be called upon success or failure</li>
		<li><code>(RTP15e)</code> A channel will be implicitly attached when these methods are called</li>
		<li><code>(RTP15f)</code> If the client is authenticated and has a configured <code>clientId</code>, if the <code>clientId</code> argument does not match the client&#8217;s <code>clientId</code>, then it should indicate an error. The connection and channel remains available for further operations</li>
	</ul></li>
</ul>
<h3 id="eventemitter">EventEmitter mixin / interface</h3>
<ul>
	<li><code>(RTE1)</code> <code>EventEmitter</code> is a generic interface for event registration and delivery used in a number of the types in the Realtime client library.  For example, the <code>Connection</code> object emits events for connection state using the <code>EventEmitter</code> pattern</li>
	<li><code>(RTE2)</code> Where objects provide <code>subscribe</code> or <code>unsubscribe</code> methods, they should follow the specification for the <code>EventEmitter#on</code> and <code>EventEmitter#off</code> methods respectively.</li>
	<li><code>(RTE3)</code> <code>EventEmitter#on</code> registers a listener for the specified event if provided, else it is registered for all events</li>
	<li><code>(RTE4)</code> <code>EventEmitter#once</code> registers a listener that is called only once when the first of the applicable events occurs (ie the specified event if given, or the first event if it is registered for all events)</li>
	<li><code>(RTE5)</code> <code>EventEmitter#off</code> deregisters a listener for the specified event if given, else it is deregisters that listener for all registrations (global and event-specific)</li>
	<li><code>(RTE6)</code> <code>EventEmitter#emit</code> emits an event, calling registered listeners with the given event name any other given arguments. If an exception is raised in any of the listeners, the exception is caught by the <code>EventEmitter</code> and the exception is logged to the Ably logger. Tests must exist to ensure exceptions raised in client code do not propagate and inhibit other event processing within the client library</li>
</ul>
<h2>Types</h2>
<h3 id="types">Data types</h3>
<h4>Message</h4>
<ul>
	<li><code>(TM1)</code> A <code>Message</code> represents an individual message to be sent or received via the Ably Realtime service.  See the <a href="http://www.rubydoc.info/gems/ably/Ably/Models/Message">Ruby Message documentation</a>, but bear in mind the attributes following underscore naming in Ruby.</li>
	<li><code>(TM2)</code> Attributes available in a <code>Message</code>, see the <a href="http://www.rubydoc.info/gems/ably/Ably/Models/Message">Ruby Message documentation</a> for an explanation of each attribute:
	<ul>
		<li><code>(TM2a)</code> <code>id</code> string &#8211; unique ID for this message</li>
		<li><code>(TM2b)</code> <code>clientId</code> string</li>
		<li><code>(TM2c)</code> <code>connectionId</code> string</li>
		<li><code>(TM2g)</code> <code>name</code> string</li>
		<li><code>(TM2d)</code> <code>data</code> string, buffer or JSON-encodable object or array</li>
		<li><code>(TM2e)</code> <code>encoding</code> string</li>
		<li><code>(TM2f)</code> <code>timestamp</code> time in milliseconds since epoch</li>
	</ul></li>
</ul>
<h4>PresenceMessage</h4>
<ul>
	<li><code>(TP1)</code> A <code>PresenceMessage</code> represents an individual presence message to be sent or received via the Ably Realtime service.  See the <a href="http://www.rubydoc.info/gems/ably/Ably/Models/PresenceMessage">Ruby PresenceMessage documentation</a>, but bear in mind the attributes following underscore naming in Ruby.</li>
	<li><code>(TP2)</code> <code>PresenceMessage</code> <code>Action</code> enum has the following values in order from zero: <code>ABSENT</code>, <code>PRESENT</code>, <code>ENTER</code>, <code>LEAVE</code>, <code>UPDATE</code></li>
	<li><code>(TP3)</code> Attributes available in a <code>PresenceMessage</code>, see the <a href="http://www.rubydoc.info/gems/ably/Ably/Models/PresenceMessage">Ruby PresenceMessage documentation</a> for an explanation of each attribute:
	<ul>
		<li><code>(TP3a)</code> <code>id</code> string &#8211; unique ID for this message</li>
		<li><code>(TP3b)</code> <code>action</code> enum</li>
		<li><code>(TP3c)</code> <code>clientId</code> string</li>
		<li><code>(TP3d)</code> <code>connectionId</code> string</li>
		<li><code>(TP3e)</code> <code>data</code> string, buffer or JSON-encodable object or array</li>
		<li><code>(TP3f)</code> <code>encoding</code> string</li>
		<li><code>(TP3g)</code> <code>timestamp</code> time in milliseconds since epoch</li>
		<li><code>(TP3h)</code> <code>memberKey</code> string function that combines the <code>connectionId</code> and <code>clientId</code> ensuring multiple connected clients with the same clientId are uniquely identifiable</li>
	</ul></li>
</ul>
<h4>ProtocolMessage</h4>
<ul>
	<li><code>(TR1)</code> A <code>ProtocolMessage</code> represents the type used to send and receive messages over the Realtime protocol.  A ProtocolMessage always relates either to the connection or to a single channel only, but can contain multiple individual Messages or PresenceMessages.  See the <a href="http://www.rubydoc.info/gems/ably/Ably/Models/ProtocolMessage">Ruby ProtocolMessage documentation</a>, but bear in mind the attributes following underscore naming in Ruby.</li>
	<li><code>(TR2)</code> <code>ProtocolMessage</code> <code>Action</code> enum has the following values in order from zero: <code>HEARTBEAT</code>, <code>ACK</code>, <code>NACK</code>, <code>CONNECT</code>, <code>CONNECTED</code>, <code>DISCONNECT</code>, <code>DISCONNECTED</code>, <code>CLOSE</code>, <code>CLOSED</code>, <code>ERROR</code>, <code>ATTACH</code>, <code>ATTACHED</code>, <code>DETACH</code>, <code>DETACHED</code>, <code>PRESENCE</code>, <code>MESSAGE</code>, <code>SYNC</code></li>
	<li><code>(TR3)</code> <code>ProtocolMessage</code> <code>Flag</code> enum has the following values in order from zero: <code>HAS_PRESENCE</code>, <code>HAS_BACKLOG</code></li>
	<li><code>(TR4)</code> Attributes available in a <code>ProtocolMessage</code>, see the <a href="http://www.rubydoc.info/gems/ably/Ably/Models/ProtocolMessage">Ruby ProtocolMessage documentation</a> for an explanation of each attribute:
	<ul>
		<li><code>(TR4a)</code> <code>action</code> enum</li>
		<li><code>(TR4n)</code> <code>id</code> string</li>
		<li><code>(TR4b)</code> <code>channel</code> string</li>
		<li><code>(TR4c)</code> <code>channelSerial</code> string</li>
		<li><code>(TR4d)</code> <code>connectionId</code> string</li>
		<li><code>(TR4e)</code> <code>connectionKey</code> string</li>
		<li><code>(TR4f)</code> <code>connectionSerial</code> long</li>
		<li><code>(TR4o)</code> <code>connectionDetails</code> <code>ConnectionDetails</code> object &#8211; provides details on the constraints or defaults for the connection such as max message size, client ID or connection state TTL</li>
		<li><code>(TR4g)</code> <code>count</code> integer</li>
		<li><code>(TR4h)</code> <code>error</code> <code>ErrorInfo</code> object</li>
		<li><code>(TR4i)</code> <code>flags</code> integer</li>
		<li><code>(TR4j)</code> <code>messageSerial</code> long</li>
		<li><code>(TR4k)</code> <code>messages</code> Array of <code>Message</code> objects</li>
		<li><code>(TR4l)</code> <code>presence</code> Array of <code>PresenceMessage</code> objects</li>
		<li><code>(TR4m)</code> <code>timestamp</code> time in milliseconds since epoch</li>
	</ul></li>
</ul>
<h4>PaginatedResult</h4>
<ul>
	<li><code>(TG1)</code> A <code>PaginatedResult</code> is a type that represents a page of results from a <a href="/rest-api/#pagination">paginated query</a>. The response is accompanied by metadata that indicates the relative queries available.</li>
	<li><code>(TG2)</code> <code>PaginatedResult</code> wraps all message and presence history, stats and REST presence requests.  The type must not raise an exception if paging headers are not returned from the REST API.</li>
	<li><code>(TG3)</code> <code>PaginatedResult#items</code> attribute contains a page of results (for example an Array of <code>Message</code> objects for a channel history request).</li>
	<li><code>(TG4)</code> <code>PaginatedResult#next</code> function returns a new <code>PaginatedResult</code> loaded with the next page of results. If there are no further pages, then <code>null</code> is returned.</li>
	<li><code>(TG5)</code> <code>PaginatedResult#first</code> function returns a new <code>PaginatedResult</code> for the first page of results.</li>
	<li><code>(TG6)</code> <code>PaginatedResult#hasNext</code> function returns <code>true</code> if there are further pages</li>
	<li><code>(TG7)</code> <code>PaginatedResult#isLast</code> function returns <code>true</code> if this page is not the last page i.e. <code>!hasNext</code></li>
</ul>
<h4>TokenRequest</h4>
<ul>
	<li><code>(TE1)</code> <code>TokenRequest</code> is a type containing the token request details sent to the <a href="/rest-api/#requesttoken">REST requestToken endpoint</a></li>
	<li><code>(TE2)</code> String attributes <code>keyName</code>, <code>clientId</code>, <code>nonce</code> and <code>mac</code></li>
	<li><code>(TE3)</code> <code>capability</code> is a string attribute containing capabilities JSON stringified</li>
	<li><code>(TE4)</code> <code>ttl</code> attribute represents time to live (expiry) of this token in milliseconds</li>
</ul>
<h4>TokenDetails</h4>
<ul>
	<li><code>(TD1)</code> <code>TokenDetails</code> is a type containing the token request response from the <a href="/rest-api/#requesttoken">REST requestToken endpoint</a></li>
	<li><code>(TD2)</code> <code>TokenDetails#token</code> attribute contains the token string</li>
	<li><code>(TD3)</code> <code>TokenDetails#expires</code> attribute contains the expiry time in milliseconds.  Where idiomatic in the language, this can be a Date/Time object</li>
	<li><code>(TD4)</code> <code>TokenDetails#issued</code> attribute contains the time the token was issued in milliseconds.  Where idiomatic in the language, this can be a Date/Time object</li>
	<li><code>(TD5)</code> <code>TokenDetails#capability</code> attribute contains the capability JSON stringified</li>
	<li><code>(TD6)</code> <code>TokenDetails#clientId</code> attribute contains the <code>clientId</code> assigned to the token. If <code>clientId</code> is <code>null</code> or omitted, then the token is prohibited from assuming a <code>clientId</code> in any operations, however if <code>clientId</code> is a wildcard string <code>'*'</code>, then the token is permitted to assume any <code>clientId</code>. Any other string value for <code>clientId</code> implies that the <code>clientId</code> is both enforced and assumed for all operations for this token</li>
</ul>
<h4>Stats</h4>
<ul>
	<li><code>(TS1)</code> <code>Stats</code> is a type encapsulating a statistics datapoint retrieved from the <a href="/rest-api/#stats">REST stats endpoint</a>.  See <a href="/general/statistics/">example statistics in JSON format</a>.</li>
	<li><code>(TS2)</code> All stats values default to zero when no underlying JSON value exists.  We send sparse JSON to stats requests omitting fields where the value is zero to reduce bandwidth and optimise JSON parsing.</li>
	<li><code>(TS3)</code> See the <a href="http://www.rubydoc.info/gems/ably/Ably/Models/Stats">Ruby Stats type documentation</a></li>
	<li><code>(TS4)</code> <code>Stats.ConnectionTypes</code> &#8211; see the <a href="http://www.rubydoc.info/gems/ably/Ably/Models/Stats/ConnectionTypes">Ruby ConnectionTypes documentation</a></li>
	<li><code>(TS5)</code> <code>Stats.MessageCount</code> &#8211; see the <a href="http://www.rubydoc.info/gems/ably/Ably/Models/Stats/MessageCount">Ruby MessageCount documentation</a></li>
	<li><code>(TS6)</code> <code>Stats.MessageTypes</code> &#8211; see the <a href="http://www.rubydoc.info/gems/ably/Ably/Models/Stats/MessageTypes">Ruby MessageTypes documentation</a></li>
	<li><code>(TS7)</code> <code>Stats.MessageTraffic</code> &#8211; see the <a href="http://www.rubydoc.info/gems/ably/Ably/Models/Stats/MessageTraffic">Ruby MessageTraffic documentation</a></li>
	<li><code>(TS8)</code> <code>Stats.RequestCount</code> &#8211; see the <a href="http://www.rubydoc.info/gems/ably/Ably/Models/Stats/RequestCount">Ruby RequestCount documentation</a></li>
	<li><code>(TS9)</code> <code>Stats.ResourceCount</code> &#8211; see the <a href="http://www.rubydoc.info/gems/ably/Ably/Models/Stats/ResourceCount">Ruby ResourceCount documentation</a></li>
</ul>
<h4>ErrorInfo</h4>
<ul>
	<li><code>(TI1)</code> Provides a generic Ably <code>ErrorInfo</code> object that contains Ably <code>code</code>, <code>statusCode</code> (analogous to HTTP status code) and <code>message</code> attributes.</li>
	<li><code>(TI2)</code> Errors returned from the Ably server are compatible with the <code>ErrorInfo</code> structure and should raise exceptions that inherit from <code>ErrorInfo</code></li>
	<li><code>(TE3)</code> <a href="https://github.com/ably/ably-common">Ably-common</a> should be included as a submodule so that <a href="https://github.com/ably/ably-common/blob/master/protocol/errors.json">consistent error codes</a> can be used</li>
</ul>
<h4>ConnectionStateChange</h4>
<ul>
	<li><code>(TA1)</code> Whenever the connection state changes, a <code>ConnectionStateChange</code> object is emitted on the <code>Connection</code> object</li>
	<li><code>(TA2)</code> The <code>ConnectionStateChange</code> object contains the current state in attribute <code>current</code>, the previous state in attribute <code>previous</code>, and when the client is not connected and a connection attempt will be made automatically by the library, the amount of time in milliseconds until the next retry in the attribute <code>retryIn</code></li>
	<li><code>(TA3)</code> If the connection state change includes error information, then the <code>errorReason</code> attribute will contain an <code>ErrorInfo</code> object describing the reason for the error</li>
	<li><code>(TA4)</code> See the [Java library implementation](https://github.com/ably/ably-java/blob/245a3f20a6dce0d34413ddfed19c5da8ea647422/src/io/ably/realtime/ConnectionStateListener.java#L15-L20) of this object.  Note that <code>reason</code> will be changed in a future release to <code>errorReason</code> in line with this specification</li>
</ul>
<h4>Capability &#8211; <strong>API not defined yet</strong></h4>
<ul>
	<li><code>(TC1)</code> This type represents a capability for a key or token</li>
	<li><code>(TC2)</code> For now a string representation of the JSON will suffice wherever <code>capability</code> is used</li>
</ul>
<h4>ConnectionDetails</h4>
<ul>
	<li><code>(CD1)</code> Connection details are optionally passed to the client library in the <code>CONNECTED</code> <code>ProtocolMessage#connectionDetails</code> attribute to inform the client about any constraints it should adhere to, and provide additional metadata about the connection. For example, if a request is made to publish a message that exceeds the <code>maxMessageSize</code>, the client library can reject the message immediately, without communicating with the Ably service</li>
	<li><code>(CD2)</code> Attributes available in <code>ConnectionDetails</code>:
	<ul>
		<li><code>(CD2a)</code> <code>clientId</code> contains the client ID assigned to the token. If <code>clientId</code> is <code>null</code> or omitted, then the client is prohibited from assuming a <code>clientId</code> in any operations, however if <code>clientId</code> is a wildcard string <code>'*'</code>, then the client is permitted to assume any <code>clientId</code>. Any other string value for <code>clientId</code> implies that the <code>clientId</code> is both enforced and assumed for all operations from this client</li>
		<li><code>(CD2b)</code> <code>connectionKey</code> is the connection secret key string that is used to resume a connection and its state</li>
		<li><code>(CD2c)</code> <code>maxMessageSize</code> is the maximum individual message size in bytes</li>
		<li><code>(CD2d)</code> <code>maxFrameSize</code> is the maximum size for a single frame of data sent to Ably. This restriction applies to a <code>ProtocolMessage</code> sent over a realtime connection, or the total body size for a REST request</li>
		<li><code>(CD2e)</code> <code>maxInboundRate</code> is the maximum allowable number of requests per second from a client or Ably. In the case of a realtime connection, this restriction applies to the number of <code>ProtocolMessage</code> objects sent, whereas in the case of REST, it is the total number of REST requests per second</li>
		<li><code>(CD2f)</code> <code>connectionStateTtl</code> is the duration that Ably will persist the connection state when a Realtime client is abruptly disconnected</li>
	</ul></li>
</ul>
<h3 id="options">Option types</h3>
<h4>ClientOptions</h4>
<ul>
	<li><code>(TO1)</code> Ably library options used when instancing a REST or Realtime client library, see <a href="https://github.com/ably/ably-java/blob/master/src/io/ably/types/ClientOptions.java">Java ClientOptions</a> which extends <a href="https://github.com/ably/ably-java/blob/0e9d961a02f4b87a59a45fe59e23a5553590102d/src/io/ably/rest/Auth.java#L44-L129">Java AuthOptions</a> as a reference</li>
	<li><code>(TO2)</code> Note: <code>ClientOptions</code> does not currently define a default for max message size or request size. This will be added in the future to ensure that REST requests does not exceed the limits before the request is made to the server. In the case of realtime, the connection constraints will be sent to the client in the initial <code>CONNECTED</code> <code>ProtocolMessage</code></li>
	<li><code>(TO3)</code> The attributes of <code>ClientOptions</code> consist of:
	<ul>
		<li><code>(TO3a)</code> <code>clientId</code> string &#8211; the id of the client represented by this instance</li>
		<li><code>(TO3b)</code> <code>logLevel</code> &#8211; controls the level of verbosity of log messages from the library</li>
		<li><code>(TO3c)</code> <code>logHandler</code> &#8211; allows the client to intercept log messages and handle them in a client-specific way</li>
		<li><code>(TO3d)</code> <code>tls</code> boolean &#8211; defaults to true. If false, will not use TLS for all connections</li>
		<li><code>(TO3e)</code> <code>autoConnect</code> boolean &#8211; defaults to true. If false, suppresses the automatic initiation of a connection when the library is instanced</li>
		<li><code>(TO3f)</code> <code>useBinaryProtocol</code> boolean &#8211; defaults to true. If false, forces the library to use the JSON encoding for REST and Realtime operations, instead of the default binary msgpack encoding</li>
		<li><code>(TO3g)</code> <code>queueMessages</code> boolean &#8211; defaults to true. If false, suppresses the default queueing of messages when connection states that anticipate imminent connection (connecting and disconnected). Instead, publish and presence state changes will fail immediately if not in the connected state</li>
		<li><code>(TO3h)</code> <code>echoMessages</code> boolean &#8211; defaults to true. If false, suppresses messages originating from this connection being echoed back on the same connection</li>
		<li><code>(TO3i)</code> <code>recover</code> string &#8211; A connection recovery string, specified with the intention of inheriting the state of an earlier connection</li>
		<li><code>(TO3j)</code> Auth option attributes:
		<ul>
			<li><code>(TO3j1)</code> <code>key</code> string &#8211; Full Ably key string as obtained from dashboard</li>
			<li><code>(TO3j2)</code> <code>token</code> string &#8211; An authentication token string issued for this application</li>
			<li><code>(TO3j3)</code> <code>tokenDetails</code> <code>TokenDetails</code> &#8211; An authentication token issued for this application</li>
			<li><code>(TO3j4)</code> <code>useTokenAuth</code> boolean &#8211; When true, token authentication will always be used by the client</li>
			<li><code>(TO3j5)</code> <code>authCallback</code> &#8211; A callback to call to obtain a signed <code>TokenRequest</code>, <code>TokenDetails</code> or a token string. This enables a client to obtain token requests or tokens from another entity, so tokens can be renewed without the client requiring a key</li>
			<li><code>(TO3j6)</code> <code>authUrl</code> string &#8211; A URL to query to obtain a signed <code>TokenRequest</code>, <code>TokenDetails</code> or a token string. This enables a client to obtain token request or token from another entity, so tokens can be renewed without the client requiring a key</li>
			<li><code>(TO3j7)</code> <code>authMethod</code> &#8211; The HTTP verb to be used when a request is made by the library to the <code>authUrl</code>. Defaults to <code>GET</code>, supports <code>GET</code> and <code>POST</code></li>
			<li><code>(TO3j8)</code> <code>authHeaders</code> &#8211; Headers to be included in any request made by the library to the <code>authUrl</code></li>
			<li><code>(TO3j9)</code> <code>authParams</code> &#8211; Additional params to be included in any request made by the library to the <code>authUrl</code>, either as query params added to the URL in the case of <code>GET</code>, or form-encoded in the body in the case of <code>POST</code></li>
			<li><code>(TO3j10)</code> <code>queryTime</code> &#8211; If true, the library will query the Ably system for the current time instead of relying on a locally-available time of day</li>
		</ul></li>
		<li><code>(TO3k)</code> Development environment attributes:
		<ul>
			<li><code>(TO3k1)</code> <code>environment</code> string &#8211; for development environments only; allows a non-default Ably environment to be used such as <code>sandbox</code></li>
			<li><code>(TO3k2)</code> <code>restHost</code> string &#8211; for development environments only; allows a non-default Ably REST host to be specified</li>
			<li><code>(TO3k3)</code> <code>realtimeHost</code> string &#8211; for development environments only; allows a non-default Ably Realtime host to be specified</li>
			<li><code>(TO3k4)</code> <code>port</code> integer &#8211; for development environments only; allows a non-default Ably non-TLS port to be specified</li>
			<li><code>(TO3k5)</code> <code>tlsPort</code> integer &#8211; for development environments only; allows a non-default Ably TLS port to be specified</li>
		</ul></li>
		<li><code>(TO3l)</code> The follow attributes, if set, are used to change the default behaviour of the libary:
		<ul>
			<li><code>(TO3l1)</code> <code>disconnectedRetryTimeout</code> integer &#8211; default 15,000 (15s). When the connection is in the <code>DISCONNECTED</code> state, this delay in milliseconds controls how frequently the client library attempts to reconnect automatically</li>
			<li><code>(TO3l2)</code> <code>suspendedRetryTimeout</code> integer &#8211; default 30,000 (30s). When the connection is in the <code>SUSPENDED</code> state, this delay in milliseconds controls how frequently the client library attempts to reconnect automatically</li>
			<li><code>(TO3l3)</code> <code>httpOpenTimeout</code> integer &#8211; default 4,000 (4s). Timeout for opening the connection, available in the client library if supported by the transport</li>
			<li><code>(TO3l4)</code> <code>httpRequestTimeout</code> integer &#8211; default 15,000 (15s). Timeout for any single HTTP request and response</li>
			<li><code>(TO3l5)</code> <code>httpMaxRetryCount</code> integer &#8211; default 3. Max number of fallback host retries for HTTP requests that fail due to network issues or server problems</li>
			<li><code>(TO3l6)</code> <code>httpMaxRetryDuration</code> integer &#8211; default 10,000 (10s). Max elapsed time in which fallback host retries for HTTP requests will be attempted i.e. if the first default host attempt takes 5s, and then the subsequent fallback retry attempt takes 7s, no further fallback host attempts will be made as the total elapsed time of 12s exceeds the default 10s limit</li>
		</ul></li>
	</ul></li>
</ul>
<h4>TokenParams</h4>
<ul>
	<li><code>(TK1)</code> A class providing parameters of a token request. These params are used when invoking <code>Auth#authorise</code>, <code>Auth#requestToken</code> and <code>Auth#createTokenRequest</code></li>
	<li><code>(TK2)</code> The attributes of <code>TokenParams</code> consist of:</li>
	<li><code>(TK2a)</code> <code>ttl</code> long &#8211; Requested time to live for the token in milliseconds</li>
	<li><code>(TK2b)</code> <code>capability</code> string &#8211; Capability requirements JSON stringified for the token.</li>
	<li><code>(TK2c)</code> <code>clientId</code> string &#8211; A <code>clientId</code> string to associate with this token. If <code>clientId</code> is <code>null</code> or omitted, then the token is prohibited from assuming a <code>clientId</code> in any operations, however if <code>clientId</code> is a wildcard string <code>'*'</code>, then the token is permitted to assume any <code>clientId</code>. Any other string value for <code>clientId</code> implies that the <code>clientId</code> is both enforced and assumed for all operations for this token</li>
	<li><code>(TK2d)</code> <code>timestamp</code> long &#8211; The timestamp (in millis since the epoch) of this request. Timestamps, in conjunction with the <code>nonce</code>, are used to prevent n requests from being replayed</li>
</ul>
<h4>AuthOptions</h4>
<ul>
	<li><code>(AO1)</code> A class providing configurable authentication options used when authenticating or issuing tokens explicitly. These options are used when invoking <code>Auth#authorise</code>, <code>Auth#requestToken</code> and <code>Auth#createTokenRequest</code></li>
	<li><code>(AO2)</code> The attributes of <code>AuthOptions</code> consist of:
	<ul>
		<li><code>(AO2a)</code> <code>key</code> string &#8211; Full Ably key string, as obtained from dashboard, used when signing token requests locally</li>
		<li><code>(AO2b)</code> <code>authCallback</code> &#8211; A callback to call to obtain a signed <code>TokenRequest</code>, <code>TokenDetails</code> or a token string. This enables a client to obtain token requests or tokens from another entity, so tokens can be renewed without the client requiring a key</li>
		<li><code>(AO2c)</code> <code>authUrl</code> string &#8211; A URL to query to obtain a signed <code>TokenRequest</code>, <code>TokenDetails</code> or a token string. This enables a client to obtain token request or token from another entity, so tokens can be renewed without the client requiring a key</li>
		<li><code>(AO2d)</code> <code>authMethod</code> &#8211; The HTTP verb to be used when a request is made by the library to the <code>authUrl</code>. Defaults to <code>GET</code>, supports <code>GET</code> and <code>POST</code></li>
		<li><code>(AO2e)</code> <code>authHeaders</code> &#8211; Headers to be included in any request made by the library to the <code>authUrl</code></li>
		<li><code>(AO2f)</code> <code>authParams</code> &#8211; Additional params to be included in any request made by the library to the <code>authUrl</code>, either as query params in the case of <code>GET</code> or in the body in the case of <code>POST</code></li>
		<li><code>(AO2g)</code> <code>queryTime</code> &#8211; If true, the library will query the Ably system for the current time instead of relying on a locally-available time of day</li>
		<li><code>(AO2h)</code> <code>force</code> &#8211; when true, indicates that a new token should be requested</li>
	</ul></li>
</ul>
<h4>ChannelOptions</h4>
<ul>
	<li><code>(TB1)</code> options provided when instancing a channel, see <a href="https://github.com/ably/ably-java/blob/master/src/io/ably/types/ChannelOptions.java">Java ChannelOptions</a> as a reference</li>
	<li><code>(TB2)</code> The attributes of <code>ChannelOptions</code> consist of:
	<ul>
		<li><code>(TB2a)</code> <code>encrypted</code> boolean &#8211; when true, enables automatic encryption &amp; decryption of all messages</li>
		<li><code>(TB2b)</code> <code>cipherParams</code> <code>CipherParams</code> &#8211; when encrypted is true, the cipher params are required</li>
	</ul></li>
</ul>
<h4>CipherParams</h4>
<ul>
	<li><code>(TZ1)</code> params to configure encryption for a channel, see <a href="https://github.com/ably/ably-java/blob/master/src/io/ably/util/Crypto.java#L52">Java CipherParams class</a> as a reference</li>
	<li><code>(TZ2)</code> The attributes of <code>CipherParams</code> consist of anything necessary to implement the supported algorithms (eg key and iv), in addition to the following standardised attributes:
	<ul>
		<li><code>(TZ2a)</code> <code>algorithm</code> string &#8211; Default is <code>AES</code>. Optionally specify the algorithm to use for encryption, currently only <code>AES</code> is supported</li>
		<li><code>(TZ2b)</code> <code>keyLength</code> integer &#8211; An integer, from an algorithm-dependent range of possible values. If unspecified, an algorithm-dependent default is used. For AES the allowed values at least include 128 and 256, with a default of 128.</li>
		<li><code>(TZ2c)</code> <code>mode</code> string &#8211; Default is <code>CBC</code>. Optionally specify cipher mode, currently only <code>CBC</code> is supported</li>
	</ul></li>
	<li><code>(TZ3)</code> <code>Crypto#getDefaultParams</code> function
	<ul>
		<li><code>(TZ3a)</code> returns a complete <code>CipherParams</code> instance with randomly generated key and iv</li>
		<li><code>(TZ3b)</code> takes an optional key parameter, returning a <code>CipherParams</code> instance created with that key and with a keyLength calculated from that key</li>
	</ul></li>
</ul>
<h3 id="defaults">Client Library defaults</h3>
<p>The following default values are configured for the client library:</p>
<ul>
	<li><code>(DF1)</code> Realtime defaults:
	<ul>
		<li><code>(DF1a)</code> <code>connectionStateTtl</code> integer &#8211; default 60s. The duration that Ably will persist the connection state when a Realtime client is abruptly disconnected. When the client is in the <code>DISCONNECTED</code> state, once this TTL has passed, the client should change the state to the <code>SUSPENDED</code> state signifying that the state is now lost i.e. channels need to be reattached manually.<br />
Note that this default is override by any <code>connectionStateTtl</code> specified in the <code>ConnectionDetails</code> of the <code>CONNECTED</code> <code>ProtocolMessage</code></li>
		<li><code>(DF1b)</code> <code>realtimeRequestTimeout</code> &#8211; default 10s. When a realtime client library is establishing a connection with Ably, or sending a <code>HEARTBEAT</code>, <code>CONNECT</code>, <code>ATTACH</code>, <code>DETACH</code> or <code>CLOSE</code> <code>ProtocolMessage</code> to Ably, this is the amount of time that the client library will wait before considering that request as failed and triggering a suitable failure condition</li>
	</ul></li>
</ul>
    </article>
    <hr class="back">
    <a href="#documentation">Back to top</a>
  </div>
  <div id="sidebar">
  <a href="/" title="API Documentation Home"><img src="/assets/ably-logo.png" class="ably-logo" title="API Documentation Home"></a>
  <ul>
<li class=''><a href='/root/quick-start-guide/'>Quickstart Guide</a></li>
<li class=''><a href='/root/how-ably-works/'>How Ably works</a></li>
<li class=''><a href='/root/usage-limits-billing/'>Usage Limits &amp; Billing</a></li>
</ul>
  <h2><a href="/realtime/">Realtime client lib</a></h2>
<ul>
<li class=''><a href='/realtime/usage/'>Using the Realtime library</a></li>
<li class=''><a href='/realtime/connection/'>Connection</a></li>
<li class=''><a href='/realtime/channels-messages/'>Channels and Messages</a></li>
<li class=''><a href='/realtime/presence/'>Presence</a></li>
<li class=''><a href='/realtime/authentication/'>Authentication</a></li>
<li class=''><a href='/realtime/history/'>History</a></li>
<li class=''><a href='/realtime/statistics/'>Statistics</a></li>
<li class=''><a href='/realtime/types/'>Types</a></li>
</ul>
  <h2><a href="/rest/">REST client lib</a></h2>
<ul>
<li class=''><a href='/rest/usage/'>Using the REST library</a></li>
<li class=''><a href='/rest/channels-messages/'>Channels and Messages</a></li>
<li class=''><a href='/rest/presence/'>Presence</a></li>
<li class=''><a href='/rest/authentication/'>Authentication</a></li>
<li class=''><a href='/rest/history/'>History</a></li>
<li class=''><a href='/rest/statistics/'>Statistics</a></li>
<li class=''><a href='/rest/encryption/'>Encryption</a></li>
</ul>
  <h2><a href="/rest-api/">REST API</a></h2>
<ul>
</ul>
  <h2>General</h2>
<ul>
<li class=''><a href='/general/authentication/'>Authentication</a></li>
<li class=''><a href='/general/channel-rules-namespaces/'>Channel Rules and Namespaces</a></li>
<li class=''><a href='/general/webhooks/'>Receiving Webhooks</a></li>
<li class=''><a href='/general/statistics/'>Application Statistics</a></li>
<li class=''><a href='/general/migrating/'>Migrating to Ably</a></li>
</ul>
  <h2><a href="/client-lib-development-guide/">Library Development</a></h2>
<ul>
<li class='selected'><a href='/client-lib-development-guide/features/'>Features spec v0.8</a></li>
<li class=''><a href='/client-lib-development-guide/feature-prioritisation/'>Feature prioritisation</a></li>
<li class=''><a href='/client-lib-development-guide/protocol/'>Realtime Protocol Definition</a></li>
<li class=''><a href='/client-lib-development-guide/rest-api/'>REST API Definition</a></li>
<li class=''><a href='/client-lib-development-guide/test-api/'>Sandbox Test API</a></li>
<li class=''><a href='/client-lib-development-guide/encryption/'>Encryption</a></li>
<li class=''><a href='/client-lib-development-guide/websocket/'>WebSocket Transport</a></li>
<li class=''><a href='/client-lib-development-guide/comet/'>Comet Transport</a></li>
<li class=''><a href='/client-lib-development-guide/connection-recovery/'>Connection Recovery</a></li>
<li class=''><a href='/client-lib-development-guide/connection-manager/'>Connection Manager</a></li>
<li class=''><a href='/client-lib-development-guide/connection-fallback/'>Connection host fallback</a></li>
<li class=''><a href='/client-lib-development-guide/documentation-formatting-guide/'>Documentation Formatting Guide</a></li>
<li class=''><a href='/code-index/'>Code Examples List</a></li>
</ul>
  <ul>
<li><a href="https://www.ably.io">Visit Ably.io</a></li>
</ul>
</div>

</body>
</html>
