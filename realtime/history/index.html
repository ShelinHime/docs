<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Ably API Documentation - History</title>
    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="stylesheet" type="text/css" href="/vendor/prettify/prettify.css" media="screen">
    <link rel="stylesheet" type="text/css" href="/stylesheet.css" media="screen">

    
      <link rel="canonical" href="https://www.ably.io/documentation/realtime/history" />
    

    <script src="/vendor/javascripts/jquery-1-8-3-min.js" type="text/javascript"></script>
    <script src="/vendor/javascripts/jquery-cookie-1-3-1.js" type="text/javascript"></script>
    <script src="/vendor/javascripts/base64.js" type="text/javascript"></script>

    <script src="/vendor/prettify/prettify-lib.js" type="text/javascript"></script>

    <script src="//cdn.ably.io/lib/ably.min.js" type="text/javascript"></script>

    <script src="/javascripts/application.js" type="text/javascript"></script>
    <script src="/javascripts/lang-manager.js" type="text/javascript"></script>

    <script type="text/javascript">window.NavLangs=["javascript","nodejs","ruby","java","swift","objc"];</script>

    <!-- you don't need to keep this, but it's cool for stats! -->
    <meta name="generator" content="nanoc 3.7.5">
  </head>
  <body>
    <div class="canonical-notice">
      <img src="/images/icon-alert.png">
      <span class="canonical-notice-text">
        You are viewing our bleeding edge unstable documentation. We recommend you use our <a href="https://www.ably.io/documentation">stable documentation Â»</a>
      </span>
      <img src="/images/icon-alert.png">
    </div>
    <div class="fork-banner"><a href="https://github.com/ably/docs"><img src="/images/forkme.png" alt="Fork me on GitHub"></a></div>

  <div id="documentation">
    
      <nav class="jump-to-nav">
        <div class="form">
          <select id="jump-to-nav">
            <option>Jump to ...</option>
            <optgroup label='Help with'>
<option id="anchor-getting-started">Getting started</option>
<option id="anchor-channel-and-presence">Channel and Presence history</option>
<option id="anchor-persisted-history">Persisted history</option>
<option id="anchor-continuous-history">Continuous history</option>
</optgroup>
<optgroup label='API reference'>
<option id="anchor-channel-history">Message history</option>
<option id="anchor-presence-history">Presence history</option>
</optgroup>
          </select>
        </div>
      </nav>
    
    <header>
      
        <div class="breadcrumb"><a href="/realtime/">Realtime Client Library API</a><span class="separator">/</span></div>
      
      
        <h1 id="title">History</h1>
      
    </header>
    <article>
      <p>The Realtime client library provides message and presence event history for channels. Channel history can be used to return continuous message history up to the exact point a realtime channel was attached, and combines both instantaneous &#8220;live&#8221; history as well as the longer term <a href="#persisted-history">persisted history</a>. If <a href="#persisted-history">persisted history</a> is enabled for the channel, then messages will <a href="https://support.ably.io/solution/articles/3000030059-how-long-are-messages-stored-for">typically be stored for 24 &#8211; 72 hours on disk</a>. If persisted history is not enabled, Ably retains the last two minutes of instantaneous &#8220;live&#8221; message history in memory.</p>
<h2 id="getting-started">Getting started</h2>
<p>The Ably Realtime client library provides a straightforward API to retrieve <a href="#paginated-result">paginated</a> message or presence event history. Each page of history, by default, contains up to 100 messages. Message ordering, by default, is from most recent to oldest.</p>
<pre class="code-editor open-jsbin open-jsbin-eqiyuq" lang="javascript"><code class="code-editor open-jsbin open-jsbin-eqiyuq" lang="javascript">var realtime = new Ably.Realtime('{{API_KEY}}');
var channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');
channel.publish('example', 'message data', function(err) {
  channel.history(function(err, resultPage) {
    var lastMessage = resultPage.items[0];
    alert('Last message: ' + lastMessage.id + ' - ' + lastMessage.data);
  });
});</code></pre>
<pre class="code-editor open-jsbin open-jsbin-eqiyuq" lang="nodejs"><code class="code-editor open-jsbin open-jsbin-eqiyuq" lang="nodejs">var realtime = new Ably.Realtime('{{API_KEY}}');
var channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');
channel.publish('example', 'message data', function(err) {
  channel.history(function(err, resultPage) {
    var lastMessage = resultPage.items[0];
    alert('Last message: ' + lastMessage.id + ' - ' + lastMessage.data);
  });
});</code></pre>
<pre lang="ruby"><code lang="ruby">realtime = Ably::Realtime.new('{{API_KEY}}')
channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}')
channel.publish 'example', 'message data' do
  channel.history do |result_page|
    last_message = result_page.items.last
    puts "Last message: #{last_message.message.id} - #{last_message.data}")
  end
end</code></pre>
<pre lang="java"><code lang="java">AblyRealtime realtime = new AblyRealtime("{{API_KEY}}");
Channel channel = realtime.channels.get("{{RANDOM_CHANNEL_NAME}}");
channel.publish("example", "message data", new CompletionListener() {
  @Override
  public void onError(ErrorInfo reason) {
    System.out.println("Unable to publish message; err = " + reason.message);
  }
  @Override
  public void onSuccess() {
    PaginatedResult&lt;Message&gt; resultPage = channel.history(null);
    Message lastMessage = resultPage.items[0];
    System.out.println("Last message: " + lastMessage.id + " - " + lastMessage.data);
  }
});</code></pre>
<pre lang="objc"><code lang="objc">ARTRealtime *realtime = [[ARTRealtime alloc] initWithKey:@"{{API_KEY}}"];
ARTRealtimeChannel *channel = [realtime.channels get:@"RANDOM_CHANNEL_NAME"];
[channel publish:@"example" data:@"message data" callback:^(ARTErrorInfo *error) {
    if (error) {
        NSLog(@"Unable to publish message; err = %@", error.message);
        return;
    }
    [channel history:^(ARTPaginatedResult&lt;ARTMessage *&gt; *resultPage, ARTErrorInfo *error) {
        ARTMessage *lastMessage = resultPage.items[0];
        NSLog(@"Last message: %@ - %@", lastMessage.id,lastMessage.data);
    }];
}];</code></pre>
<pre lang="swift"><code lang="swift">let realtime = ARTRealtime(key: "{{API_KEY}}")
let channel = realtime.channels.get("{{RANDOM_CHANNEL_NAME}}")
channel.publish("example", data: "message data") { error in
    if let error = error {
        print("Unable to publish message; err = \(error.message)")
        return
    }
    channel.history { resultPage, error in
        let lastMessage = resultPage!.items[0] as! ARTMessage
        print("Last message: \(lastMessage.id) - \(lastMessage.data)")
    }
}</code></pre>
<h2 id="channel-and-presence">Channel &amp; Presence history</h2>
<p>Both the <a href="/realtime/channels-messages"><code>Channel</code></a> and <a href="/realtime/presence"><code>Presence</code></a> objects provide history. The <a href="/realtime/channels-messages"><code>Channel</code></a> object provides the history of <a href="#message"><code>Message</code></a> objects published on the channel, whereas the <a href="/realtime/presence"><code>Presence</code></a> object provides presence event history of that channel i.e. members entering, updating or leaving the channel as <a href="#presence-message"><code>PresenceMessage</code></a> objects.</p>
<h3 id="persisted-history">Enabling persistent history</h3>
<p>By default, persisted history on channels is disabled and messages are only stored by the Ably service for two minutes in memory. If persisted history is enabled for the channel, then messages will <a href="https://support.ably.io/solution/articles/3000030059-how-long-are-messages-stored-for">typically be stored for 24 &#8211; 72 hours on disk</a>.</p>
<p>Every message that is persisted to or retrieved from disk counts as an extra message towards your monthly quote. For example, for a channel that has persistence enabled, if a message is published, two messages will be deducted from your monthly quota. If the message is later retrieved from history, another message will be deducted from your monthly quota.</p>
<p>To enable history on a channel, it is necessary to add a channel rule in the settings of your <a href="https://support.ably.io/solution/articles/3000030053-how-do-i-access-my-app-dashboard">application dashboard</a>. See the <a href="https://support.ably.io/solution/articles/3000030057-what-are-channel-rules-and-how-can-i-use-them-in-my-app">documentation on channel rules</a> for further information on what they are and how to configure them.</p>
<h3 id="continuous-history">Continuous history</h3>
<p>It is possible to obtain message history that is continuous with the realtime messages received on an attached channel, in the backwards direction from the point of attachment. When a <code>Channel</code> instance is attached, it&#8217;s automatically populated by the Ably service with the serial number of the last published message on the channel. As such, using this serial number, the client library is able to make a history request to the Ably service for all messages received since the channel was attached. Any new messages therefore are received in realtime via the attached channel, and any historical messages are accessible via the history method.</p>
<p>In order to benefit from this functionality, the <code>untilAttach</code> option can be used when making history requests on attached channels. If the channel is not yet attached, this will result in an error.</p>
<pre class="code-editor open-jsbin open-jsbin-ewiduf" lang="javascript"><code class="code-editor open-jsbin open-jsbin-ewiduf" lang="javascript">var realtime = new Ably.Realtime('{{API_KEY}}');
var channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');
channnel.attach(function(err) {
  channel.history({ untilAttach: true}, function(err, resultPage) {
    var lastMessage = resultPage.items[0];
    alert('Last message before attach: ' + lastMessage.data);
  });
});</code></pre>
<pre class="code-editor open-jsbin open-jsbin-ewiduf" lang="nodejs"><code class="code-editor open-jsbin open-jsbin-ewiduf" lang="nodejs">var realtime = new Ably.Realtime('{{API_KEY}}');
var channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');
channnel.attach(function(err) {
  channel.history({ untilAttach: true}, function(err, resultPage) {
    var lastMessage = resultPage.items[0];
    alert('Last message before attach: ' + lastMessage.data);
  });
});</code></pre>
<pre lang="ruby"><code lang="ruby">realtime = Ably::Realtime.new('{{API_KEY}}')
channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}')
channnel.attach do
  channel.history(until_attach: true) do |result_page|
    last_message = result_page.items.last
    puts "Last message before attach: #{last_message.data}")
  end
end</code></pre>
<pre lang="java"><code lang="java">AblyRealtime realtime = new AblyRealtime("{{API_KEY}}");
Channel channel = realtime.channels.get("{{RANDOM_CHANNEL_NAME}}");
channel.attach();
channel.on(ChannelState.attached, new ChannelStateListener() {
  @Override
  public void onChannelStateChanged(ChannelState state, ErrorInfo reason) {
    Param[] options = new Param[]{ new Param("untilAttach", "true") };
    PaginatedResult&lt;Message&gt; resultPage = channel.history(options);
    Message lastMessage = resultPage.items[0];
    System.out.println("Last message before attach: " + lastMessage.data);
  }
});</code></pre>
<pre lang="objc"><code lang="objc">ARTRealtime *realtime = [[ARTRealtime alloc] initWithKey:@"{{API_KEY}}"];
ARTRealtimeChannel *channel = [realtime.channels get:@"RANDOM_CHANNEL_NAME"];
[channel attach];
[channel on:ARTChannelEventAttached call:^(ARTErrorInfo *error) {
    ARTRealtimeHistoryQuery *query = [[ARTRealtimeHistoryQuery alloc] init];
    query.untilAttach = YES;
    [channel history:query callback:^(ARTPaginatedResult&lt;ARTMessage *&gt; *resultPage, ARTErrorInfo *error) {
        ARTMessage *lastMessage = resultPage.items[0];
        NSLog(@"Last message: %@ - %@", lastMessage.id,lastMessage.data);
    } error:nil];
}];</code></pre>
<pre lang="swift"><code lang="swift">let realtime = ARTRealtime(key: "{{API_KEY}}")
let channel = realtime.channels.get("{{RANDOM_CHANNEL_NAME}}")
channel.attach()
channel.on(.Attached) { error in
    let query = ARTRealtimeHistoryQuery()
    query.untilAttach = true
    try! channel.history(query) { resultPage, error in
        let lastMessage = resultPage!.items[0] as! ARTMessage
        print("Last message before attach: \(lastMessage.id) - \(lastMessage.data)")
    }
}</code></pre>
<h1>API reference</h1>
<div class="inline-toc">
<ul><li>History API
<ul>
<li>
Channel
<ul>
<li><a href='#channel-history'>history(options)</a></li>
</ul>
</li>
<li>
Presence
<ul>
<li><a href='#presence-history'>history(options)</a></li>
</ul>
</li>
<li>
Related types
<ul>
<li><a href='#message'>Message</a></li>
<li><a href='#presence-message'>PresenceMessage</a></li>
<li><a href='#presence-action'>Presence action</a></li>
<li><a href='#paginated-result'>PaginatedResult</a></li>
<li><a href='#param'>Param</a></li>
</ul>
</li>
</ul>
</li></ul>
</div><h2>Channel object</h2>
<p>The <a href="/realtime/channels-messages">Realtime <code>Channel</code> object</a> exposes the following public method to obtain <a href="#message"><code>Message</code></a> history.</p>
<h3>Methods</h3>
<h6 id="channel-history">history</h6>
<blockquote class="definition">
<p class="definition"><span lang='default'>history(Object option, callback(<a href="/realtime/types#error-info">ErrorInfo</a> err, <a href="#paginated-result">PaginatedResult</a>&lt;<a href="#message">Message</a>&gt; resultPage))</span><span lang='ruby'><a href="/realtime/types#deferrable">Deferrable</a> history(Hash option) &#8594; yields <a href="#paginated-result">PaginatedResult</a>&lt;<a href="#message">Message</a>&gt;</span><span lang='java'>public <a href="#paginated-result">PaginatedResult</a>&lt;<a href="#message">Message</a>&gt; history(<a href="#param">Param</a>[] option)</span><span lang='objc,swift'>history(query: ARTRealtimeHistoryQuery?, callback: (<a href="#paginated-result">ARTPaginatedResult</a>&lt;<a href="#message">ARTMessage</a>&gt;?, ARTErrorInfo?) &#8594; Void) throws</span></p>
</blockquote>
<p>Gets a <a href="#paginated-result">paginated</a> set of historical messages for this channel.</p>
<h4>Parameters</h4>
<dl>
	<dt><span lang="default">option</span><span lang="objc,swift">query</span><span lang="java"><a href="#param">Param</a>[] option</span></dt>
	<dd><span lang="default">an optional object containing the query parameters</span><span lang="ruby">an optional set of key value pairs containing the query parameters</span>, as specified below.</dd>
</dl>
<dl>
	<dt><div lang="javascript,nodejs">callback</div></dt>
	<dd>is a function of the form: <code>function(err, resultPage)</code></dd>
	<dt><div lang="ruby">&amp;block</div></dt>
	<dd>yields a <code>PaginatedResult&lt;Message&gt;</code> array</dd>
	<dt><div lang="swift,objc">callback</div></dt>
	<dd>called with a <a href="#paginated-result">ARTPaginatedResult</a>&lt;<a href="#message">ARTMessage</a>&gt; object or an error</dd>
</dl>
<h4><span lang="default"><code>options</code> parameters</span><span lang="objc,swift"><code>ARTRealtimeHistoryQuery</code> properties</span></h4>
<dl>
	<dt><span lang="ruby">:</span>start</dt>
	<dd><em>beginning of time</em> earliest <span lang="ruby"><code>Time</code> or </span>time in milliseconds since the epoch for any message retrieved<br><i>Type: <code>Long</code><span lang="ruby">, <code>Time</code></span></i></dd>
	<dt><span lang="ruby">:</span>end</dt>
	<dd><em>current time</em> latest <span lang="ruby"><code>Time</code> or </span>time in milliseconds since the epoch for any messages retrieved<br><i>Type: <code>Long</code><span lang="ruby">, <code>Time</code></span></i></dd>
	<dt><span lang="ruby">:</span>direction</dt>
	<dd><em>backwards</em> <span lang="ruby"><code>:</code></span><code>forwards</code> or <span lang="ruby"><code>:</code></span><code>backwards</code><br><i>Type: <span lang="default"><code>String</code></span><span lang="ruby"><code>Symbol</code></span></i></dd>
	<dt><span lang="ruby">:</span>limit</dt>
	<dd><em>100</em> maximum number of messages to retrieve up to 1,000<br><i>Type: <code>Integer</code></i></dd>
	<dt><span lang="default">untilAttach</span><span lang="ruby">:until_attach</span></dt>
	<dd><em>false</em> when true, ensures message history is up until the point of the channel being attached. See <a href="#continuous-history">continuous history</a> for more info. If the <code>Channel</code> is not attached, enabling this option will result in error<br><i>Type: <code>Boolean</code></i></dd>
</dl>


<div lang="javascript,nodejs,,objc,swift"> <!-- start javascript,nodejs,,objc,swift language block -->
<h4>Callback result</h4>
<p>On success, <code>resultPage</code> contains a <a href="#paginated-result"><code>PaginatedResult</code></a> encapsulating an array of <a href="#message"><code>Message</code></a> objects corresponding to the current page of results. <a href="#paginated-result"><code>PaginatedResult</code></a> supports pagination using <a href="#paginated-result"><code>next()</code></a> and <a href="#paginated-result"><code>first()</code></a> methods.</p>
<p>On failure to retrieve message history, <code>err</code> contains an <a href="#error-info"><code>ErrorInfo</code></a> object with the failure reason.</p>

</div> <!-- /end javascript,nodejs,,objc,swift language block -->



<div lang="java"> <!-- start java language block -->
<h4>Returns</h4>
<p>On success, the returned <a href="#paginated-result"><code>PaginatedResult</code></a> encapsulates an array of <a href="#message"><code>Message</code></a> objects corresponding to the current page of results. <a href="#paginated-result"><code>PaginatedResult</code></a> supports pagination using <a href="#paginated-result"><code>next</code></a> and <a href="#paginated-result"><code>first</code></a> methods.</p>
<p>Failure to retrieve the message history will raise an <a href="/realtime/types/#ably-exception"><code>AblyException</code></a></p>

</div> <!-- /end java language block -->



<div lang="ruby"> <!-- start ruby language block -->
<h4>Returns</h4>
<p>A <a href="/realtime/types#deferrable"><code>Deferrable</code></a> object is returned from the method.</p>
<p>On success, the registered success blocks for the <a href="/realtime/types#deferrable"><code>Deferrable</code></a> and any block provided to the method yield a <a href="#paginated-result">PaginatedResult</a> that encapsulates an array of <a href="#message"><code>Message</code></a> objects corresponding to the current page of results. <a href="#paginated-result"><code>PaginatedResult</code></a> supports pagination using <a href="#paginated-result"><code>next()</code></a> and <a href="#paginated-result"><code>first()</code></a> methods.</p>
<p>Failure to retrieve the message history will trigger the <code>errback</code> callbacks of the <a href="/realtime/types#deferrable"><code>Deferrable</code></a> with an <a href="#error-info"><code>ErrorInfo</code></a> object with the failure reason.</p>

</div> <!-- /end ruby language block -->

<h2>Presence object</h2>
<p><a href="/realtime/presence">Realtime <code>Presence</code> object</a> exposes the following public method to obtain presence event history such as enter, update and leave events. These events are represented as <a href="#presence-message"><code>PresenceMessage</code></a> objects.</p>
<h3>Methods</h3>
<h6 id="presence-history">history</h6>
<blockquote class="definition">
<p class="definition"><span lang='default'>history(Object option, callback(<a href="/realtime/types#error-info">ErrorInfo</a> err, <a href="#paginated-result">PaginatedResult</a>&lt;<a href="#presence-message">PresenceMessage</a>&gt; resultPage))</span><span lang='ruby'><a href="/realtime/types#deferrable">Deferrable</a> history(Hash option) &#8594; yields <a href="#paginated-result">PaginatedResult</a>&lt;<a href="#presence-message">PresenceMessage</a>&gt;</span><span lang='java'>public <a href="#paginated-result">PaginatedResult</a>&lt;<a href="#presence-message">PresenceMessage</a>&gt; history(<a href="#param">Param</a>[] option)</span><span lang='objc,swift'>history(query: ARTRealtimeHistoryQuery?, callback: (<a href="#paginated-result">ARTPaginatedResult</a>&lt;<a href="#presence-message">ARTPresenceMessage</a>&gt;?, ARTErrorInfo?) &#8594; Void) throws</span></p>
</blockquote>
<p>Gets a <a href="#paginated-result">paginated</a> set of historical presence events for this channel.</p>
<h4>Parameters</h4>
<dl>
	<dt><span lang="default">option</span><span lang="objc,swift">query</span><span lang="java"><a href="#param">Param</a>[] option</span></dt>
	<dd><span lang="default">an optional object containing the query parameters</span><span lang="ruby">an optional set of key value pairs containing the query parameters</span>, as specified below.</dd>
</dl>
<dl>
	<dt><div lang="javascript,nodejs">callback</div></dt>
	<dd>is a function of the form: <code>function(err, resultPage)</code></dd>
	<dt><div lang="ruby">&amp;block</div></dt>
	<dd>yields a <code>PaginatedResult&lt;PresenceMessage&gt;</code> array</dd>
	<dt><div lang="swift,objc">callback</div></dt>
	<dd>called with a <a href="#paginated-result">ARTPaginatedResult</a>&lt;<a href="#presence-message">ARTPresenceMessage</a>&gt; object or an error</dd>
</dl>
<h4><span lang="default"><code>options</code> parameters</span><span lang="objc,swift"><code>ARTRealtimeHistoryQuery</code> properties</span></h4>
<dl>
	<dt><span lang="ruby">:</span>start</dt>
	<dd><em>beginning of time</em> earliest <span lang="ruby"><code>Time</code> or </span>time in milliseconds since the epoch for any presence event retrieved<br><i>Type: <code>Long</code><span lang="ruby">, <code>Time</code></span></i></dd>
	<dt><span lang="ruby">:</span>end</dt>
	<dd><em>current time</em> latest <span lang="ruby"><code>Time</code> or </span>time in milliseconds since the epoch for any presence events retrieved<br><i>Type: <code>Long</code><span lang="ruby">, <code>Time</code></span></i></dd>
	<dt><span lang="ruby">:</span>direction</dt>
	<dd><em>backwards</em> <span lang="ruby"><code>:</code></span><code>forwards</code> or <span lang="ruby"><code>:</code></span><code>backwards</code><br><i>Type: <span lang="default"><code>String</code></span><span lang="ruby"><code>Symbol</code></span></i></dd>
	<dt><span lang="ruby">:</span>limit</dt>
	<dd><em>100</em> maximum number of presence event messages to retrieve up to 1,000<br><i>Type: <code>Integer</code></i></dd>
	<dt><span lang="default">untilAttach</span><span lang="ruby">:until_attach</span></dt>
	<dd><em>false</em> when true, ensures presence event history is up until the point of the channel being attached. See <a href="#continuous-history">continuous history</a> for more info. If the <code>Channel</code> is not attached, enabling this option will result in error<br><i>Type: <code>Boolean</code></i></dd>
</dl>


<div lang="javascript,nodejs,,objc,swift"> <!-- start javascript,nodejs,,objc,swift language block -->
<h4>Callback result</h4>
<p>On success, <code>resultPage</code> contains a <a href="#paginated-result"><code>PaginatedResult</code></a> encapsulating an array of <a href="#presence-message"><code>PresenceMessage</code></a> objects corresponding to the current page of results. <a href="#paginated-result"><code>PaginatedResult</code></a> supports pagination using <a href="#paginated-result"><code>next()</code></a> and <a href="#paginated-result"><code>first()</code></a> methods.</p>
<p>On failure to retrieve presence event history, <code>err</code> contains an <a href="#error-info"><code>ErrorInfo</code></a> object with the failure reason.</p>

</div> <!-- /end javascript,nodejs,,objc,swift language block -->



<div lang="java"> <!-- start java language block -->
<h4>Returns</h4>
<p>On success, the returned <a href="#paginated-result"><code>PaginatedResult</code></a> encapsulates an array of <a href="#presence-message"><code>PresenceMessage</code></a> objects corresponding to the current page of results. <a href="#paginated-result"><code>PaginatedResult</code></a> supports pagination using <a href="#paginated-result"><code>next</code></a> and <a href="#paginated-result"><code>first</code></a> methods.</p>
<p>Failure to retrieve the presence event history will raise an <a href="/realtime/types/#ably-exception"><code>AblyException</code></a></p>

</div> <!-- /end java language block -->



<div lang="ruby"> <!-- start ruby language block -->
<h4>Returns</h4>
<p>A <a href="/realtime/types#deferrable"><code>Deferrable</code></a> object is returned from the method.</p>
<p>On success, the registered success blocks for the <a href="/realtime/types#deferrable"><code>Deferrable</code></a> and any block provided to the method yield a <a href="#paginated-result">PaginatedResult</a> that encapsulates an array of <a href="#presence-message"><code>PresenceMessage</code></a> objects corresponding to the current page of results. <a href="#paginated-result"><code>PaginatedResult</code></a> supports pagination using <a href="#paginated-result"><code>next()</code></a> and <a href="#paginated-result"><code>first()</code></a> methods.</p>
<p>Failure to retrieve the presence event history will trigger the <code>errback</code> callbacks of the <a href="/realtime/types#deferrable"><code>Deferrable</code></a> with an <a href="#error-info"><code>ErrorInfo</code></a> object with the failure reason.</p>

</div> <!-- /end ruby language block -->

<h2 id="related-types">Related types</h2>
<h3 id="message"><span lang='default'>Message</span><span lang='swift,objc'>ARTMessage</span><span lang='ruby'>Ably::Models::Message Enum</span><span lang='java'>io.ably.lib.types.Message</span></h3>
<p>A <code>Message</code> represents an individual message that is sent to or received from Ably.</p>
<h4><span lang='default'>Properties</span><span lang='java'>Members</span><span lang='ruby'>Attributes</span><span lang='python'>Attributes</span></h4>
<dl>
	<dt>name</dt>
	<dd>Event name, if provided<br><i>Type: <code>String</code></i></dd>
</dl>
<dl>
	<dt><div lang="default">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>String</code>, <code>StringBuffer</code>, <code>JSON Object</code></i></dd>
	<dt><div lang="java">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>String</code>, <code>ByteArray</code>, <code>JSONObject</code>, <code>JSONArray</code></i></dd>
	<dt><div lang="ruby">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>String</code>, <code>Binary</code> (ASCII-8BIT String), <code>Hash</code>, <code>Array</code></i></dd>
	<dt><div lang="python">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>String</code>, <code>Bytearray</code>, <code>Dict</code>, <code>List</code></i></dd>
	<dt><div lang="php">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>String</code>, <code>Binary String</code>, <code>Associative Array</code>, <code>Array</code></i></dd>
	<dt><div lang="objc">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>NSString *</code>, <code>NSData *</code>, <code>NSDictionary *</code>, <code>NSArray *</code></i></dd>
	<dt><div lang="swift">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>String</code>, <code>NSData</code>, <code>Dictionary</code>, <code>Array</code></i></dd>
</dl>
<dl>
	<dt>id</dt>
	<dd>Unique ID assigned by Ably to this message<br><i>Type: <code>String</code></i></dd>
</dl>
<dl>
	<dt><span lang="default">clientId</span><span lang="ruby,python">client_id</span></dt>
	<dd>The client ID of the publisher of this message<br><i>Type: <code>String</code></i></dd>
</dl>
<dl>
	<dt><span lang="default">connectionId</span><span lang="ruby,python">connection_id</span></dt>
	<dd>The connection ID of the publisher of this message<br><i>Type: <code>String</code></i></dd>
</dl>
<dl>
	<dt>timestamp</dt>
	<dd>Timestamp when the presence update was received by the Ably the realtime service, as <span lang="default">milliseconds since the epoch</span><span lang="ruby">a <code>Time</code> object</span><br><i>Type: <span lang="default"><code>Integer</code></span><span lang="java"><code>Long Integer</code></span><span lang="ruby"><code>Time</code></span><span lang="objc,swift"><code>NSDate</code></span></i></dd>
</dl>
<dl>
	<dt>encoding</dt>
	<dd>This will typically be empty as all messages received from Ably are automatically decoded client-side using this value. However, if the message encoding cannot be processed, this attribute will contain the remaining transformations not applied to the <code>data</code> payload<br><i>Type: <code>String</code></i></dd>
</dl>
<h3 id="presence-message"><span lang='default'>PresenceMessage</span><span lang='swift,objc'>ARTPresenceMessage</span><span lang='ruby'>Ably::Models::PresenceMessage Enum</span><span lang='java'>io.ably.lib.types.PresenceMessage</span></h3>
<p>A <code>PresenceMessage</code> represents an individual presence update that is sent to or received from Ably.</p>
<h4><span lang='default'>Properties</span><span lang='java'>Members</span><span lang='ruby'>Attributes</span></h4>
<dl>
	<dt><div lang="java">action</div></dt>
	<dd>the event signified by a PresenceMessage. See <a href="/realtime/types#presence-action"><code>PresenceMessage.action</code></a><br><i>Type: <code>enum { ABSENT, PRESENT, ENTER, LEAVE, UPDATE }</code></i></dd>
	<dt><div lang="javascript,nodejs">action</div></dt>
	<dd>the event signified by a PresenceMessage. See <a href="/realtime/types#presence-action"><code>Presence action</code></a><br><i>Type: <code>int enum { ABSENT, PRESENT, ENTER, LEAVE, UPDATE }</code></i></dd>
	<dt><div lang="python">action</div></dt>
	<dd>the event signified by a PresenceMessage. See <a href="/realtime/types#presence-action"><code>PresenceAction</code></a><br><i>Type: <code>int enum { ABSENT, PRESENT, ENTER, LEAVE, UPDATE }</code></i></dd>
	<dt><div lang="ruby">action</div></dt>
	<dd>the event signified by a PresenceMessage. See <a href="/realtime/types#presence-action"><code>PresenceMessage::ACTION</code></a><br><i>Type: <code>enum { :absent, :present, :enter, :leave, :update }</code></i></dd>
	<dt><div lang="php">action</div></dt>
	<dd>the event signified by a PresenceMessage. See <a href="/realtime/types#presence-action"><code>PresenceMessage::ACTION</code></a><br><i>Type: <code>const PresenceMessage::ABSENT,PRESENT,ENTER,LEAVE,UPDATE</code></i></dd>
	<dt><div lang="objc,swift">action</div></dt>
	<dd>the event signified by a PresenceMessage. See <a href="/realtime/types#presence-action"><code>PresenceMessage.action</code></a><br><i>Type: <code>ARTPresenceAction</code></i></dd>
</dl>
<dl>
	<dt><div lang="java">data</div></dt>
	<dd>The presence update payload, if provided<br><i>Type: <code>String</code>, <code>ByteArray</code>, <code>JSONObject</code>, <code>JSONArray</code></i></dd>
	<dt><div lang="javascript,nodejs">data</div></dt>
	<dd>The presence update payload, if provided<br><i>Type: <code>String</code>, <code>StringBuffer</code>, <code>JSON Object</code></i></dd>
	<dt><div lang="ruby">data</div></dt>
	<dd>The presence update payload, if provided<br><i>Type: <code>String</code>, <code>Binary</code> (ASCII-8BIT String), <code>Hash</code>, <code>Array</code></i></dd>
	<dt><div lang="python">data</div></dt>
	<dd>The presence update payload, if provided<br><i>Type: <code>String</code>, <code>Bytearray</code>, <code>Dict</code>, <code>List</code></i></dd>
	<dt><div lang="swift">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>String</code>, <code>NSData</code>, <code>Dictionary</code>, <code>Array</code></i></dd>
	<dt><div lang="objc">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>NSString *</code>, <code>NSData *</code>, <code>NSDictionary *</code>, <code>NSArray *</code></i></dd>
	<dt><div lang="php">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>String</code>, <code>Binary String</code>, <code>Associative Array</code>, <code>Array</code></i></dd>
</dl>
<dl>
	<dt>id</dt>
	<dd>Unique ID assigned by Ably to this presence update<br><i>Type: <code>String</code></i></dd>
</dl>
<dl>
	<dt><span lang="default">clientId</span><span lang="ruby,python">client_id</span></dt>
	<dd>The client ID of the publisher of this presence update<br><i>Type: <code>String</code></i></dd>
</dl>
<dl>
	<dt><span lang="default">connectionId</span><span lang="ruby,python">connection_id</span></dt>
	<dd>The connection ID of the publisher of this presence update<br><i>Type: <code>String</code></i></dd>
</dl>
<dl>
	<dt>timestamp</dt>
	<dd>Timestamp when the presence update was received by the Ably the realtime service<span lang="default">, as milliseconds since the epoch</span><span lang="ruby,objc,swift"></span>.<br><i>Type: <span lang="default"><code>Integer</code></span><span lang="java"><code>Long Integer</code></span><span lang="ruby"><code>Time</code></span><span lang="objc,swift"><code>NSDate</code></span></i></dd>
</dl>
<dl>
	<dt>encoding</dt>
	<dd>This will typically be empty as all presence updates received from Ably are automatically decoded client-side using this value. However, if the message encoding cannot be processed, this attribute will contain the remaining transformations not applied to the <code>data</code> payload<br><i>Type: <code>String</code></i></dd>
</dl>
<h3 id="presence-action"><span lang='default'>Presence action</span><span lang='swift,objc'>ARTPresenceAction</span><span lang='java'>io.ably.lib.types.PresenceMessage.Action</span><span lang='ruby'>Ably::Models::PresenceMessage::ACTION</span></h3>


<div lang="javascript,nodejs"> <!-- start javascript,nodejs language block -->
<p><code>Presence</code> <code>action</code> is a String with a value matching any of the <a href="/realtime/presence#presence-states"><code>Realtime Presence</code> states &amp; events</a>.</p>
<pre lang="javascript"><code lang="javascript">var allPresenceActions = [
  'absent', // (reserved for internal use)
  'present',
  'enter',
  'leave',
  'update'
]</code></pre>

</div> <!-- /end javascript,nodejs language block -->



<div lang="java"> <!-- start java language block -->
<p><code>io.ably.lib.types.PresenceMessage.Action</code> is an enum representing all the <a href="/realtime/presence#presence-states"><code>Realtime Presence</code> states &amp; events</a>.</p>
<pre lang="java"><code lang="java">public enum Action {
  ABSENT,  // 0 (reserved for internal use)
  PRESENT, // 1
  ENTER,   // 2
  LEAVE,   // 3
  UPDATE   // 4
}</code></pre>

</div> <!-- /end java language block -->



<div lang="python"> <!-- start python language block -->
<p><code>PresenceAction</code> is an enum-like class representing all the <a href="/realtime/presence#presence-states"><code>Realtime Presence</code> states &amp; events</a>.</p>
<pre lang="python"><code lang="python">class PresenceAction(object):
  ABSENT = 0    # (reserved for internal use)
  PRESENT = 1
  ENTER = 2
  LEAVE = 3
  UPDATE = 4</code></pre>

</div> <!-- /end python language block -->



<div lang="php"> <!-- start php language block -->
<p><code>PresenceMessage Action</code> is one of the class constants representing all the <a href="/realtime/presence#presence-states"><code>Realtime Presence</code> states &amp; events</a>.</p>
<pre lang="php"><code lang="php">namespace Ably\Models;
class PresenceMessages {
  const ABSENT  = 0; /* (reserved for internal use) */
  const PRESENT = 1;
  const ENTER   = 2;
  const LEAVE   = 3;
  const UPDATE  = 4;
}</code></pre>
<h4>Example usage</h4>
<pre lang="php"><code lang="php">if ($presenceMessage-&gt;action == Ably\Models\PresenceMesage::ENTER) {
  /* do something */
}</code></pre>

</div> <!-- /end php language block -->



<div lang="ruby"> <!-- start ruby language block -->
<p><code>Ably::Models::PresenceMessage::ACTION</code> is an enum-like value representing all the <a href="/realtime/presence#presence-states"><code>Realtime Presence</code> states &amp; events</a>. <code>ACTION</code> can be represented interchangeably as either symbols or constants.</p>
<h4>Symbol states</h4>
<pre lang="ruby"><code lang="ruby">:absent  # =&gt; 0 (reserved for internal use)
:present # =&gt; 1
:enter   # =&gt; 2
:leave   # =&gt; 3
:update  # =&gt; 4</code></pre>
<h4>Constant states</h4>
<pre lang="ruby"><code lang="ruby">PresenceMessage::ACTION.Absent  # =&gt; 0 (internal use)
PresenceMessage::ACTION.Present # =&gt; 1
PresenceMessage::ACTION.Enter   # =&gt; 2
PresenceMessage::ACTION.Leave   # =&gt; 3
PresenceMessage::ACTION.Update  # =&gt; 4</code></pre>
<h4>Example usage</h4>
<pre lang="ruby"><code lang="ruby"># Example with symbols
presence.on(:attached) { ... }

# Example with constants
presence.on(Ably::Models::PresenceMessage::ACTION.Enter) { ... }

# Interchangeable
Ably::Models::PresenceMessage::ACTION.Enter == :enter # =&gt; true</code></pre>

</div> <!-- /end ruby language block -->



<div lang="objc,swift"> <!-- start objc,swift language block -->
<p><code>ARTPresenceAction</code> is an enum representing all the <a href="/realtime/presence#presence-states"><code>Realtime Presence</code> states &amp; events</a>.</p>
<pre lang="objc"><code lang="objc">typedef NS_ENUM(NSUInteger, ARTPresenceAction) {
    ARTPresenceAbsent,
    ARTPresencePresent,
    ARTPresenceEnter,
    ARTPresenceLeave,
    ARTPresenceUpdate,
    ARTPresenceLast
};</code></pre>
<pre lang="swift"><code lang="swift">enum ARTPresenceAction : UInt {
  case Absent
  case Present
  case Enter
  case Leave
  case Update
  case Last
}</code></pre>

</div> <!-- /end objc,swift language block -->

<h3 id="paginated-result"><span lang='default'>PaginatedResult</span><span lang='swift,objc'>ARTPaginatedResult</span><span lang='ruby'>Ably::Models::PaginatedResult</span><span lang='java'>io.ably.lib.types.PaginatedResult</span></h3>
<p>A <code>PaginatedResult</code> is a type that represents a page of results for all message and presence history, stats and REST presence requests. The response from a <a href="/rest-api/#pagination">Ably REST API paginated query</a> is accompanied by metadata that indicates the relative queries available to the <code>PaginatedResult</code> object.</p>
<h4><span lang='default'>Properties</span><span lang='java'>Members</span><span lang='ruby'>Attributes</span><span lang='python'>Attributes</span></h4>
<dl>
	<dt>items</dt>
	<dd>contains a page of results (for example an Array of <a href="#message"><code>Message</code></a> or <a href="#presence-message"><code>PresenceMessage</code></a> objects for a channel history request)<br><span lang="default"><i>Type: <code>Array &lt;Message, Presence, Stats&gt;</code></i></span><span lang="python"><i>Type: <code>List &lt;Message, Presence, Stats&gt;</code></i></span></dd>
</dl>
<dl>
	<dt><div lang="default">isLast</div></dt>
	<dd><code>true</code> if this page is the last page<br><i>Type: <code>Boolean</code></i></dd>
	<dt><div lang="ruby">last?</div></dt>
	<dd><code>true</code> if this page is the last page<br><i>Type: <code>Boolean</code></i></dd>
	<dt><div lang="php">isLast()</div></dt>
	<dd><code>true</code> if this page is the last page<br><i>Type: <code>Boolean</code></i></dd>
	<dt><div lang="python">is_last()</div></dt>
	<dd><code>True</code> if this page is the last page<br><i>Type: <code>Boolean</code></i></dd>
</dl>
<dl>
	<dt><div lang="default">hasNext</div></dt>
	<dd><code>true</code> if there are further pages<br><i>Type: <code>Boolean</code></i></dd>
	<dt><div lang="ruby">has_next?</div></dt>
	<dd><code>true</code> if there are further pages<br><i>Type: <code>Boolean</code></i></dd>
	<dt><div lang="php">hasNext()</div></dt>
	<dd><code>true</code> if there are further pages<br><i>Type: <code>Boolean</code></i></dd>
	<dt><div lang="python">has_next()</div></dt>
	<dd><code>True</code> if there are further pages<br><i>Type: <code>Boolean</code></i></dd>
</dl>
<h4>Methods</h4>
<h6>first</h6>
<blockquote class="definition">
<p class="definition"><span lang='default'>first(callback(<a href="/realtime/types#error-info">ErrorInfo</a> err, <a href="/realtime/types#paginated-result">PaginatedResult</a> resultPage))</span><span lang='ruby'><a href="/realtime/types#paginated-result">PaginatedResult</a> first</span><span lang='php'><a href="/realtime/types#paginated-result">PaginatedResult</a> first()</span><span lang='python'><a href="/realtime/types#paginated-result">PaginatedResult</a> first()</span><span lang='java'>public <a href="/realtime/types#paginated-result">PaginatedResult</a> first()</span><span lang='swift,objc'>first(callback: (ARTPaginatedResult?, ARTErrorInfo?) &#8594; Void)</span></p>
</blockquote>
<p>Returns a new <code>PaginatedResult</code> for the first page of results. <span lang="ruby">When using the Realtime library, the <code>first</code> method returns a <a href="/realtime/types#deferrable">Deferrable</a> and yields a <a href="/realtime/types#paginated-result">PaginatedResult</a>.</span></p>
<h6>items</h6>
<blockquote class="definition">
<p class="definition"><span lang='default'>Object[] items()</span><span lang='python'>List items()</span><span lang='ruby'>Object[] items</span><span lang='java'>public Object[] items()</span><span lang='swift, objc'>items: [AnyObject]</span></p>
</blockquote>
<p>Returns the current page of results as <span lang="default">an Array</span><span lang="python">a <code>List</code></span>. The type of the objects in the <span lang="default">array</span><span lang="python">list</span> is determined by the operation that provided the <code>PaginatedResult</code>. For example, a <a href="/realtime/channels-messages#history">Message#history</a> request will return <span lang="default">an array</span><span lang="python">a list</span> of <code>Message</code> objects.</p>
<h6>next</h6>
<blockquote class="definition">
<p class="definition"><span lang='default'>next(callback(<a href="/realtime/types#error-info">ErrorInfo</a> err, <a href="/realtime/types#paginated-result">PaginatedResult</a> resultPage))</span><span lang='ruby'><a href="/realtime/types#paginated-result">PaginatedResult</a> next</span><span lang='php'><a href="/realtime/types#paginated-result">PaginatedResult</a> next()</span><span lang='python'><a href="/realtime/types#paginated-result">PaginatedResult</a> next()</span><span lang='java'>public <a href="/realtime/types#paginated-result">PaginatedResult</a> next()</span><span lang='swift,objc'>next(callback: (ARTPaginatedResult?, ARTErrorInfo?) &#8594; Void)</span></p>
</blockquote>
<p>Returns a new <code>PaginatedResult</code> loaded with the next page of results. If there are no further pages, then <span lang="default"><code>null</code></span><span lang="java"><code>Null</code></span><span lang="python"><code>None</code></span><span lang="ruby,objc,swift"><code>nil</code></span> is returned. <span lang="ruby">When using the Realtime library, the <code>first</code> method returns a <a href="/realtime/types#deferrable">Deferrable</a> and yields a <a href="/realtime/types#paginated-result">PaginatedResult</a>.</span></p>
<h4>Example</h4>
<pre lang="javascript"><code lang="javascript">channel.history(function(err, paginatedResult) {
  console.log('Page 0 item 0:' + paginatedResult.items[0].data);
  paginatedResult.next(function(err, nextPage) {
    console.log('Page 1 item 1: ' + nextPage.items[1].data);
    console.log('Last page?: ' + nextPage.isLast;
  });
});</code></pre>
<pre lang="nodejs"><code lang="nodejs">channel.history(function(err, paginatedResult) {
  console.log('Page 0 item 0:' + paginatedResult.items[0].data);
  paginatedResult.next(function(err, nextPage) {
    console.log('Page 1 item 1: ' + nextPage.items[1].data);
    console.log('Last page?: ' + nextPage.isLast;
  });
});</code></pre>
<pre lang="java"><code lang="java">PaginatedResult firstPage = channel.history();
System.out.println("Page 0 item 0:" + firstPage.items[0].data);
if (firstPage.hasNext) {
  PaginatedResult nextPage = firstPage.next();
  System.out.println("Page 1 item 1:" + nextPage.items[1].data);
  System.out.println("More pages?:" + Strong.valueOf(nextpage.hasNext()));
});</code></pre>
<pre lang="ruby"><code lang="ruby"># When using the REST sync library
first_page = channel.history
puts "Page 0 item 0: #{first_page.items[0].data}"
if first_page.has_next?
  next_page = first_page.next
  puts "Page 1 item 1: #{next_page.items[1].data}"
  puts "Last page?: #{next_page.is_last?}"
end

# When using the Realtime EventMachine library
channel.history do |first_page|
  puts "Page 0 item 0: #{first_page.items[0].data}"
  if first_page.has_next?
    first_page.next do |next_page|
      puts "Page 1 item 1: #{next_page.items[1].data}"
      puts "Last page?: #{next_page.is_last?}"
    end
  end
end</code></pre>
<pre lang="python"><code lang="python">result_page = channel.history()
print 'Page 0 item 0: ' + str(result_page.items[0].data)
if result_page.has_next():
  next_page = result_page.next()
  print 'Page 1 item 1: ' + str(next_page.items[1].data)
  print 'Last page?: ' + str(next_page.is_last())</code></pre>
<pre lang="php"><code lang="php">$firstPage = $channel.history();
echo("Page 0 item 0: " . $firstPage-&gt;items[0]-&gt;data);
if ($firstPage-&gt;hasNext()) {
  $nextPage = $firstPage-&gt;next();
  echo("Page 1 item 1: " . $nextPage-&gt;items[1]-&gt;data);
  echo("Last page?: " . $nextPage-&gt;isLast());
}</code></pre>
<pre lang="objc"><code lang="objc">[channel history:^(ARTPaginatedResult&lt;ARTMessage *&gt; *paginatedResult, ARTErrorInfo *error) {
    NSLog(@"Page 0 item 0: %@", paginatedResult.items[0].data);
    [paginatedResult next:^(ARTPaginatedResult&lt;ARTMessage *&gt; *nextPage, ARTErrorInfo *error) {
        NSLog(@"Page 1 item 1: %@", nextPage.items[1].data);
        NSLog(@"Last page?: %d", nextPage.isLast);
    }];
}];</code></pre>
<pre lang="swift"><code lang="swift">channel.history { paginatedResult, error in
    let paginatedResult = paginatedResult!
    print("Page 0 item 0: \((paginatedResult.items[0] as! ARTMessage).data)")
    paginatedResult.next { nextPage, error in
        let nextPage = nextPage!
        print("Page 0 item 0: \((nextPage.items[1] as! ARTMessage).data)")
        print("Last page? \(nextPage.isLast)")
    }
}</code></pre>
<h3 id="param"><span lang='java'>io.ably.lib.types.Param</span></h3>


<div lang="java"> <!-- start java language block -->
<p><code>Param</code> is a type encapsulating a key/value pair. This type is used frequently in method parameters allowing key/value pairs to be used more flexible, see <a href="/realtime/history#channel-history"><code>Channel#history</code></a> for an example.</p>
<p>Please note that <code>key</code> and <code>value</code> attributes are always strings. If an <code>Integer</code> or other value type is expected, then you must coerce that type into a <code>String</code>.</p>
<h4><span lang='java'>Members</span></h4>
<dl>
	<dt>key</dt>
	<dd>The key value<br><i>Type: <code>String</code></i></dd>
	<dt>value</dt>
	<dd>The value associated with the <code>key</code><br><i>Type: <code>String</code></i></dd>
</dl>

</div> <!-- /end java language block -->


    </article>
    <hr class="back">
    <a href="#documentation">Back to top</a>
  </div>
  <div id="sidebar">
  <a href="/" title="API Documentation Home"><img src="/images/ably-logo.png" class="ably-logo" title="API Documentation Home"></a>
  <ul>
<li class=''><a href='/quick-start-guide/'>Quickstart Guide</a></li>
<li class=''><a href='/how-ably-works/'>How Ably works</a></li>
</ul>
  <h2><a href="/realtime/">Realtime client lib</a></h2>
<ul>
<li class=''><a href='/realtime/usage/'>Using the Realtime library</a></li>
<li class=''><a href='/realtime/connection/'>Connection</a></li>
<li class=''><a href='/realtime/channels-messages/'>Channels and Messages</a></li>
<li class=''><a href='/realtime/presence/'>Presence</a></li>
<li class=''><a href='/realtime/authentication/'>Authentication</a></li>
<li class='selected'><a href='/realtime/history/'>History</a></li>
<li class=''><a href='/realtime/encryption/'>Encryption</a></li>
<li class=''><a href='/realtime/statistics/'>Statistics</a></li>
<li class=''><a href='/realtime/types/'>Types</a></li>
</ul>
  <h2><a href="/rest/">REST client lib</a></h2>
<ul>
<li class=''><a href='/rest/usage/'>Using the REST library</a></li>
<li class=''><a href='/rest/channels-messages/'>Channels and Messages</a></li>
<li class=''><a href='/rest/presence/'>Presence</a></li>
<li class=''><a href='/rest/authentication/'>Authentication</a></li>
<li class=''><a href='/rest/history/'>History</a></li>
<li class=''><a href='/rest/encryption/'>Encryption</a></li>
<li class=''><a href='/rest/statistics/'>Statistics</a></li>
<li class=''><a href='/rest/types/'>Types</a></li>
</ul>
  <h2><a href="/rest-api/">REST API</a></h2>
<ul>
</ul>
  <h2>General</h2>
<ul>
<li class=''><a href='/general/authentication/'>Authentication</a></li>
<li class=''><a href='/general/channel-rules-namespaces/'>Channel Rules and Namespaces</a></li>
<li class=''><a href='/general/push-notifications/'>Mobile push notifications</a></li>
<li class=''><a href='/general/webhooks/'>Receiving WebHooks</a></li>
<li class=''><a href='/general/statistics/'>Application Statistics</a></li>
</ul>
  <h2><a href="/client-lib-development-guide/">Library Development</a></h2>
<ul>
<li class=''><a href='/client-lib-development-guide/features/'>Features spec v0.8</a></li>
<li class=''><a href='/client-lib-development-guide/feature-prioritisation/'>Feature prioritisation</a></li>
<li class=''><a href='/client-lib-development-guide/protocol/'>Realtime Protocol Definition</a></li>
<li class=''><a href='/client-lib-development-guide/rest-api/'>REST API Definition</a></li>
<li class=''><a href='/client-lib-development-guide/test-api/'>Sandbox Test API</a></li>
<li class=''><a href='/client-lib-development-guide/encryption/'>Encryption</a></li>
<li class=''><a href='/client-lib-development-guide/websocket/'>WebSocket Transport</a></li>
<li class=''><a href='/client-lib-development-guide/comet/'>Comet Transport</a></li>
<li class=''><a href='/client-lib-development-guide/connection-recovery/'>Connection Recovery</a></li>
<li class=''><a href='/client-lib-development-guide/connection-manager/'>Connection Manager</a></li>
<li class=''><a href='/client-lib-development-guide/connection-fallback/'>Connection host fallback</a></li>
<li class=''><a href='/client-lib-development-guide/documentation-formatting-guide/'>Documentation Formatting Guide</a></li>
<li class=''><a href='/code-index/'>Code Examples List</a></li>
</ul>
  <ul>
<li><a href="https://www.ably.io">Visit Ably.io</a></li>
</ul>
</div>

</body>
</html>
