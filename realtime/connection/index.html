<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Ably API Documentation - Connection</title>
    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="stylesheet" type="text/css" href="/vendor/prettify/prettify.css" media="screen">
    <link rel="stylesheet" type="text/css" href="/stylesheet.css" media="screen">

    
      <link rel="canonical" href="https://www.ably.io/documentation/realtime/connection" />
    

    <script src="/vendor/javascripts/jquery-1-8-3-min.js" type="text/javascript"></script>
    <script src="/vendor/javascripts/jquery-cookie-1-3-1.js" type="text/javascript"></script>
    <script src="/vendor/javascripts/base64.js" type="text/javascript"></script>

    <script src="/vendor/prettify/prettify-lib.js" type="text/javascript"></script>

    <script src="//cdn.ably.io/lib/ably.min.js" type="text/javascript"></script>

    <script src="/javascripts/application.js" type="text/javascript"></script>
    <script src="/javascripts/lang-manager.js" type="text/javascript"></script>

    <script type="text/javascript">window.NavLangs=["javascript","nodejs","ruby","java","swift","objc"];</script>

    <!-- you don't need to keep this, but it's cool for stats! -->
    <meta name="generator" content="nanoc 3.7.5">
  </head>
  <body>
    <div class="canonical-notice">
      <img src="/images/icon-alert.png">
      <span class="canonical-notice-text">
        You are viewing our bleeding edge unstable documentation. We recommend you use our <a href="https://www.ably.io/documentation">stable documentation Â»</a>
      </span>
      <img src="/images/icon-alert.png">
    </div>
    <div class="fork-banner"><a href="https://github.com/ably/docs"><img src="/images/forkme.png" alt="Fork me on GitHub"></a></div>

  <div id="documentation">
    
      <nav class="jump-to-nav">
        <div class="form">
          <select id="jump-to-nav">
            <option>Jump to ...</option>
            <optgroup label='Help with'>
<option id="anchor-title">Getting started</option>
<option id="anchor-connection-state-explained">Connection state explained</option>
<option id="anchor-handling-failures">Handling failures</option>
<option id="anchor-connection-state-recovery">Connection state recovery</option>
</optgroup>
<optgroup label='Connection API properties'>
<option id="anchor-id">id</option>
<option id="anchor-key">key</option>
<option id="anchor-state">state</option>
<option id="anchor-error-reason">error</option>
<option id="anchor-recovery-key">recovery key</option>
<option id="anchor-serial">serial</option>
</optgroup>
<optgroup label='Connection API methods'>
<option id="anchor-connect">connect</option>
<option id="anchor-close">close</option>
<option id="anchor-on">on</option>
<option id="anchor-once">once</option>
<option id="anchor-off">off</option>
<option id="anchor-ping">ping</option>
</optgroup>
          </select>
        </div>
      </nav>
    
    <header>
      
        <div class="breadcrumb"><a href="/realtime/">Realtime Client Library API</a><span class="separator">/</span></div>
      
      
        <h1 id="title">Connection</h1>
      
    </header>
    <article>
      <p>The Ably Realtime library establishes and maintains a connection to the Ably service, using the most efficient transport available, typically WebSockets. The Ably realtime protocol operates and multiplexes all channel traffic over that connection.</p>
<h3 id="getting-started">Getting started</h3>
<p>The Ably Realtime library will open and maintain a connection to the Ably realtime servers as soon as it is instanced. The <code>Connection</code> object provides a straightforward API to monitor and manage connection state.</p>
<p>The following example relies on the default auto-connect behaviour of the library, and then subscribes to the connection&#8217;s <code>connected</code> event.</p>
<pre class="code-editor open-jsbin open-jsbin-aredoz" lang="javascript"><code class="code-editor open-jsbin open-jsbin-aredoz" lang="javascript">var ably = new Ably.Realtime('{{API_KEY}}');
ably.connection.on('connected', function() {
  alert('Connected, that was easy');
})</code></pre>
<pre class="code-editor open-jsbin open-jsbin-aredoz" lang="nodejs"><code class="code-editor open-jsbin open-jsbin-aredoz" lang="nodejs">var Ably = require('ably');
var ably = new Ably.Realtime('{{API_KEY}}');
ably.connection.on('connected', function() {
  alert('Connected, that was easy');
})</code></pre>
<pre lang="ruby"><code lang="ruby">ably = Ably::Realtime.new('{{API_KEY}}')
ably.connection.on(:connected) do |message|
  puts "Connected, that was easy"
end</code></pre>
<pre lang="java"><code lang="java">AblyRealtime ably = new AblyRealtime("{{API_KEY}}");
ably.connection.on('connected', new ConnectionStateListener() {
  @Override
  public void onConnectionStateChanged(ConnectionStateChange change) {
    System.out.println("Connected, that was easy");
  }
});</code></pre>
<pre lang="objc"><code lang="objc">ARTRealtime *ably = [[ARTRealtime alloc] initWithKey:@"{{API_KEY}}"];
[ably.connection on:ARTRealtimeConnected call:^(ARTConnectionStateChange *change) {
    NSLog(@"Connected, that was easy");
}];</code></pre>
<pre lang="swift"><code lang="swift">let realtime = ARTRealtime(key: "{{API_KEY}}")
realtime.connection.on(.Connected) { change in
    print("Connected, that was easy")
}</code></pre>
<h2 id="connection-state-explained">Connection state explained</h2>
<p>Although connection state is temporary, the Ably protocol provides continuity of message delivery between the client and the service, provided that a dropped connection is reestablished by the client within a limited interval (typically around 2 minutes). Beyond that, the connection becomes stale and the system will not attempt to recover the connection state. The lifecycle of a connection, and the strategy for reconnecting on failure, reflect the transient nature of the connection state.</p>
<p>The client library is responsible for managing the connection; this includes selecting a transport (in those environments supporting multiple transports), selecting a host to connect to (automatically falling back to an alternate data centre host if the closest data centre is unreachable), and managing continuity of operation when the connection drops.</p>
<p>When the library is instanced, if connectivity to the service is available, the library will establish a connection immediately, and if the connection drops at any time it will attempt to re-establish it by making repeated connection attempts every 15 seconds for up to two minutes.</p>
<p>If, after that time, there has been no connection, the library falls back to a lower level of activity, still periodically attempting reconnection at 30 second intervals. This reflects the assumption that there will no longer be recoverable connection state and the client may be offline for a period of time. As soon as a reconnection attempt has been successful, the system reverts to the more active connection behaviour. Further, you can explicitly trigger a reconnection attempt at any time if you wish to implement a different reconnection strategy.</p>
<p>The connection object provides methods to observe the lifecycle of the connection and to trigger state transitions.</p>
<h3 id="connection-states">Available connection states</h3>
<p>A series of connection states is defined as follows:</p>
<dl>
	<dt>initialized</dt>
	<dd>A <code>Connection</code> object having this state has been initialized but no connection has yet been attempted.</dd>
</dl>
<dl>
	<dt>connecting</dt>
	<dd>A connection attempt has been initiated. The connecting state is entered as soon as the library has completed initialization, and is reentered each time connection is re-attempted following disconnection.</dd>
</dl>
<dl>
	<dt>connected</dt>
	<dd>A connection exists and is active.</dd>
</dl>
<dl>
	<dt>disconnected</dt>
	<dd>A temporary failure condition. No current connection exists because there is no network connectivity or no host is available.<br><br>The disconnected state is entered if an established connection is dropped, or if a connection attempt was unsuccessful. In the disconnected state the library will periodically attempt to open a new connection (approximately every 15 seconds), anticipating that the connection will be re-established soon and thus connection and channel continuity will be possible. <br><br>In this state, developers can continue to publish messages as they are automatically placed in a local queue, and sent as soon as a connection is established. <br>Messages published by other clients to the Ably service, whilst this client is disconnected, are queued and delivered to this client upon reconnection, so long as the connection is resumed within 2 minutes. <br><br>If connection state recovery is not possible following a new connection being established, all channels are detached, thus ensuring the developer is made aware that continuity on the channel was not possible. The developer is then responsible for re-attaching channels and recovering state, if required, using the <a href="/realtime/history">history API</a>.</dd>
</dl>
<dl>
	<dt>suspended</dt>
	<dd>A long term failure condition. No current connection exists because there is no network connectivity or no host is available.<br><br>The suspended state is entered after a failed connection attempt if there has then been no connection for a period of two minutes. In the suspended state, the library will periodically attempt to open a new connection every 30 seconds. Developers are unable to publish messages in this state. A new connection attempt can also be triggered by an explicit call to <span lang="default"><a href="#connect"><code>connect()</code></a></span><span lang="ruby"><a href="#connect"><code>connect</code></a></span> on the <code>Connection</code> object.</dd>
</dl>
<dl>
	<dt>closing</dt>
	<dd>An explicit request by the developer to close the connection has been sent to the Ably service. If a reply is not received from Ably within a short period of time, the connection will be forcibly terminated and the connection state will become <code>closed</code>.</dd>
</dl>
<dl>
	<dt>closed</dt>
	<dd>The connection has been explicitly closed by the client.<br><br>In the closed state, no reconnection attempts are made automatically by the library, and clients may not publish messages. No connection state is preserved by the service or by the library. A new connection attempt can be triggered by an explicit call to <span lang="default"><a href="#connect"><code>connect()</code></a></span><span lang="ruby"><a href="#connect"><code>connect</code></a></span> on the <code>Connection</code> object, which will result in a new connection.</dd>
</dl>
<dl>
	<dt>failed</dt>
	<dd>An indefinite failure condition. This state is entered if a connection error has been received from the Ably service (such as an attempt to connect with invalid credentials). A failed state may also be triggered by the client library directly as a result of some local permanent error.<br><br>In the failed state, no reconnection attempts are made automatically by the library, and clients may not publish messages. A new connection attempt can be triggered by an explicit call to <span lang="default"><a href="#connect"><code>connect()</code></a></span><span lang="ruby"><a href="#connect"><code>connect</code></a></span> on the <code>Connection</code> object.</dd>
</dl>
<h4>Typical connection state sequences</h4>
<p>The library is initialized and initiates a successful connection.</p>
<blockquote>
<p>initialized &rarr; connecting &rarr; connected</p>
</blockquote>
<p>An existing connection is dropped and reestablished on the first attempt.</p>
<blockquote>
<p>connected &rarr; disconnected &rarr; connecting &rarr; connected</p>
</blockquote>
<p>An existing connection is dropped, and reestablished after several attempts but within a two minute interval.</p>
<blockquote>
<p>connected &rarr; disconnected &rarr; connecting &rarr; disconnected &rarr; &hellip; &rarr; connecting &rarr; connected</p>
</blockquote>
<p>There is no connection established after initializing the library.</p>
<blockquote>
<p>initialized &rarr; connecting &rarr; disconnected &rarr; connecting &rarr; &hellip; &rarr; suspended</p>
</blockquote>
<p>After a period of being offline a connection is reestablished.</p>
<blockquote>
<p>suspended &rarr; connecting &rarr; suspended &rarr; &hellip; &rarr; connecting &rarr; connected</p>
</blockquote>
<h4>Listening for state changes</h4>
<p>The <code>Connection</code> object is an <code>EventEmitter</code> and emits an event whose name is the new state whenever there is a connection state change. <span lang="default">An event listener function is passed a <a href="#connection-state-change">ConnectionStateChange</a> object as the first argument for state change events.</span><span lang="ruby">The event block is passed the new state and an optional <a href="/realtime/types#error-info"><code>ErrorInfo</code></a> object</span></p>


<div lang="javascript,nodejs"> <!-- start javascript,nodejs language block -->
<pre lang="javascript"><code lang="javascript">realtime.connection.on('connected', function(stateChange) {
  console.log('Ably is connected');
});</code></pre>
<pre lang="nodejs"><code lang="nodejs">realtime.connection.on('connected', function(stateChange) {
  console.log('Ably is connected');
});</code></pre>
<p>Alternatively a listener may be registered so that it receives all state change events.</p>
<pre lang="javascript"><code lang="javascript">realtime.connection.on(function(stateChange) {
  console.log('New connection state is ' + stateChange.current);
});</code></pre>
<pre lang="nodejs"><code lang="nodejs">realtime.connection.on(function(stateChange) {
  console.log('New connection state is ' + stateChange.current);
});</code></pre>
<p>Previously registered listeners can be removed individually or all together.</p>
<pre lang="javascript"><code lang="javascript">/* remove a listener registered for a single event */
realtime.connection.off('connected', myListener);

/* remove a listener registered for all events */
realtime.connection.off(myListener);

/* remove all event listeners */
realtime.connection.off();</code></pre>
<pre lang="nodejs"><code lang="nodejs">/* remove a listener registered for a single event */
realtime.connection.off('connected', myListener);

/* remove a listener registered for all events */
realtime.connection.off(myListener);

/* remove all event listeners */
realtime.connection.off();</code></pre>

</div> <!-- /end javascript,nodejs language block -->



<div lang="java"> <!-- start java language block -->
<pre lang="java"><code lang="java">realtime.connection.on('connected', new ConnectionStateListener() {
  @Override
  public void onConnectionStateChanged(ConnectionStateChange change) {
    System.out.println("New state is connected");
  }
});</code></pre>
<p>Alternatively a listener may be registered so that it receives all state change events.</p>
<pre lang="java"><code lang="java">realtime.connection.on(new ConnectionStateListener() {
  @Override
  public void onConnectionStateChanged(ConnectionStateChange change) {
    System.out.println("New state is " + change.current.name());
  }
});</code></pre>
<p>Previously registered listeners can be removed individually or all together.</p>
<pre lang="java"><code lang="java">/* remove a single listener */
realtime.connection.off(myListener);

/* remove all event listeners */
realtime.connection.off();</code></pre>

</div> <!-- /end java language block -->



<div lang="ruby"> <!-- start ruby language block -->
<pre lang="ruby"><code lang="ruby">realtime.connection.on(:connected) do
  puts 'Ably is connected'
end</code></pre>
<p>Alternatively a listener may be registered so that it receives all state change events.</p>
<pre lang="ruby"><code lang="ruby">realtime.connection.on do |state_change|
  puts "New connection state is #{state_change.current}"
end</code></pre>
<p>Previously registered listeners can be removed individually or all together.</p>
<pre lang="ruby"><code lang="ruby"># remove a listener registered for a single even
realtime.connection.off :connected, &amp;block

# remove a listener registered for all events
realtime.connection.off &amp;block

# remove all event listeners
realtime.connection.off</code></pre>

</div> <!-- /end ruby language block -->



<div lang="objc"> <!-- start objc language block -->
<pre lang="objc"><code lang="objc">ARTEventListener *listener = [realtime.connection on:ARTRealtimeConnected call:^(ARTConnectionStateChange *change) {
    NSLog(@"Ably is connected");
}];</code></pre>
<p>Alternatively a listener may be registered so that it receives all state change events.</p>
<pre lang="objc"><code lang="objc">ARTEventListener *listener = [realtime.connection on:^(ARTConnectionStateChange *change) {
    NSLog(@"New connection state is %lu", (unsigned long)change.current);
}];</code></pre>
<p>Previously registered listeners can be removed individually or all together.</p>
<pre lang="objc"><code lang="objc">// remove a listener registered for a single event
[realtime.connection off:ARTRealtimeConnected listener:listener];

// remove a listener registered for all events
[realtime.connection off:listener];

// remove all event listeners
[realtime.connection off];</code></pre>

</div> <!-- /end objc language block -->



<div lang="swift"> <!-- start swift language block -->
<pre lang="swift"><code lang="swift">let listener = realtime.connection.on(.Connected) { change in
    print("Ably is connected")
}</code></pre>
<p>Alternatively a listener may be registered so that it receives all state change events.</p>
<pre lang="swift"><code lang="swift">let listener = realtime.connection.on { change in
    print("New connection state is \(change!.current)")
}</code></pre>
<p>Previously registered listeners can be removed individually or all together.</p>
<pre lang="swift"><code lang="swift">// remove a listener registered for a single event
realtime.connection.off(.Connected, listener: listener)

// remove a listener registered for all events
realtime.connection.off(listener)

// remove all event listeners
realtime.connection.off()</code></pre>

</div> <!-- /end swift language block -->

<h3 id="handling-failures">Handling failures</h3>
<p>We recommend that you always handle both connection and channel failures explicitly. For example, a connection can move to the <code>FAILED</code> state if the token cannot be renewed successfully, or a channel can move to the <code>DETACHED</code> state if there is a loss of continuity on the channel. If you subscribe to these failure states that are not automatically recovered, you can perform your own recovery based on your specific application requirements. The failure states you need to consider are:</p>
<ul>
	<li><a href="/realtime/types#connection-state"><code>ConnectionState#failed</code></a></li>
	<li><a href="/realtime/types#channel-state"><code>ChannelState#detached</code></a></li>
	<li><a href="/realtime/types#channel-state"><code>ChannelState#failed</code></a></li>
</ul>
<h4>State change side effects on channels</h4>
<p>Once a channel becomes attached, it will remain attached until any of the following occurs:</p>
<ul>
	<li>An explicit request to detach the channel is made;</li>
	<li>The channel moves into the <code>failed</code> state following an unrecoverable error sent from Ably. If for example permissions were revoked for that client on that channel, the channel would move to the <code>failed</code> state;</li>
	<li>The connection enters the <code>suspended</code>, <code>failed</code> or <code>closed</code> state;</li>
	<li>The connection is not resumed fully as part of the <a href="#connection-state-recovery">connection state recovery process</a></li>
</ul>
<p>Ably provides automatic message continuity for channels, even when connections are disconnected and later resumed. See <a href="/realtime/connection#connection-state-recovery">connection state recovery</a> for more details on how connections and channel state recovery allows you, as a developer, to publish and receive messages without having to worry about changing network conditions. However, there are times when connection recovery is not possible such as being disconnected from Ably for more than two minutes.  When this occurs, the channels that are attached can no longer provide guaranteed message continuity. We wanted developers to be aware of this discontinuity, and as such, our client libraries will automatically detach all attached channels that have lost continuity. It is then up to the developer to decide what action to take such as using the <a href="/realtime/history">history API</a> to retrieve old messages, or simply to reattach the channel and continue if messsage loss is not important.</p>
<p>For customers who want to ensure that all channels are attached when a connection is available, regardless of whether messages may have been missed, we recommend the following approach:</p>
<ul>
	<li>Add a listener on the connection object for all <code>connected</code> events</li>
	<li>Reattach all channels you have created. If a channel is already attached, and you call the <a href="/realtime/channels-messages/#attach"><code>channel#attach</code></a> method, the channel will simply remain attached. It is therefore safe to simply attach all channels every time the connection becomes <code>connected</code></li>
</ul>
<p>The following Javascript example demonstrates a trivial way to ensure all channels are attached when the client becomes connected or the channel becomes detached:</p>
<pre lang="javascript"><code lang="javascript">function reattach(channel) {
  channel.attach();
  /* Example when using presence on the channel */
  channel.presence.enter();
}

/* Connection state changes can trigger channels to become detached
   Automatically re-attach channels, nothing will happen if alreay attached */
client.connection.on('connected', function() {
  for (let channelName in client.channels.all) {
    let channel = client.channels.get(channelName);
    reattach(channel);
  }
});

/* If a channel becomes detached due to channel failure (some edge cases exist)
   You should explicitly re-attach the channel if you are connected */
channel.on('detached', function() {
  if (client.connection.state === 'connected') {
    reattach(channel);
  }
});</code></pre>
<h3 id="connection-state-recovery">Connection state recovery</h3>
<p>The Ably system preserves connection state to allow connections to continue transparently across brief disconnections. The connection state that is tracked includes the messages sent to the client on the connection, members present on a channel and the set of channels that the client is attached to.</p>
<p>There are two modes of connection state recovery:</p>
<ul>
	<li><code>resume</code>: this is transparent recovery of a live client instance across disconnections. Upon disconnection, the library will automatically re-attempt connection and, once the connection is re-established, any missed messages will be sent to the client. The developer does not need to do anything to trigger this behaviour; all client channel event listeners remain attached and are called when the backlog of messages is received.</li>
</ul>
<ul>
	<li><code>recover</code>: this addresses the case in which a new client library instance wishes to connect and recover the state of an earlier connection. This occurs typically in a browser environment when the page has been refreshed and therefore the client instance is disposed and no client state is retained. In this case any message listeners associated with channels will no longer exist so it is not possible for the library simply to send the message backlog on reconnection; instead the client must re-subscribe to each channel it is interested in within 15 seconds, and its message listener(s) will be called with any message backlog for that channel. If the previously attached channels are not re-attached within 15 seconds of a connection being recovered, the channels will automatically be detached by Ably. A client requests recovery of connection state by including a recovery string in the <a href="/realtime/usage#client-options">client options</a> when instancing the Realtime library. See <a href="#connection-state-recover-options">connection state recover options</a> for more info.</li>
</ul>
<p>In either case, when a connection is resumed or recovered, the message backlog held on the server will be pushed to the client. However, any new messages published will be sent as they become available or messages could be indefinitely deferred on very heavily loaded connections. Therefore the system does not guarantee that messages received after reconnection are delivered in the same order that would have occurred if the connection had not been dropped. In the <code>recover</code> case, in particular, the order of the message delivery depends on the timing of the re-attachment of each channel.</p>
<h4 id="connection-state-recover-options">Connection state recover options</h4>
<p>In <code>recover</code> mode it is necessary to request recovery mode in the <a href="/realtime/usage#client-options">client options</a> when instancing the library. Recovery requires that the library knows the previous connection&#8217;s <span lang="default"><a href="#recovery-key"><code>recoveryKey</code></a></span><span lang="ruby"><a href="#recovery-key"><code>recovery_key</code></a></span> value (which includes both the private unique <a href="#key"><code>Connection#key</code></a> and the last message serial received on that connection). As the recovery key is never shared with any other clients, it allows Ably to safely resend message backlogs to the original client.</p>


<div lang="javascript"> <!-- start javascript language block -->
<p>In the browser environment, if a callback is provided in the <code>recover</code> option, when <code>window beforeunload</code> event fires, the connection details, including the <a href="#recovery-key"><code>recoveryKey</code></a>, are stored in the <a href="https://www.w3.org/TR/webstorage/">browser&#8217;s sessionStorage</a>. The provided <code>recover</code> callback is then invoked whenever the connection state can be recovered and just before a connection is established, passing in the <a href="#last-connection-details"><code>LastConnectionDetails</code></a>. The callback is then responsible for confirming whether the connection state should be recovered or not. For example, it is common to recover connection state when the page is reloaded but not for different pages the user has navigated to. The callback allows the developer to decide if the connection should be recovered or not at the time the new connection is established by inspecting the <a href="#last-connection-details"><code>LastConnectionDetails</code></a> and evaluating that against any other application state. Below is a straightforward example:</p>
<pre lang="javascript"><code lang="javascript">var ably = new Ably.Realtime({
  authUrl: '/obtainToken',
  recover: function(lastConnectionDetails, cb) {
    if (lastConnectionDetails.location.href === document.location.href) {
      cb(true); /* recover connection as user has reloaded page */
    } else {
      cb(false); /* do not recover connection as URL has changed */
    }
  }
});</code></pre>
<pre lang="nodejs"><code lang="nodejs">var ably = new Ably.Realtime({
  authUrl: '/obtainToken',
  recover: function(lastConnectionDetails, cb) {
    if (lastConnectionDetails.location.href === document.location.href) {
      cb(true); /* recover connection as user has reloaded page */
    } else {
      cb(false); /* do not recover connection as URL has changed */
    }
  }
});</code></pre>
<p>Please note that as <a href="https://www.w3.org/TR/webstorage/"><code>sessionStorage</code></a> is used to persist the <code>LastConnectionDetails</code> between page reloads, it is only available for pages in the same origin and top-level browsing context.</p>
<p>Alternatively, if it is necessary to be explicit about the connection <code>recoveryKey</code> , the connection can be recovered by providing the last value of the connection&#8217;s <code>recoveryKey</code> value in the <a href="/realtime/usage#client-options">client options</a> <code>recover</code> attribute when instancing the library.</p>

</div> <!-- /end javascript language block -->

<h4>Connection recovery constraints</h4>
<p>Connection recovery requires that the new client library instance uses credentials that are compatible with those used for the inherited connection; this requires that the same authentication mode is used, with the same key. If token auth was used, the same token is not required, but the token used must have the same <code>capability</code> and <span lang="default"><code>clientId</code></span><span lang="ruby"><code>client_id</code></span>. This ensures that the client recovering the connection cannot receive a backlog of messages that its new credentials are not entitled to access. Incompatible credentials will result in an unrecoverable connection error.</p>
<h1>Connection API reference</h1>
<div class="inline-toc">
<ul><li>Connection API reference
<ul>
<li>
Methods
<ul>
<li><a href='#connect'>connect()</a></li>
<li><a href='#close'>close()</a></li>
<li><a href='#on-state-listener'>on(state, listener)</a></li>
<li><a href='#on-listener'>on(listener)</a></li>
<li><a href='#once-state-listener'>once(state, listener)</a></li>
<li><a href='#once-listener'>once(listener)</a></li>
<li><a href='#off-state-listener'>off(state, listener)</a></li>
<li><a href='#off-listener'>off(listener)</a></li>
<li><a href='#ping'>ping()</a></li>
</ul>
</li>
<li>
Properties
<ul>
<li><a href='#id'>id</a></li>
<li><a href='#state'>state</a></li>
<li><a href='#error-reason'>errorReason</a></li>
<li><a href='#key'>key</a></li>
<li><a href='#recover-key'>recoveryKey</a></li>
<li><a href='#serial'>serial</a></li>
</ul>
</li>
<li>
Related types
<ul>
<li><a href='#completion-listener'>CompletionListener</a></li>
<li><a href='#connection-state'>ConnectionState</a></li>
<li><a href='#connection-state-listener'>ConnectionStateListener</a></li>
<li><a href='#connection-state-change'>ConnectionStateChange</a></li>
<li><a href='#last-connection-details'>LastConnectionDetails</a></li>
</ul>
</li>
</ul>
</li></ul>
</div><h2 id="properties"><span lang='default'>Connection Properties</span><span lang='swift,objct'>ARTConnection Properties</span><span lang='ruby'>Ably::Realtime::Connection Attributes</span><span lang='java'>io.ably.lib.realtime.Connection Members</span></h2>
<p>The <code>Connection</code> object exposes the following public <span lang="default">properties</span><span lang="ruby">attributes</span><span lang="java">members</span>:</p>
<h6 id="id">id</h6>
<p>A unique public identifier <code>String</code> for this connection, used to identify this member in presence events and messages.</p>
<h6 id="state">state</h6>
<p>The current <span lang="java"><a href="#connection-state"><code>io.ably.lib.realtime.ConnectionState</code></a> <code>state</code></span><span lang="ruby"><a href="#connection-state"><code>Ably::Realtime::Connection::STATE</code></a> <code>state</code></span><span lang="objc,swift"><a href="#connection-state"><code>ARTRealtimeConnectionState</code></a> <code>state</code></span><span lang="default"><code>state String</code></span> of this Connection. See the <a href="#connection-states"><code>Connection</code> states</a> for more information.</p>
<h6 id="error-reason"><span lang='default'>errorReason</span><span lang='java'>reason</span><span lang='ruby'>error_reason</span></h6>
<p>When a connection failure occurs this <span lang="default,ruby">attribute</span><span lang="java">member</span><span lang="javascript,nodejs">property</span> contains the <span lang="javascript,nodejs"><a href="/realtime/types#error-info"><code>ErrorInfo</code></a></span><span lang="java,ruby"><a href="/realtime/types#ably-exception"><code>AblyException</code></a></span>.</p>
<h6 id="key">key</h6>
<p>A unique private connection key <code>String</code> used to recover or resume a connection, assigned by Ably. When recovering a connection explicitly, the <span lang="default"><code>recoveryKey</code></span><span lang="ruby"><code>recovery_key</code></span> is used in the <code>recover</code> <a href="/realtime/usage#client-options">client options</a> as it contains both the <code>key</code> and the last message <code>serial</code>.</p>
<h6 id="recovery-key"><span lang='default'>recoveryKey</span><span lang='ruby'>recovery_key</span></h6>
<p>The recovery key <code>String</code> can be used by another client to recover this connection&#8217;s state in the <code>recover</code> <a href="/realtime/usage#client-options">client options</a> <span lang="default">property</span><span lang="java">member</span><span lang="ruby">attribute</span>. See <a href="#connection-state-recover-options">connection state recover options</a> for more information.</p>
<h6 id="serial">serial</h6>
<p>The serial number <code>Integer</code> of the last message to be received on this connection, used automatically by the library when recovering or resuming a connection. When recovering a connection explicitly, the <span lang="default"><code>recoveryKey</code></span><span lang="ruby"><code>recovery_key</code></span> is used in the <code>recover</code> <a href="/realtime/usage#client-options">client options</a> as it contains both the <code>key</code> and the last message <code>serial</code>.</p>
<h2 id="methods"><span lang='default'>Connection Methods</span><span lang='swift,objc'>ARTConnection Methods</span><span lang='ruby'>Ably::Realtime::Connection Methods</span><span lang='java'>io.ably.lib.realtime.Connection Methods</span></h2>
<h6 id="connect">connect</h6>
<blockquote class="definition">
<p class="definition"><span lang='default'>connect()</span><span lang='ruby'><a href="/realtime/types#deferrable">Deferrable</a> connect &#8594; yields <a href="/realtime/connection"><code>Connection</code></a></span><span lang='java'>public void connect()</span></p>
</blockquote>
<p>Explicitly calling <code>connect</code> is unnecessary unless the <a href="#client-options"><code>ClientOptions</code></a> <span lang="default"><code>autoConnect</code></span><span lang="ruby"><code>auto_connect</code></span> is disabled. Unless already <code>connected</code> or <code>connecting</code>, this method causes the connection to open, entering the <code>connecting</code> state.</p>


<div lang="ruby"> <!-- start ruby language block -->
<h4>Returns</h4>
<p>A <a href="/realtime/types#deferrable"><code>Deferrable</code></a> object is returned from this method.</p>
<p>On successfully connecting to Ably, the registered success blocks for the <a href="/realtime/types#deferrable"><code>Deferrable</code></a> and any block provided to this method yields a <a href="/realtime/connection"><code>Connection</code></a> object.</p>
<p>Failure to connect will trigger the errback callbacks of the <a href="/realtime/types#deferrable"><code>Deferrable</code></a> with an <a href="#error-info"><code>ErrorInfo</code></a> object containing an error response as defined in the <a href="/rest-api#common">Ably REST API</a> documentation.</p>

</div> <!-- /end ruby language block -->

<h6 id="close">close</h6>
<blockquote class="definition">
<p class="definition"><span lang='default'>close()</span><span lang='ruby'><a href="/realtime/types#deferrable">Deferrable</a> close &#8594; yields <a href="/realtime/connection"><code>Connection</code></a></span><span lang='java'>public void close()</span></p>
</blockquote>
<p>Causes the connection to close, entering the <code>closing</code> state. Once <code>closed</code>, the library will not attempt to re-establish the connection without an explicit call to <span lang="default"><a href="#connect"><code>connect()</code></a></span><span lang="ruby"><a href="#connect"><code>connect</code></a></span>.</p>


<div lang="ruby"> <!-- start ruby language block -->
<h4>Returns</h4>
<p>A <a href="/realtime/types#deferrable"><code>Deferrable</code></a> object is returned from this method.</p>
<p>On successfully closing the connection, the registered success blocks for the <a href="/realtime/types#deferrable"><code>Deferrable</code></a> and any block provided to this method yields a <a href="/realtime/connection"><code>Connection</code></a> object.</p>
<p>Failure to close the connection will trigger the errback callbacks of the <a href="/realtime/types#deferrable"><code>Deferrable</code></a> with an <a href="#error-info"><code>ErrorInfo</code></a> object containing an error response as defined in the <a href="/rest-api#common">Ably REST API</a> documentation.</p>

</div> <!-- /end ruby language block -->

<h6 id="on">on</h6>
<p>There are two overloaded versions of this method:</p>
<blockquote class="definition" id="on-state-listener">
<p class="definition" id="on-state-listener"><span lang='default'>on(String state, listener(<a href="#connection-state-change">ConnectionStateChange</a> stateChange))</span><span lang='ruby'>on(<a href="#connection-state">ConnectionState</a> *state) &#8594; yields <a href="#connection-state-change">ConnectionStateChange</a></span><span lang='java'>public void on(<a href="#connection-state">ConnectionState</a> state, <a href="#connection-state-listener">ConnectionStateListener</a> listener)</span><span lang='objc,swift'>on(event: <a href="#connection-state">ARTRealtimeConnectionState</a>, call: (<a href="#connection-state-change">ARTConnectionStateChange</a>?) &#8594; Void) &#8594; ARTEventListener</span></p>
</blockquote>
<p>Register the given listener <span lang="ruby">block</span><span lang="swift,objc">function</span> for the specified <a href="#connection-state">ConnectionState</a> <span lang="default"><code>state</code></span><span lang="ruby"><code>state(s)</code></span><span lang="java"><code>state</code></span> changes on the <code>Connection</code>. The listener is passed a <a href="#connection-state-change">ConnectionStateChange</a> object that contains the current state, previous state, and an optional reason for the state change.</span></p>
<blockquote class="definition" id="on-listener">
<p class="definition" id="on-listener"><span lang='default'>on(listener(<a href="#connection-state-change">ConnectionStateChange</a> stateChange))</span><span lang='ruby'>on &#8594; yields <a href="#connection-state-change">ConnectionStateChange</a></span><span lang='java'>public void on(<a href="#connection-state-listener">ConnectionStateListener</a> listener)</span><span lang='objc,swift'>on(call: (<a href="#connection-state-change">ARTConnectionStateChange</a>?) &#8594; Void) &#8594; ARTEventListener</span></p>
</blockquote>
<p>Register the given listener <span lang="ruby">block</span><span lang="swift,objc">function</span> for all <a href="#connection-state">ConnectionState</a> changes on the <code>Connection</code>. The listener is passed a <a href="#connection-state-change">ConnectionStateChange</a> object that contains the current state, previous state, and an optional reason for the state change.</span></p>
<h4>Parameters</h4>
<dl>
	<dt><div lang="javascript,nodejs">state</div></dt>
	<dd>the connection state to subscribe to<br><i>Type: <code>String</code></i></dd>
	<dt><div lang="java">state</div></dt>
	<dd>the connection state to subscribe to<br><i>Type: <a href="#connection-state"><code>ConnectionState</code></a></i></dd>
	<dt><div lang="ruby">state</div></dt>
	<dd>the connection state as a Symbol such as <code>:connected</code> or <code>ConnectionState</code> object to subscribe to<br><i>Type: <a href="#connection-state"><code>ConnectionState</code></a></i></dd>
	<dt><div lang="swift,objc">state</div></dt>
	<dd>the connection state to subscribe to<br><i>Type: <a href="#connection-state"><code>ARTRealtimeConnectionState</code></a></i></dd>
</dl>
<dl>
	<dt><div lang="javascript,nodejs">listener</div></dt>
	<dd>is a function of the form <code>function(stateChange)</code> to be notified for matching state changes</dd>
	<dt><div lang="java">listener</div></dt>
	<dd>listener to be notified for matching state changes<br><i>Type: <a href="#connection-state-listener"><code>ConnectionStateListener</code></a></i></dd>
	<dt><div lang="ruby">&amp;block</div></dt>
	<dd>listener block that is yielded to for matching state changes</dd>
	<dt><div lang="swift,objc">call</div></dt>
	<dd>called with matching state changes</dd>
</dl>
<h4>Example</h4>
<p><a href="https://jsbin.ably.io:443/usuxex/1/edit?javascript,live" target="_blank">Browser <code>ConnectionState</code> change example</a></p>
<h6 id="once">once</h6>
<p>There are two overloaded versions of this method:</p>
<blockquote class="definition" id="once-state-listener">
<p class="definition" id="once-state-listener"><span lang='default'>once(String state, listener(<a href="#connection-state-change">ConnectionStateChange</a> stateChange))</span><span lang='ruby'>once(<a href="#connection-state">ConnectionState</a> *state) &#8594; yields <a href="#connection-state-change">ConnectionStateChange</a></span><span lang='java'>public void once(<a href="#connection-state">ConnectionState</a> state, <a href="#connection-state-listener">ConnectionStateListener</a> listener)</span><span lang='objc,swift'>once(event: <a href="#connection-state">ARTRealtimeConnectionState</a>, call: (<a href="#connection-state-change">ARTConnectionStateChange</a>?) &#8594; Void) &#8594; ARTEventListener</span></p>
</blockquote>
<p>Register the given listener <span lang="ruby">block</span><span lang="swift,objc">function</span> for a single occurence of the specified <a href="#connection-state">ConnectionState</a> <span lang="default"><code>state</code></span><span lang="ruby"><code>state(s)</code></span><span lang="java"><code>state</code></span> change on the <code>Connection</code>. Once the listener has been called, it is removed as a registered listener and will not be called again. The listener is passed a <a href="#connection-state-change">ConnectionStateChange</a> object that contains the current state, previous state, and an optional reason for the state change.</p>
<blockquote class="definition" id="once-listener">
<p class="definition" id="once-listener"><span lang='default'>once(listener(<a href="#connection-state-change">ConnectionStateChange</a> stateChange))</span><span lang='ruby'>once &#8594; yields <a href="#connection-state-change">ConnectionStateChange</a></span><span lang='java'>public void once(<a href="#connection-state-listener">ConnectionStateListener</a> listener)</span><span lang='objc,swift'>once(call: (<a href="#connection-state-change">ARTConnectionStateChange</a>?) &#8594; Void) &#8594; ARTEventListener</span></p>
</blockquote>
<p>Register the given listener <span lang="ruby">block</span> for a single occurence of any <a href="#connection-state">ConnectionState</a> change on the <code>Connection</code>. Once the listener has been called, it is removed as a registered listener and will not be called again. The listener is passed a <a href="#connection-state-change">ConnectionStateChange</a> object that contains the current state, previous state, and an optional reason for the state change.</p>
<h4>Parameters</h4>
<dl>
	<dt><div lang="javascript,nodejs">state</div></dt>
	<dd>the connection state to subscribe to<br><i>Type: <code>String</code></i></dd>
	<dt><div lang="java">state</div></dt>
	<dd>the connection state to subscribe to<br><i>Type: <a href="#connection-state"><code>ConnectionState</code></a></i></dd>
	<dt><div lang="ruby">state</div></dt>
	<dd>the connection state as a Symbol such as <code>:connected</code> or <code>ConnectionState</code> object to subscribe to<br><i>Type: <a href="#connection-state"><code>ConnectionState</code></a></i></dd>
	<dt><div lang="swift,objc">state</div></dt>
	<dd>the connection state to subscribe to<br><i>Type: <a href="#connection-state"><code>ARTRealtimeConnectionState</code></a></i></dd>
</dl>
<dl>
	<dt><div lang="javascript,nodejs">listener</div></dt>
	<dd>is a function of the form <code>function(stateChange)</code> to be notified for a single occurence of a matching state change</dd>
	<dt><div lang="java">listener</div></dt>
	<dd>listener to be notified for a single occurence of a matching state change<br><i>Type: <a href="#connection-state-listener"><code>ConnectionStateListener</code></a></i></dd>
	<dt><div lang="ruby">&amp;block</div></dt>
	<dd>listener block that is yielded to for a single occurence of a matching state change</dd>
	<dt><div lang="swift,objc">call</div></dt>
	<dd>called with matching state changes</dd>
</dl>
<h6 id="off">off</h6>
<p>There are two overloaded versions of this method:</p>
<blockquote class="definition" id="off-state-listener">
<p class="definition" id="off-state-listener"><span lang='default'>off(String state, listener)</span><span lang='ruby'>off(<a href="#connection-state">ConnectionState</a> *state, &amp;block)</span><span lang='java'>public void off(<a href="#connection-state">ConnectionState</a> state, <a href="#connection-state-listener">ConnectionStateListener</a> listener)</span><span lang='objc,swift'>off(event: <a href="#connection-state">ARTRealtimeConnectionState</a>, listener: ARTEventListener)</span></p>
</blockquote>
<p>Remove the given listener <span lang="ruby">block</span> for the <a href="#connection-state">ConnectionState</a> <span lang="default"><code>state</code></span><span lang="ruby"><code>state(s)</code></span><span lang="java"><code>state</code></span>.</p>
<blockquote class="definition" id="off-listener">
<p class="definition" id="off-listener"><span lang='default'>off(listener)</span><span lang='ruby'>off(&amp;block)</span><span lang='java'>public void off(<a href="#connection-state-listener">ConnectionStateListener</a> listener)</span><span lang='objc,swift'>off(listener: ARTEventListener)</span></p>
</blockquote>
<p>Remove the given listener <span lang="ruby">block</span> for all <a href="#connection-state">ConnectionState</a> states.</p>
<h4>Parameters</h4>
<dl>
	<dt><div lang="javascript,nodejs">state</div></dt>
	<dd>the connection state to unsubscribe from<br><i>Type: <code>String</code></i></dd>
	<dt><div lang="java">state</div></dt>
	<dd>the connection state to unsubscribe from<br><i>Type: <a href="#connection-state"><code>ConnectionState</code></a></i></dd>
	<dt><div lang="ruby">state</div></dt>
	<dd>the connection state as a Symbol such as <code>:connected</code> or <code>ConnectionState</code> object to unsubscribe from<br><i>Type: <a href="#connection-state"><code>ConnectionState</code></a></i></dd>
	<dt><div lang="swift,objc">event</div></dt>
	<dd>the connection state to unsubscribe from<br><i>Type: <a href="#connection-state"><code>ARTRealtimeConnectionState</code></a></i></dd>
</dl>
<dl>
	<dt><div lang="javascript,nodejs">listener</div></dt>
	<dd>is the listener function to be removed</dd>
	<dt><div lang="java">listener</div></dt>
	<dd>is the listener to be removed<br><i>Type: <a href="#connection-state-listener"><code>ConnectionStateListener</code></a></i></dd>
	<dt><div lang="ruby">&amp;block</div></dt>
	<dd>is the listener block to be removed</dd>
	<dt><div lang="swift,objc">listener</div></dt>
	<dd>previous return value from a <code>on</code> or <code>once</code> call</dd>
</dl>
<h6 id="ping">ping</h6>
<blockquote class="definition">
<p class="definition"><span lang='default'>ping(callback(<a href="/realtime/types#error-info">ErrorInfo</a> err))</span><span lang='ruby'><a href="/realtime/types#deferrable">Deferrable</a> ping &#8594; yields <code>Float seconds</code></span><span lang='java'>public void ping(<a href="#completion-listener">CompletionListener</a> listener)</span><span lang='objc,swift'>ping(callback: (ARTErrorInfo?) &#8594; Void)</span></p>
</blockquote>
<p>When connected, sends a heartbeat ping to the Ably server and <span lang="default">executes the callback</span><span lang="java">calls the listener</span><span lang="ruby">yields the elapsed time in seconds</span> when a heartbeat ping request is echoed from the server. This can be useful for measuring true roundtrip latency to the connected Ably server.</p>


<div lang="ruby"> <!-- start ruby language block -->
<h4>Returns</h4>
<p>A <a href="/realtime/types#deferrable"><code>Deferrable</code></a> object is returned from this method.</p>
<p>On successfully echoing a heartbeat from Ably, the registered success blocks for the <a href="/realtime/types#deferrable"><code>Deferrable</code></a> and any block provided to this method yields a <code>Float</code> representing the time in seconds for the heartbeat ping request to be echoed.</p>
<p>Failure to receive a heartbeat ping will trigger the errback callbacks of the <a href="/realtime/types#deferrable"><code>Deferrable</code></a> with an <a href="#error-info"><code>ErrorInfo</code></a> object containing an error response as defined in the <a href="/rest-api#common">Ably REST API</a> documentation.</p>

</div> <!-- /end ruby language block -->

<h2 id="related-types">Related types</h2>
<h3 id="completion-listener"><span lang='java'>io.ably.lib.realtime.CompletionListener</span></h3>


<div lang="java"> <!-- start java language block -->
<p>A <span lang="java"><code>io.ably.lib.realtime.CompletionListener</code></span> is an interface allowing a client to be notified of the outcome of an asynchronous operation.</p>
<pre lang="java"><code lang="java">public interface CompletionListener {
  // Called when the associated operation completes successfully,
  public void onSuccess();

  // Called when the associated operation completes with an error.
  public void onError(ErrorInfo reason);
}</code></pre>

</div> <!-- /end java language block -->

<h3 id="connection-state"><span lang='default'>ConnectionState</span><span lang='swift,objc'>ARTRealtimeConnectionState</span><span lang='ruby'>Connection::STATE Enum</span><span lang='java'>io.ably.lib.realtime.ConnectionState Enum</span></h3>


<div lang="javascript,nodejs"> <!-- start javascript,nodejs language block -->
<p><code>ConnectionState</code> is a String with a value matching any of the <a href="/realtime/connection#connection-states"><code>Realtime Connection</code> states</a>.</p>
<pre lang="javascript"><code lang="javascript">var allConnectionStates = [
  'initialized',
  'connecting',
  'connected',
  'disconnected',
  'suspended',
  'closing',
  'closed',
  'failed'
]</code></pre>

</div> <!-- /end javascript,nodejs language block -->



<div lang="java"> <!-- start java language block -->
<p><code>io.ably.lib.realtime.ConnectionState</code> is an enum representing all the <a href="/realtime/connection#connection-states"><code>Realtime Connection</code> states</a>.</p>
<pre lang="java"><code lang="java">public enum ConnectionState {
  initialized,   // 0
  connecting,    // 1
  connected,     // 2
  disconnected,  // 3
  suspended,     // 4
  closing,       // 5
  closed,        // 6
  failed         // 7
}</code></pre>

</div> <!-- /end java language block -->



<div lang="ruby"> <!-- start ruby language block -->
<p><code>Ably::Realtime::Connection::STATE</code> is an enum-like value representing all the <a href="/realtime/connection#connection-states"><code>Realtime Connection</code> states</a>. <code>STATE</code> can be represented interchangeably as either symbols or constants.</p>
<h4>Symbol states</h4>
<pre lang="ruby"><code lang="ruby">:initialized # =&gt;  0
:connecting # =&gt;   1
:connected # =&gt;    2
:disconnected # =&gt; 3
:suspended # =&gt;    4
:closing # =&gt;      5
:closed # =&gt;       6
:failed # =&gt;       7</code></pre>
<h4>Constant states</h4>
<pre lang="ruby"><code lang="ruby">Connection::STATE.Initialized # =&gt;  0
Connection::STATE.Connecting # =&gt;   1
Connection::STATE.Connected # =&gt;    2
Connection::STATE.Disconnected # =&gt; 3
Connection::STATE.Suspended # =&gt;    4
Connection::STATE.Closing # =&gt;      5
Connection::STATE.Closed # =&gt;       6
Connection::STATE.Failed # =&gt;       7</code></pre>
<h4>Example usage</h4>
<pre lang="ruby"><code lang="ruby"># Example with symbols
client.connection.on(:connected) { ... }

# Example with constants
client.connection.on(Ably::Realtime::Connection::STATE.Connected) { ... }

# Interchangeable
Ably::Realtime::Connection::STATE.Connected == :connected # =&gt; true</code></pre>

</div> <!-- /end ruby language block -->



<div lang="objc,swift"> <!-- start objc,swift language block -->
<p><code>ARTRealtimeConnectionState</code> is an enum representing all the <a href="/realtime/connection#connection-states"><code>Realtime Connection</code> states</a>.</p>
<pre lang="objc"><code lang="objc">typedef NS_ENUM(NSUInteger, ARTRealtimeConnectionState) {
    ARTRealtimeInitialized,
    ARTRealtimeConnecting,
    ARTRealtimeConnected,
    ARTRealtimeDisconnected,
    ARTRealtimeSuspended,
    ARTRealtimeClosing,
    ARTRealtimeClosed,
    ARTRealtimeFailed
};</code></pre>
<pre lang="swift"><code lang="swift">public enum ARTRealtimeConnectionState : UInt {   
    case Initialized
    case Connecting
    case Connected
    case Disconnected
    case Suspended
    case Closing
    case Closed
    case Failed
}</code></pre>

</div> <!-- /end objc,swift language block -->

<h3 id="connection-state-listener"><span lang='java'>io.ably.lib.realtime.ConnectionStateListener</span></h3>


<div lang="java"> <!-- start java language block -->
<p>A <span lang="java"><code>io.ably.lib.realtime.ConnectionStateListener</code></span> is an interface allowing a client to be notified of connection state change. See <a href="/realtime/connection#on"><code>Connection#on</code></a> to register a listener for one or more events.</p>
<pre lang="java"><code lang="java">public interface ConnectionStateListener {
  // Called when the connection state changes
  public void onConnectionStateChanged(ConnectionStateListener.ConnectionStateChange state);
}</code></pre>

</div> <!-- /end java language block -->

<h3 id="connection-state-change"><span lang='default'>ConnectionStateChange Object</span><span lang='objc,swift'>ARTConnectionStateChange</span><span lang='java'>io.ably.lib.realtime.ConnectionStateListener.ConnectionStateChange</span><span lang='ruby'>ConnectionStateChange</span></h3>
<p>A <span lang="java"><code>io.ably.lib.realtime.ConnectionStateListener.ConnectionStateChange</code></span><span lang="ruby"><code>Ably::Models::ConnectionStateChange</code></span><span lang="swift,objc"><code>ARTConnectionStateChange</code></span><span lang="default"><code>ConnectionStateChange</code></span> is a type encapsulating state change information emitted by the <a href="/realtime/connection"><code>Connection</code></a> object. See <a href="/realtime/connection#on"><code>Connection#on</code></a> to register a listener for one or more events.</p>
<h4><span lang='default'>Properties</span><span lang='java'>Members</span><span lang='ruby'>Attributes</span></h4>
<dl>
	<dt>previous</dt>
	<dd>the previous state<br><i>Type: <span lang="default"><a href="/realtime/types#connection-state">State <code>String</code></a></span><span lang="ruby"><a href="/realtime/types#connection-state"><code>Connection::STATE</code></a></span><span lang="java"><a href="/realtime/types#connection-state"><code>ConnectionState</code></a></span></i></dd>
	<dt>current</dt>
	<dd>the new state<br><i>Type: <span lang="default"><a href="/realtime/types#connection-state">State <code>String</code></a></span><span lang="ruby"><a href="/realtime/types#connection-state"><code>Connection::STATE</code></a></span><span lang="java"><a href="/realtime/types#connection-state"><code>ConnectionState</code></a></span></i></dd>
	<dt>reason</dt>
	<dd>an <a href="#error-info"><code>ErrorInfo</code></a> containing any information relating to the transition<br><i>Type: <a href="/realtime/types#error-info"><code>ErrorInfo</code></a></i></dd>
	<dt><span lang="default">retryIn</span><span lang="ruby">retry_in</span></dt>
	<dd>Duration upon which the library will retry a connection where applicable, as <span lang="default">milliseconds</span><span lang="ruby">seconds</span><br><i>Type: <span lang="default"><code>Integer</code></span><span lang="java"><code>Long Integer</code></span></i></dd>
</dl>
<h3 id="last-connection-details"><span lang='javascript'>LastConnectionDetails</span></h3>


<div lang="javascript"> <!-- start javascript language block -->
<p>A <code>LastConnectionDetails</code> object provides details on the last connection in a browser environment persisted when the <code>window beforeunload</code> fired. This object is provided to the callback specified in the <code>recover</code> attribute of <a href="/realtime/types#client-options"><code>ClientOptions</code></a>. The callback in turn instructs the client library whether the connection should be recovered or not. See <a href="/realtime/connection/#connection-state-recovery">connection state recovery</a> for more information.</p>
<p>Please note that as <a href="https://www.w3.org/TR/webstorage/"><code>sessionStorage</code></a> is used to persist the <code>LastConnectionDetails</code> between page reloads, it is only available for pages in the same origin and top-level browsing context.</p>
<h4><span lang='default'>Properties</span></h4>
<dl>
	<dt>recoveryKey</dt>
	<dd>An opaque string obtained from the <a href="/realtime/connection/#recovery-key">recoveryKey</a> attribute of the <a href="/realtime/connection">Connection object</a> before the page was unloaded. This property is used by the library to recover the connection<br><i>Type: <code>String</code></i></dd>
</dl>
<dl>
	<dt>disconnectedAt</dt>
	<dd>the time at which the previous library was abruptly disconnected before the page was unloaded. This is represented as milliseconds since epoch<br><i>Type: <code>Integer</code></i></dd>
</dl>
<dl>
	<dt>location</dt>
	<dd>a clone of <a href="https://www.w3.org/TR/html5/browsers.html#the-location-interface"><code>location</code></a> object of the previous page&#8217;s <code>document</code> object before the page was unloaded. A common use case for this attribute is to ensure that the previous page URL is the same as the current URL before allowing the connection to be recovered. For example, you may want the connection to be recovered only for page reloads, but not when a user navigates to a different page<br><i>Type: <code>String</code></i></dd>
</dl>
<dl>
	<dt>clientId</dt>
	<dd>the <a href="/realtime/authentication/#client-id"><code>clientId</code></a> of the <a href="/realtime/authentication">client&#8217;s Auth object</a> before the page was unloaded. A common use case for this attribute is to ensure that the current logged in user&#8217;s <code>clientId</code> matches the previous connection&#8217;s <code>clientId</code> before allowing the connection to be recovered. Ably prohibits changing a <code>clientId</code> for an existing connection, so any mismatch in <code>clientId</code> during a recover will result in the connection moving to the failed state<br><i>Type: <code>String</code></i></dd>
</dl>

</div> <!-- /end javascript language block -->


    </article>
    <hr class="back">
    <a href="#documentation">Back to top</a>
  </div>
  <div id="sidebar">
  <a href="/" title="API Documentation Home"><img src="/images/ably-logo.png" class="ably-logo" title="API Documentation Home"></a>
  <ul>
<li class=''><a href='/quick-start-guide/'>Quickstart Guide</a></li>
<li class=''><a href='/how-ably-works/'>How Ably works</a></li>
</ul>
  <h2><a href="/realtime/">Realtime client lib</a></h2>
<ul>
<li class=''><a href='/realtime/usage/'>Using the Realtime library</a></li>
<li class='selected'><a href='/realtime/connection/'>Connection</a></li>
<li class=''><a href='/realtime/channels-messages/'>Channels and Messages</a></li>
<li class=''><a href='/realtime/presence/'>Presence</a></li>
<li class=''><a href='/realtime/authentication/'>Authentication</a></li>
<li class=''><a href='/realtime/history/'>History</a></li>
<li class=''><a href='/realtime/encryption/'>Encryption</a></li>
<li class=''><a href='/realtime/statistics/'>Statistics</a></li>
<li class=''><a href='/realtime/types/'>Types</a></li>
</ul>
  <h2><a href="/rest/">REST client lib</a></h2>
<ul>
<li class=''><a href='/rest/usage/'>Using the REST library</a></li>
<li class=''><a href='/rest/channels-messages/'>Channels and Messages</a></li>
<li class=''><a href='/rest/presence/'>Presence</a></li>
<li class=''><a href='/rest/authentication/'>Authentication</a></li>
<li class=''><a href='/rest/history/'>History</a></li>
<li class=''><a href='/rest/encryption/'>Encryption</a></li>
<li class=''><a href='/rest/statistics/'>Statistics</a></li>
<li class=''><a href='/rest/types/'>Types</a></li>
</ul>
  <h2><a href="/rest-api/">REST API</a></h2>
<ul>
</ul>
  <h2>General</h2>
<ul>
<li class=''><a href='/general/authentication/'>Authentication</a></li>
<li class=''><a href='/general/channel-rules-namespaces/'>Channel Rules and Namespaces</a></li>
<li class=''><a href='/general/push-notifications/'>Mobile push notifications</a></li>
<li class=''><a href='/general/webhooks/'>Receiving WebHooks</a></li>
<li class=''><a href='/general/statistics/'>Application Statistics</a></li>
</ul>
  <h2><a href="/client-lib-development-guide/">Library Development</a></h2>
<ul>
<li class=''><a href='/client-lib-development-guide/features/'>Features spec v0.9</a></li>
<li class=''><a href='/client-lib-development-guide/feature-prioritisation/'>Feature prioritisation</a></li>
<li class=''><a href='/client-lib-development-guide/protocol/'>Realtime Protocol Definition</a></li>
<li class=''><a href='/client-lib-development-guide/rest-api/'>REST API Definition</a></li>
<li class=''><a href='/client-lib-development-guide/test-api/'>Sandbox Test API</a></li>
<li class=''><a href='/client-lib-development-guide/encryption/'>Encryption</a></li>
<li class=''><a href='/client-lib-development-guide/websocket/'>WebSocket Transport</a></li>
<li class=''><a href='/client-lib-development-guide/comet/'>Comet Transport</a></li>
<li class=''><a href='/client-lib-development-guide/connection-recovery/'>Connection Recovery</a></li>
<li class=''><a href='/client-lib-development-guide/connection-manager/'>Connection Manager</a></li>
<li class=''><a href='/client-lib-development-guide/connection-fallback/'>Connection host fallback</a></li>
<li class=''><a href='/client-lib-development-guide/documentation-formatting-guide/'>Documentation Formatting Guide</a></li>
<li class=''><a href='/code-index/'>Code Examples List</a></li>
</ul>
  <ul>
<li><a href="https://www.ably.io">Visit Ably.io</a></li>
</ul>
</div>

</body>
</html>
