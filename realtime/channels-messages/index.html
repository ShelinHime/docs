<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Ably API Documentation - Channels and Messages</title>
    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="stylesheet" type="text/css" href="/vendor/prettify/prettify.css" media="screen">
    <link rel="stylesheet" type="text/css" href="/stylesheet.css" media="screen">

    
      <link rel="canonical" href="https://www.ably.io/documentation/realtime/channels-messages" />
    

    <script src="/vendor/javascripts/jquery-1-8-3-min.js" type="text/javascript"></script>
    <script src="/vendor/javascripts/jquery-cookie-1-3-1.js" type="text/javascript"></script>
    <script src="/vendor/javascripts/base64.js" type="text/javascript"></script>

    <script src="/vendor/prettify/prettify-lib.js" type="text/javascript"></script>

    <script src="//cdn.ably.io/lib/ably.min.js" type="text/javascript"></script>

    <script src="/javascripts/application.js" type="text/javascript"></script>
    <script src="/javascripts/lang-manager.js" type="text/javascript"></script>

    <script type="text/javascript">window.NavLangs=["javascript","nodejs","ruby","java","swift","objc","csharp"];</script>

    <!-- you don't need to keep this, but it's cool for stats! -->
    <meta name="generator" content="nanoc 3.7.5">
  </head>
  <body>
    <div class="canonical-notice">
      <img src="/images/icon-alert.png">
      <span class="canonical-notice-text">
        You are viewing our bleeding edge unstable documentation. We recommend you use our <a href="https://www.ably.io/documentation">stable documentation Â»</a>
      </span>
      <img src="/images/icon-alert.png">
    </div>
    <div class="fork-banner"><a href="https://github.com/ably/docs"><img src="/images/forkme.png" alt="Fork me on GitHub"></a></div>

  <div id="documentation">
    
      <nav class="jump-to-nav">
        <div class="form">
          <select id="jump-to-nav">
            <option>Jump to ...</option>
            <optgroup label='Help with'>
<option id="anchor-getting-started">Getting started</option>
<option id="anchor-channels">Channels &amp; lifecycle</option>
<option id="anchor-channel-states">Channel states</option>
<option id="anchor-handling-failures">Handling failures</option>
<option id="anchor-channel-namespaces">Channel namespaces</option>
<option id="anchor-message-subscription">Subscribing to messages</option>
<option id="anchor-message-publish">Publishing messages</option>
<option id="anchor-message-history">Retrieving message history</option>
</optgroup>
<optgroup label='Channel API properties'>
<option id="anchor-state">state</option>
<option id="anchor-error-reason">errorReason</option>
<option id="anchor-name">name</option>
<option id="anchor-presence">presence</option>
</optgroup>
<optgroup label='Channel API methods'>
<option id="anchor-publish">publish</option>
<option id="anchor-subscribe">subscribe</option>
<option id="anchor-unsubscribe">unsubscribe</option>
<option id="anchor-history">history</option>
<option id="anchor-attach">attach</option>
<option id="anchor-detach">detach</option>
<option id="anchor-on">on</option>
<option id="anchor-once">once</option>
<option id="anchor-off">off</option>
</optgroup>
          </select>
        </div>
      </nav>
    
    <header>
      
        <div class="breadcrumb"><a href="/realtime/">Realtime Client Library API</a><span class="separator">/</span></div>
      
      
        <h1 id="title">Channels and Messages</h1>
      
    </header>
    <article>
      <p>The Ably Realtime service organises the message traffic within applications into named channels. Channels are the &#8220;unit&#8221; of message distribution; clients attach to channels to subscribe to messages, and every message published to a unique channel is broadcast by Ably to all subscribers. This scalable and resilient messaging pattern is commonly called <a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">pub/sub</a>.</p>
<h2 id="getting-started">Getting started</h2>
<p>The Ably Realtime client library provides a straightforward API for publishing and subscribing to messages on a channel. If the channel does not exist at the time the client is attached, a channel will be created in the Ably system immediately.</p>
<pre class="code-editor open-jsbin open-jsbin-owecul" lang="javascript"><code class="code-editor open-jsbin open-jsbin-owecul" lang="javascript">var realtime = new Ably.Realtime('{{API_KEY}}');
var channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');
channel.subscribe(function(message) {
  alert('Received: ' + message.data);
});
channel.publish('example', 'message data');</code></pre>
<pre class="code-editor open-jsbin open-jsbin-owecul" lang="nodejs"><code class="code-editor open-jsbin open-jsbin-owecul" lang="nodejs">var Ably = require('ably');
var realtime = new Ably.Realtime('{{API_KEY}}');
var channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');
channel.subscribe(function(message) {
  alert("Received: "  message.data);
});
channel.publish("example", "message data");</code></pre>
<pre lang="ruby"><code lang="ruby">realtime = Ably::Realtime.new('{{API_KEY}}')
channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}')
channel.subscribe do |message|
  puts "Received: #{message.data}"
end
channel.publish 'example', 'message data'</code></pre>
<pre lang="java"><code lang="java">AblyRealtime realtime = new AblyRealtime("{{API_KEY}}");
Channel channel = realtime.channels.get("{{RANDOM_CHANNEL_NAME}}");
channel.subscribe(new MessageListener() {
  @Override
  public void onMessage(Message message) {
    System.out.println("New messages arrived. " + message.name);
  }
});
channel.publish("example", "message data");</code></pre>
<pre lang="csharp"><code lang="csharp">AblyRealtime realtime = new AblyRealtime("{{API_KEY}}");
var channel = realtime.Channels.Get("{{RANDOM_CHANNEL_NAME}}");
channel.Subscribe(message =&gt; {
  Console.WriteLine($"Message: {message.name}:{message.data} received")
});
channel.Publish("example", "message data");</code></pre>
<pre lang="objc"><code lang="objc">ARTRealtime *realtime = [[ARTRealtime alloc] initWithKey:@"{{API_KEY}}"];
ARTRealtimeChannel *channel = [realtime.channels get:@"{{RANDOM_CHANNEL_NAME}}"];
[channel subscribe:^(ARTMessage *message) {
    NSLog(@"Received: %@", message.data);
}];
[channel publish:@"example" data:@"message data"];</code></pre>
<pre lang="swift"><code lang="swift">let realtime = ARTRealtime(key: "{{API_KEY}}")
let channel = realtime.channels.get("{{RANDOM_CHANNEL_NAME}}")
channel.subscribe { message in
    print("Received: \(message.data)")
}
channel.publish("example", data: "message data")</code></pre>
<h2 id="channels">Channels</h2>
<p>In order to publish, subscribe to, or be present on a channel, you must first obtain a channel instance and then attach to that channel. In most instances, as a convenience, it is unnecessary to explicitly attach a channel as it will implicitly attached when performing any operation on the channel such as publishing or subscribing.</p>
<h3>Obtaining a channel instance</h3>
<p>A <code>Channel</code> object is a reference to a single channel. A channel instance is obtained from the <a href="/realtime/usage/#channels"><code>channels</code> collection</a> of the <span lang="ruby"><code>Realtime::Client</code></span><span lang="default"><code>Realtime</code></span><span lang="objc,swift"><code>ARTRealtime</code></span><span lang="csharp"><code>AblyRealtime</code></span> instance, and is uniquely identified by its unicode string name. Find out more about <a href="https://support.ably.io/solution/articles/3000046824-what-restrictions-exist-for-the-name-field-of-a-channel">channel naming</a></p>
<pre class="code-editor open-jsbin open-jsbin-agorop" lang="javascript"><code class="code-editor open-jsbin open-jsbin-agorop" lang="javascript">var channel = realtime.channels.get('channelName');</code></pre>
<pre class="code-editor open-jsbin open-jsbin-agorop" lang="nodejs"><code class="code-editor open-jsbin open-jsbin-agorop" lang="nodejs">var channel = realtime.channels.get('channelName');</code></pre>
<pre lang="java"><code lang="java">Channel channel = realtime.channels.get("channelName");</code></pre>
<pre lang="csharp"><code lang="csharp">var channel = realtime.Channels.Get("channelName");</code></pre>
<pre lang="ruby"><code lang="ruby">channel = realtime.channels.get('channelName')</code></pre>
<pre lang="objc"><code lang="objc">ARTRealtimeChannel *channel = [realtime.channels get:@"channelName"];</code></pre>
<pre lang="swift"><code lang="swift">let channel = realtime.channels.get("channelName")</code></pre>
<h4>Setting channel options and encryption</h4>
<p>A set of <a href="#channel-options">channel options</a> may also be passed to configure a channel for encryption. Find out more about <a href="/realtime/encryption">symmetric message encryption</a>.</p>
<pre lang="javascript"><code lang="javascript">Ably.Realtime.Crypto.generateRandomKey(function(err, key) {
  var options = { cipher: { key: key } };
  var channel = realtime.channels.get('channelName', options);
});</code></pre>
<pre lang="nodejs"><code lang="nodejs">Ably.Realtime.Crypto.generateRandomKey(function(err, key) {
  var options = { cipher: { key: key } };
  var channel = realtime.channels.get('channelName', options);
});</code></pre>
<pre lang="java"><code lang="java">CipherParams params = Crypto.getDefaultParams(key);
ChannelOptions options = new ChannelOptions();
options.cipher = params;
Channel channel = realtime.channels.get("channelName", options);</code></pre>
<pre lang="csharp"><code lang="csharp">byte[] key = Crypto.GetRandomKey();
var cipherParams = Crypto.GetDefaultParams(key);
var channelOpts = new ChannelOptions(cipherParams);
var encryptedChannel = realtime.Channels.Get("channelName", channelOpts);</code></pre>
<pre lang="ruby"><code lang="ruby">key = Ably::Util::Crypto.generate_random_key
options = { cipher: { key: key } }
channel = realtime.channels.get('channelName', options)</code></pre>
<pre lang="objc"><code lang="objc">NSData *key = [ARTCrypto generateRandomKey];
ARTChannelOptions *options = [[ARTChannelOptions alloc] initWithCipherKey:key];
ARTRealtimeChannel *channel = [realtime.channels get:@"channelName" options:options];</code></pre>
<pre lang="swift"><code lang="swift">let key = ARTCrypto.generateRandomKey()
let options = ARTChannelOptions(cipherKey: key)
let channel = realtime.channels.get("channelName", options: options)</code></pre>
<h3 id="channel-lifecycle">Channel lifecycle</h3>
<p>Channels are not pre-configured or provisioned by Ably in advance; they are created on demand when clients attach, and remain active until such time that there are no remaining attached clients. Within the <a href="https://support.ably.io/solution/articles/3000030053-how-do-i-access-my-app-dashboard">dashboard for your app</a> however, you can pre-configure one or more <a href="#channel-namespaces">channel namespaces</a> (i.e. name prefixes), and associate different attributes and access rights with those namespaces. Find out more about <a href="#channel-namespaces">channel namespaces</a>.</p>
<p>The following example explicitly attaches to a channel, which results in the channel being provisioned in Ably&#8217;s global realtime cluster. This channel will remain available globally until there are no more clients attached to the channel:</p>
<pre lang="javascript"><code lang="javascript">realtime.channels.get('chatroom').attach(function() {
  console.log('"chatroom" exists and is now available globally in every data centre');
});</code></pre>
<pre lang="nodejs"><code lang="nodejs">realtime.channels.get('chatroom').attach(function() {
  console.log('"chatroom" exists and is now available globally in every data centre');
});</code></pre>
<pre lang="ruby"><code lang="ruby">realtime.channels.get('chatroom').attach do |channel|
  puts "'chatroom' exists and is now available globally in every data centre"
end</code></pre>
<pre lang="java"><code lang="java">Channel channel = realtime.channels.get("chatroom");
channel.on(new ChannelStateListener() {
  @Override
  public void onChannelStateChanged(ChannelState state, ErrorInfo reason) {
    switch (state.current) {
      case attached: {
        System.out.println("'chatroom' exists and is now available globally");
      }
    }
  }
});</code></pre>
<pre lang="csharp"><code lang="csharp">var channel = realtime.Channels.Get("chatroom");
channel.Attach((success, error) =&gt; {
  Console.WriteLine("'chatroom' exists and is now available globally");
});</code></pre>
<pre lang="objc"><code lang="objc">[[realtime.channels get:@"chatroom" options:options] attach:^(ARTErrorInfo *error) {
  NSLog(@"'chatroom' exists and is now available globally in every data centre");
}];</code></pre>
<pre lang="swift"><code lang="swift">realtime.channels.get("chatroom").attach { error in
  print("'chatroom' exists and is now available globally in every data centre")
}</code></pre>
<p>Clients attach to a channel in order to participate on that channel in any way (either to publish, subscribe, or be present on the channel).</p>
<h3>Implicit attach</h3>
<p>Although the attach operation can be initiated explicitly by a client, it is more common for the client to perform a publish or subscribe operation, and the client library will initiate the attach if the channel is not already attached. The client library allows clients to begin publishing messages to a channel as soon as the channel has been created, and messages are queued until such time as the attach has succeeded or failed.</p>
<pre class="code-editor open-jsbin open-jsbin-onurog" lang="javascript"><code class="code-editor open-jsbin open-jsbin-onurog" lang="javascript">var channel = realtime.channels.get('chatroom');
channel.subscribe('action', function(message) { // implicit attach
  console.log('Message received '' + message.data);
});
channel.publish('action', 'boom!');</code></pre>
<pre class="code-editor open-jsbin open-jsbin-onurog" lang="nodejs"><code class="code-editor open-jsbin open-jsbin-onurog" lang="nodejs">var channel = realtime.channels.get('chatroom');
channel.subscribe('action', function(message) { // implicit attach
  console.log('Message received '' + message.data);
});
channel.publish('action', 'boom!');</code></pre>
<pre lang="ruby"><code lang="ruby">channel = realtime.channels.get('chatroom')
channel.subscribe('action') do |message| # implicit attach
  puts "Message received: #{message}";
end
channel.publish 'action', 'boom!'</code></pre>
<pre lang="java"><code lang="java">Channel channel = realtime.channels.get("chatroom");
/* Implicit attach when subscribing */
channel.subscribe(new MessageListener() {
  @Override
  public void onMessage(Message message) {
    System.out.println("Message received: " + message.data);
  }
});
channel.publish("action", "boom!");</code></pre>
<pre lang="csharp"><code lang="csharp">var channel = realtime.Channels.Get("chatroom");
channel.Subscribe(message =&gt; Console.WriteLine("Message received:" + message.data));
channel.Publish("action", "boom");</code></pre>
<pre lang="objc"><code lang="objc">ARTRealtimeChannel *channel = [realtime.channels get:@"chatroom" options:options];
[channel subscribe:@"action" callback:^(ARTMessage *message) {
    NSLog(@"Message received: %@", message.data);
}]
[channel publish:@"action" data:@"boom!"];</code></pre>
<pre lang="swift"><code lang="swift">let channel = realtime.channels.get("chatroom")
channel.subscribe("action") { message in
    print("Message received: \(message.data)")
}
channel.publish("action", data: "boom!")</code></pre>
<h3 id="channel-states">Channel states</h3>
<p>A channel can exist in any of the following states:</p>
<dl>
	<dt>initialized</dt>
	<dd>A <code>Channel</code> object having this state has been initialized but no attach has yet been attempted</dd>
</dl>
<dl>
	<dt>attaching</dt>
	<dd>An attach has been initiated by sending a request to Ably. This is a transient state; it will be followed either by a transition to attached or failed</dd>
</dl>
<dl>
	<dt>attached</dt>
	<dd>Attach has succeeded. In the attached state a client may publish and subscribe to messages, or be present</dd>
</dl>
<dl>
	<dt>detaching</dt>
	<dd>A detach has been initiated on the attached <code>Channel</code> by sending a request to Ably. This is a transient state; it will be followed either by a transition to detached or failed</dd>
</dl>
<dl>
	<dt>detached</dt>
	<dd>The <code>Channel</code>, having previously been attached, has been detached</dd>
</dl>
<dl>
	<dt>failed</dt>
	<dd>An indefinite failure condition. This state is entered if a <code>Channel</code> error has been received from the Ably service (such as an attempt to attach without the necessary access rights)</dd>
</dl>
<h3>Listening for state changes</h3>
<p>The <code>Channel</code> object is an <code>EventEmitter</code> and emits an event whose name is the new state whenever there is a channel state change. <span lang="javascript,nodejs">As with all events from an <code>EventEmitter</code> in the Ably library, <code>this</code> within the listener function is a reference to an event object whose <code>event</code> property is the name of the event that fired. This allows a listener to listen for all events with a single registration and know, which event fired when it is entered.</span></p>
<pre lang="javascript"><code lang="javascript">channel.on('attached', function() {
  console.log('channel ' + channel.name + ' is now attached');
});</code></pre>
<pre lang="nodejs"><code lang="nodejs">channel.on('attached', function() {
  console.log('channel ' + channel.name + ' is now attached');
});</code></pre>
<pre lang="ruby"><code lang="ruby">channel.on(:attached) do |channel_state_change|
  puts "channel #{channel.name} is now attached"
end</code></pre>
<pre lang="java"><code lang="java">channel.on(ChannelState.attached, new ChannelStateListener() {
  @Override
  public void onChannelStateChanged(ChannelState state, ErrorInfo reason) {
    System.out.println("channel " + channel.name + " is now attached");
  }
});</code></pre>
<pre lang="csharp"><code lang="csharp">var channel = realtime.Channels.Get("chatroom");
channel.On(ChannelState.Attached, args =&gt; {
  Console.WriteLine("channel " + channel.Name + " is now attached")
});</code></pre>
<pre lang="objc"><code lang="objc">[channel on:ARTChannelEventAttached call:^(ARTErrorInfo *error) {
  NSLog(@"channel %@ is now attached", channel.name);
}];</code></pre>
<pre lang="swift"><code lang="swift">channel.on(.Attached) { error in
  print("channel \(channel.name) is now attached")
}</code></pre>
<p>Alternatively a listener may be registered so that it receives all state change events.</p>
<pre class="code-editor open-jsbin open-jsbin-aqotuc" lang="javascript"><code class="code-editor open-jsbin open-jsbin-aqotuc" lang="javascript">var myListener = function() {
  console.log('channel state is ' + this.event);
});
channel.on(myListener);</code></pre>
<pre class="code-editor open-jsbin open-jsbin-aqotuc" lang="nodejs"><code class="code-editor open-jsbin open-jsbin-aqotuc" lang="nodejs">var myListener = function() {
  console.log('channel state is ' + this.event);
});
channel.on(myListener);</code></pre>
<pre lang="ruby"><code lang="ruby">channel.on do |channel_state_change|
  puts "channel state is #{channel_state_change.current}"
end</code></pre>
<pre lang="java"><code lang="java">channel.on(new ChannelStateListener() {
  @Override
  public void onChannelStateChanged(ChannelState state, ErrorInfo reason) {
    System.out.println("channel state is " + ChannelState.values()[state]);
  }
});</code></pre>
<pre lang="csharp"><code lang="csharp">channel.On(args =&gt; Console.WriteLine("channel state is " + channel.State));</code></pre>
<pre lang="objc"><code lang="objc">ARTEventListener *listener = [channel on:^(ARTErrorInfo *error) {
    NSLog(@"channel state is %@", channel.state);
}];</code></pre>
<pre lang="swift"><code lang="swift">let listener = channel.on { error in
    print("channel state is \(channel.state)")
}</code></pre>
<p>Previously registered listeners can be removed individually or all together.</p>
<pre lang="javascript"><code lang="javascript">/* remove the listener registered for a single event */
channel.off('attached', myListener);

/* remove the listener registered for all events */
channel.off(myListener);</code></pre>
<pre lang="nodejs"><code lang="nodejs">/* remove the listener registered for a single event */
channel.off('attached', myListener);

/* remove the listener registered for all events */
channel.off(myListener);</code></pre>
<pre lang="ruby"><code lang="ruby"># remove the listener proc registered for a single event
channel.off(:attached, &amp;my_proc)

# remove the listener proc registered for all events
channel.off(&amp;my_proc)</code></pre>
<pre lang="java"><code lang="java">/* remove the listener registered for a single event */
channel.off(ChannelState.attached, channelStateListener);

/* remove the listener registered for all events */
channel.off(channelStateListener);</code></pre>
<pre lang="csharp"><code lang="csharp">// remove the listener registered for a single event
channel.Off(ChannelState.Attached, channelStateListener);

// remove the listener registered for all events
channel.Off(channelStateListener);</code></pre>
<pre lang="objc"><code lang="objc">// remove the listener registered for a single event
[channel off:ARTChannelEventAttached listener:listener];

// remove the listener registered for all events
[channel off:listener];</code></pre>
<pre lang="swift"><code lang="swift">// remove the listener registered for a single event
channel.off(.Attached, listener: listener)

// remove the listener registered for all events
channel.off(listener)</code></pre>
<h3 id="handling-failures">Handling channel failures</h3>
<p>Channel attach and detach operations are synchronous &#8211; after initiating an attach request, the client must wait for a response from Ably that confirms that the channel is established on the service.</p>
<p>There are cases where an attach will fail deterministically, such as if the client doesn&#8217;t have the necessary rights to access the channel.</p>
<pre lang="javascript"><code lang="javascript">realtime.channels.get('private:chatroom').attach(function(err) {
  if (err) {
    console.error('Attach failed: ' + err);
  }
});</code></pre>
<pre lang="nodejs"><code lang="nodejs">realtime.channels.get('private:chatroom').attach(function(err) {
  if (err) {
    console.error('Attach failed: ' + err);
  }
});</code></pre>
<pre lang="ruby"><code lang="ruby">promise = realtime.channels.get('private:chatroom').attach
promise.errback do |error|
  puts "Attach failed: #{error}"
end</code></pre>
<pre lang="java"><code lang="java">Channel channel = realtime.channels.get("private:chatroom");
channel.on(new ChannelStateListener() {
  @Override
  public void onChannelStateChanged(ChannelState state, ErrorInfo reason) {
    switch (state.current) {
      case failed: {
        System.out.println("Attach failed: " + reason.message);
      }
    }
  }
});</code></pre>
<pre lang="csharp"><code lang="csharp">var privateChannel = realtime.Channels.Get("private:chatroom");
privateChannel.Attach((_, error) =&gt; {
    if (error != null)
    {
        Console.WriteLine("Attach failed: " + error.message);
    }
});</code></pre>
<pre lang="objc"><code lang="objc">[[realtime.channels get:@"private:chatroom"] attach:^(ARTErrorInfo *error) {
    if (error) {
        NSLog(@"Attach failed: %@", error);
    }
}];</code></pre>
<pre lang="swift"><code lang="swift">realtime.channels.get("private:chatroom").attach { error in
    if let error = error {
        print("Attach failed: \(error)")
    }
}</code></pre>
<h4>Connection state change side effects on channels</h4>
<p>Once a channel becomes attached, it will remain attached until any of the following occurs:</p>
<ul>
	<li>An explicit request to detach the channel is made;</li>
	<li>The channel moves into the <code>failed</code> state following an unrecoverable error sent from Ably. If for example permissions were revoked for that client on that channel, the channel would move to the <code>failed</code> state;</li>
	<li>The connection enters the <code>suspended</code>, <code>failed</code> or <code>closed</code> state;</li>
	<li>The connection is not resumed fully as part of the <a href="#connection-state-recovery">connection state recovery process</a></li>
</ul>
<p>Ably provides automatic message continuity for channels, even when connections are disconnected and later resumed. See <a href="/realtime/connection#connection-state-recovery">connection state recovery</a> for more details on how connections and channel state recovery allows you, as a developer, to publish and receive messages without having to worry about changing network conditions. However, there are times when connection recovery is not possible such as being disconnected from Ably for more than two minutes.  When this occurs, the channels that are attached can no longer provide guaranteed message continuity. We wanted developers to be aware of this discontinuity, and as such, our client libraries will automatically detach all attached channels that have lost continuity. It is then up to the developer to decide what action to take such as using the <a href="/realtime/history">history API</a> to retrieve old messages, or simply to reattach the channel and continue if messsage loss is not important.</p>
<p>For customers who want to ensure that all channels are attached when a connection is available, regardless of whether messages may have been missed, we recommend the following approach:</p>
<ul>
	<li>Add a listener on the connection object for all <code>connected</code> events</li>
	<li>Reattach all channels you have created. If a channel is already attached, and you call the <a href="/realtime/channels-messages/#attach"><span lang="default"><code>channel#attach</code></span><span lang="csharp"><code>channel#Attach</code></span></a> method, the channel will simply remain attached. It is therefore safe to simply attach all channels every time the connection becomes <code>connected</code></li>
</ul>
<p>The following Javascript example demonstrates a trivial way to ensure all channels are attached when the client becomes connected or the channel becomes detached:</p>
<pre lang="javascript"><code lang="javascript">function reattach(channel) {
  channel.attach();
  /* Example when using presence on the channel */
  channel.presence.enter();
}

/* Connection state changes can trigger channels to become detached
   Automatically re-attach channels, nothing will happen if alreay attached */
client.connection.on('connected', function() {
  for (let channelName in client.channels.all) {
    let channel = client.channels.get(channelName);
    reattach(channel);
  }
});

/* If a channel becomes detached due to channel failure (some edge cases exist)
   You should explicitly re-attach the channel if you are connected */
channel.on('detached', function() {
  if (client.connection.state === 'connected') {
    reattach(channel);
  }
});</code></pre>
<h3 id="channel-namespaces">Channel namespaces</h3>
<p>One or more channel namespaces, or channel name prefixes, may be <a href="https://support.ably.io/solution/articles/3000030053-how-do-i-access-my-app-dashboard">configured for an app in your dashboard</a>. When a channel is created whose name is prefixed with one of the namespaces, the channel assumes certain configured attributes associated with that namespace. For example, a channel namespace named &#8220;<code>private</code>&#8221; would match channels named &#8220;<code>private</code>&#8221;, &#8220;<code>private:chat</code>&#8221;, &#8220;<code>private:chat:mike</code>&#8221;.</p>
<p>Namespace-prefixed channel names are delimited by a single colon <code>:</code>; the first component of the channel name (from the start up to and including the last character before the colon) is the namespace. A channel name may validly contain a colon even if the namespace component does not correspond to a namespace; also, a channel may contain multiple colons and only the component up to the first colon will be matched with a namespace. The only restriction on channel names is that a channel name may not start with a colon <code>:</code>, an open square bracket <code>[</code> and it may not be empty.</p>
<p>Namespaces are defined and configured via the <a href="https://support.ably.io/solution/articles/3000030057-what-are-channel-rules-and-how-can-i-use-them-in-my-app">application dashboard settings</a>. The namespace attributes that can be configured are:</p>
<ul>
	<li><b>Persisted messages</b> &#8211; If enabled, all messages within this namespace will be stored according to the storage rules for your account. You can access stored messages via the <a href="/realtime/history">history API</a></li>
	<li><b>Require identification</b> &#8211; if enabled, clients will not be permitted to subscribe to matching channels unless they are both authenticated and identified (they have an assigned client ID). Anonymous clients are not permitted to join these channels. Find out more about <a href="https://support.ably.io/solution/articles/3000038608-authenticated-clients">authenticated and identified clients</a></li>
	<li><b>Require TLS</b> &#8211; if enabled, only clients who have connected to Ably over TLS will be allowed to join the channel</li>
</ul>
<p>Key or token capabilities can also specify access rights based on channel namespace, find out more about <a href="/general/authentication">authentication</a></p>
<h2>Messages</h2>
<p>Each message published has an optional event <code>name</code> <span lang="default">property</span><span lang="java">member</span><span lang="ruby">attribute</span> and a <code>data</code> <span lang="default">property</span><span lang="java">member</span><span lang="ruby">attribute</span> carrying the payload of the message. Various primitive and object types are portably defined and supported in all clients, enabling clients to be interoperable despite being hosted in different languages or environments.</p>
<p>The supported payload types are Strings, JSON objects and arrays, buffers containing arbitrary binary data, and Null objects. Client libraries detect the supplied message payload and encode the message appropriately.</p>
<h3 id="message-subscription">Subscribing to messages</h3>
<p>The <code>name</code> <span lang="default">property</span><span lang="java">member</span><span lang="ruby">attribute</span> of published messages does not affect the distribution of a channel message to clients but may be used as a (purely clientside) subscription filter, allowing a client to register a listener that only sees a subset of the messages received on the channel. When subscribing, a message listener can subscribe to see all messages on the channel or only a subset whose name matches a given <code>name</code> string.</p>
<p>The client can choose whether or not to receive messages that they themselves publish using <span lang="default"><a href="/realtime/usage/#client-options"><code>ClientOptions#echoMessages</code></a></span><span lang="ruby"><a href="/realtime/usage/#client-options"><code>ClientOptions#echo_messages</code></a></span>.</p>
<div lang="javascript,nodejs,,objc,swift">
<p>A client can subscribe to all messages on a channel by passing a listener function to the <code>subscribe</code> method. The listener is passed a <a href="#message"><code>Message</code></a> object for each message received.</p>
<p></div><div lang="java"><br />
A client can register for messages on a channel by implementing <a href="#message-listener">MessageListener</a> and calling the <code>subscribe(MessageListener listener)</code> or <code>subscribe(String name, MessageListener listener)</code> method. The listener is passed an array of one or more <a href="#message"><code>Message</code></a> objects when messages are received.</p>
<p></div><div lang="ruby"><br />
A client can subscribe to all messages on a channel by passing a block to the <code>subscribe</code> method. The block is passed a <a href="#message"><code>Message</code></a> object for each message are received.</p>
<p></div><div lang="csharp"><br />
A client can subscribe to all messages on a channel by passing a lambda expression to the <code>Subscribe</code> method. The lambda is passed a <a href="#message"><code>Message</code></a> object for each message are received.</p>
</div>
<pre class="code-editor open-jsbin open-jsbin-owecul" lang="javascript"><code class="code-editor open-jsbin open-jsbin-owecul" lang="javascript">channel.subscribe(function(message) {
  console.log('message received for event ' + message.name);
  console.log('message data:' + message.data);
});</code></pre>
<pre class="code-editor open-jsbin open-jsbin-owecul" lang="nodejs"><code class="code-editor open-jsbin open-jsbin-owecul" lang="nodejs">channel.subscribe(function(message) {
  console.log('message received for event ' + message.name);
  console.log('message data:' + message.data);
});</code></pre>
<pre lang="java"><code lang="java">channel.subscribe(new MessageListener() {
  @Override
  public void onMessage(Message message) {
    System.out.println("Message received: " + message.data);
  }
});</code></pre>
<pre lang="csharp"><code lang="csharp">channel.Subscribe(message =&gt;
{
    Console.WriteLine($"message received for event {message.name}");
    Console.WriteLine($"message data: {message.data}");
});</code></pre>
<pre lang="ruby"><code lang="ruby">channel.subscribe do |message|
  puts "message received for event #{message.name}"
  puts "message data: #{message.data}"
end</code></pre>
<pre lang="objc"><code lang="objc">[channel subscribe:^(ARTMessage *message) {
    NSLog(@"message received for event %@", message.name);
    NSLog(@"message data: %@", message.data);
}];</code></pre>
<pre lang="swift"><code lang="swift">channel.subscribe { message in
    print("message received for event \(message.name)")
    print("message data: \(message.data)")
}</code></pre>
<p>Alternatively a listener may be registered so that it is called only for messages having a specific event name.</p>
<pre lang="javascript"><code lang="javascript">channel.subscribe('myEvent', function(message) {
  console.log('message received for event ' + message.name);
  console.log('message data:' + message.data);
});</code></pre>
<pre lang="nodejs"><code lang="nodejs">channel.subscribe('myEvent', function(message) {
  console.log('message received for event ' + message.name);
  console.log('message data:' + message.data);
});</code></pre>
<pre lang="java"><code lang="java">channel.subscribe("myEvent", new MessageListener() {
  @Override
  public void onMessage(Message message) {
    System.out.println("Message received: " + message.data);
  }
});</code></pre>
<pre lang="csharp"><code lang="csharp">channel.Subscribe("myEvent", message =&gt;
{
    Console.WriteLine($"message received for event {message.name}");
    Console.WriteLine($"message data: {message.data}");
});</code></pre>
<pre lang="ruby"><code lang="ruby">channel.subscribe('myEvent') do |message|
  puts "message received for event #{message.name}"
  puts "message data: #{message.data}"
end</code></pre>
<pre lang="swift"><code lang="swift">channel.subscribe("myEvent") { message in
    print("message received for event \(message.name)")
    print("message data: \(message.data)")
}</code></pre>
<pre lang="objc"><code lang="objc">[channel subscribe:@"myEvent" callback:^(ARTMessage *message) {
    NSLog(@"message received for event %@", message.name);
    NSLog(@"message data: %@", message.data);
}];</code></pre>
<p>Previously registered listeners can be removed individually or all together.</p>
<pre lang="javascript"><code lang="javascript">/* remove the listener registered for a single event */
channel.unsubscribe('myEvent', myListener);

/* remove the listener registered for all events */
channel.unsubscribe(myListener);</code></pre>
<pre lang="nodejs"><code lang="nodejs">/* remove the listener registered for a single event */
channel.unsubscribe('myEvent', myListener);

/* remove the listener registered for all events */
channel.unsubscribe(myListener);</code></pre>
<pre lang="java"><code lang="java">/* remove a single listener */
channel.unsubscribe(myListener);

/* remove the listener registered for all events */
channel.unsubscribe("myEvent", myListener);</code></pre>
<pre lang="csharp"><code lang="csharp">/* remove a single listener */
channel.Unsubscribe(myHandler);

/* remove the listener registered for all events */
channel.Unsubscribe("myEvent", myHandler);</code></pre>
<pre lang="ruby"><code lang="ruby"># remove the listener proc registered for a single event
channel.unsubscribe("myEvent", &amp;my_proc)

# remove the listener proc registered for all events
channel.unsubscribe(&amp;my_proc)</code></pre>
<pre lang="objc"><code lang="objc">// remove the listener registered for a single event
[channel unsubscribe:@"myEvent" listener:listener];

// remove the listener registered for all events
[channel unsubscribe:listener];</code></pre>
<pre lang="swift"><code lang="swift">// remove the listener registered for a single event
channel.unsubscribe("myEvent", listener: listener)

// remove the listener registered for all events
channel.unsubscribe(listener)</code></pre>
<h3 id="message-publish">Publishing messages</h3>
<p>Channels expose a <span lang="default"><code>publish</code></span><span lang="csharp"><code>Publish</code></span> method whereby a client can publish either a single message or an array of messages to a channel. A listener optionally passed in to the <span lang="default"><code>publish</code></span><span lang="csharp"><code>Publish</code></span> method enables the client to know whether or not the operation succeeded.</p>
<pre class="code-editor open-jsbin open-jsbin-owecul" lang="javascript"><code class="code-editor open-jsbin open-jsbin-owecul" lang="javascript">channel.publish('event', 'This is my payload', function(err) {
  if(err) {
    console.log('Unable to publish message; err = ' + err.message);
  } else {
    console.log('Message successfully sent');
  }
});</code></pre>
<pre class="code-editor open-jsbin open-jsbin-owecul" lang="nodejs"><code class="code-editor open-jsbin open-jsbin-owecul" lang="nodejs">channel.publish('event', 'This is my payload', function(err) {
  if(err) {
    console.log('Unable to publish message; err = ' + err.message);
  } else {
    console.log('Message successfully sent');
  }
});</code></pre>
<pre lang="ruby"><code lang="ruby">deferrable = channel.publish('event', 'This is my payload') do
  puts 'Messages successfully sent'
end
deferrable.errback do |err|
  puts "Unable to publish messages; err = #{err}"
end</code></pre>
<pre lang="java"><code lang="java">channel.publish("event", "This is my payload", new CompletionListener() {
  @Override
  public void onError(ErrorInfo reason) {
    System.out.println("Unable to publish message; err = " + reason.message);
  }
  @Override
  public void onSuccess() {
    System.out.println("Message successfully sent");
  }
});</code></pre>
<pre lang="csharp"><code lang="csharp">channel.Publish("event", "payload", (success, error) =&gt;
{
  if (error != null) {
    Console.WriteLine("Unable to publish message. Reason: " + error.message);
  } else {
    Console.WriteLine("Message published sucessfully");
  }
});</code></pre>
<pre lang="objc"><code lang="objc">[channel publish:@"event" data:@"This is my payload" callback:^(ARTErrorInfo *error) {
  if (error) {
    NSLog(@"Unable to publish message; err = %@", error.message);
  } else {
    NSLog(@"Message successfully sent");
  }
}];</code></pre>
<pre lang="swift"><code lang="swift">channel.publish("event", data: "This is my payload") { error in
  if let error = error {
    print("Unable to publish message; err = \(error.message)")
  } else {
    print("Message successfully sent")
  }
}</code></pre>


<div lang="csharp"> <!-- start csharp language block -->
<p>Channels also expose an async version <code>PublishAsync</code> of the <code>Publish</code> call which resumes execution once the message is confirmed received. It is purely for convenience.</p>
<pre lang="csharp"><code lang="csharp">var result = await channel.PublishAsync("event", "payload");
if(result.IsFailure) {
  Console.WriteLine("Unable to publish message. Reason: " + result.Error.message);
} else {
  Console.WriteLine("Message published sucessfully");
}</code></pre>

</div> <!-- /end csharp language block -->

<h3 id="message-history">Retrieving message history</h3>
<p>Channels expose a <a href="#history"><span lang="default"><code>history</code></span><span lang="csharp"><code>History</code></span></a> method providing a means for clients to obtain messages previously sent on the channel. Channel history can be used to return continuous message history up to the exact point a realtime channel was attached.</p>
<p>History provides access to instantaneous &#8220;live&#8221; history as well as the longer term persisted history for attached channels. If <a href="/realtime/history#persisted-history">persisted history</a> is enabled for the channel, then messages will <a href="https://support.ably.io/solution/articles/3000030059-how-long-are-messages-stored-for">typically be stored for 24 &#8211; 72 hours</a>. If persisted history is not enabled, Ably retains the last two minutes of message history in memory.</p>
<p>The following example retrieves the first two pages of historical messages published up until the point the channel was attached.</p>
<pre lang="javascript"><code lang="javascript">channel.attach(function() {
  channel.history({ untilAttach: true }, function(err, resultPage) {
    if(err) {
      console.log('Unable to get channel history; err = ' + err.message);
    } else {
      console.log(resultPage.items.length + ' messages received in first page');
      if(resultPage.hasNext()) {
        resultPage.next(function(err, nextPage) { ... });
      }
    }
  });
});</code></pre>
<pre lang="nodejs"><code lang="nodejs">channel.attach(function() {
  channel.history({ untilAttach: true }, function(err, resultPage) {
    if(err) {
      console.log('Unable to get channel history; err = ' + err.message);
    } else {
      console.log(resultPage.items.length + ' messages received in first page');
      if(resultPage.hasNext()) {
        resultPage.next(function(err, nextPage) { ... });
      }
    }
  });
});</code></pre>
<pre lang="java"><code lang="java">Param[] options = new Param[]{ new Param("untilAttach", "true") };
PaginatedResult&lt;Message&gt; resultPage = channel.history(options);
System.out.println(resultPage.items().length + " messages received in first page");
if(resultPage.hasNext()) {
  PaginatedResult&lt;Message&gt; nextPage = resultPage.next();
  System.out.println(nextPage.items().length + " messages received in second page");
}</code></pre>
<pre lang="csharp"><code lang="csharp">var history = await channel.HistoryAsync(untilAttached: true);
Console.WriteLine($"{history.Items.Count} messages received in the first page");
if (history.HasNext)
{
  var nextPage = await history.NextAsync();
  Console.WriteLine($"{nextPage.Items.Count} messages received in the second page");
}</code></pre>
<pre lang="ruby"><code lang="ruby">channel.attach do
  channel.history(until_attach: true) do |result_page|
    puts "#{result_page.items.length} messages received in first page"
    if result_page.has_next?
      result_page.next { |next_page| ... }
    end
  end
end</code></pre>
<pre lang="objc"><code lang="objc">[channel attach:^(ARTErrorInfo *error) {
    ARTRealtimeHistoryQuery *query = [[ARTRealtimeHistoryQuery alloc] init];
    query.untilAttach = true;
    [channel history:query callback:^(ARTPaginatedResult&lt;ARTMessage *&gt; *resultPage, ARTErrorInfo *error) {
        NSLog(@"%lu messages received in first page", (unsigned long)[resultPage.items count]);
        if (resultPage.hasNext) {
            [resultPage next:^(ARTPaginatedResult&lt;ARTMessage *&gt; *nextPage, ARTErrorInfo *error) {
                // ...
            }];
        }
    } error:nil];
}];</code></pre>
<pre lang="swift"><code lang="swift">channel.attach { error in
    let query = ARTRealtimeHistoryQuery()
    query.untilAttach = true
    try! channel.history(query) { resultPage, error in
        let resultPage = resultPage!
        print("\(resultPage.items.count) messages received in first page")
        if resultPage.hasNext {
            resultPage.next { nextPage, error in
                // ...
            }
        }
    }
}</code></pre>
<p>See the <a href="/realtime/history">history documentation</a> for further details of the supported query parameters.</p>
<h2>Presence</h2>
<p>Channels expose a <span lang="default"><code>presence</code></span><span lang="csharp"><code>Presence</code></span> member which a client can use to obtain channel presence information and to enter and leave the presence channel itself. See the <a href="/realtime/presence">presence documentation</a> for details.</p>
<h1>Channel API Reference</h1>
<div class="inline-toc">
<ul><li>Channel reference
<ul>
<li>
Methods
<ul>
<li><a href='#publish-data'>publish(name, data)</a></li>
<li><a href='#publish-msg-array'>publish(messages)</a></li>
<li><a href='#subscribe-listener'>subscribe(listener)</a></li>
<li><a href='#subscribe-event'>subscribe(name, listener)</a></li>
<li><a href='#subscribe-event-array'>subscribe(names, listener)</a></li>
<li><a href='#unsubscribe-event'>unsubscribe(name, listener)</a></li>
<li><a href='#unsubscribe-listener'>unsubscribe(listener)</a></li>
<li><a href='#unsubscribe-all'>unsubscribe()</a></li>
<li><a href='#history'>history(options)</a></li>
<li><a href='#attach'>attach()</a></li>
<li><a href='#detach'>detach()</a></li>
<li><a href='#on-state-listener'>on(state, listener)</a></li>
<li><a href='#on-listener'>on(listener)</a></li>
<li><a href='#once-state-listener'>once(state, listener)</a></li>
<li><a href='#once-listener'>once(listener)</a></li>
<li><a href='#off-state-listener'>off(state, listener)</a></li>
<li><a href='#off-listener'>off(listener)</a></li>
</ul>
</li>
<li>
Properties
<ul>
<li><a href='#state'>state</a></li>
<li><a href='#error-reason'>errorReason</a></li>
<li><a href='#name'>name</a></li>
<li><a href='#presence'>presence</a></li>
</ul>
</li>
<li>
Related types
<ul>
<li><a href='#channel-state'>ChannelState</a></li>
<li><a href='#message'>Message</a></li>
<li><a href='#channel-options'>ChannelOptions</a></li>
<li><a href='#channel-event'>ChannelEvent</a></li>
<li><a href='#channel-state-change'>ChannelStateChange</a></li>
<li><a href='#channel-state-listener'>ChannelStateListener</a></li>
<li><a href='#completion-listener'>CompletionListener</a></li>
<li><a href='#message-listener'>MessageListener</a></li>
<li><a href='#paginated-result'>PaginatedResult</a></li>
<li><a href='#param'>Param</a></li>
</ul>
</li>
</ul>
</li></ul>
</div><h2 id="properties"><span lang='default'>Channel Properties</span><span lang='objc,swift'>ARTRealtimeChannel Properties</span><span lang='ruby'>Ably::Realtime::Channel Attributes</span><span lang='java'>io.ably.lib.realtime.Channel Members</span><span lang='csharp'>IO.Ably.Realtime.RealtimeChannel Properties</span></h2>
<p>The <code>Channel</code> object exposes the following public <span lang="default">properties</span><span lang="ruby">attributes</span><span lang="java">members</span>:</p>
<h6 id="state"><span lang='default'>state</span><span lang='csharp'>State</span></h6>
<p>The current <span lang="java"><a href="#channel-state"><code>io.ably.lib.realtime.ChannelState</code></a> <code>state</code></span><span lang="csharp"><a href="#channel-state"><code>IO.Ably.Realtime.ChannelState</code></a> <code>state</code></span><span lang="ruby"><a href="#channel-state"><code>Ably::Realtime::Channel::STATE</code></a> <code>state</code></span><span lang="objc,swift"><a href="#channel-state"><code>ARTRealtimeChannelState</code></a></span><span lang="default"><a href="#channel-state"><code>ChannelState</code></a></span> of this <code>Channel</code>. See the supported <a href="#channel-states">channel states</a> for more information.</p>
<h6 id="error-reason"><span lang='default'>errorReason</span><span lang='java'>reason</span><span lang='ruby'>error_reason</span><span lang='csharp'>ErrorReason</span></h6>
<p>When a channel failure occurs this <span lang="default,ruby">attribute</span><span lang="java">member</span><span lang="javascript,nodejs,,objc,swift,csharp">property</span> contains the <span lang="java,ruby"><a href="/realtime/types#ably-exception"><code>AblyException</code></a></span><span lang="default"><a href="/realtime/types#error-info"><code>ErrorInfo</code></a></span>.</p>
<h6 id="name"><span lang='default'>name</span><span lang='csharp'>Name</span></h6>
<p>The name <code>String</code> unique to this channel.</p>
<h6 id="presence"><span lang='default'>presence</span><span lang='csharp'>Presence</span></h6>
<p>Provides access to the <a href="/realtime/presence">Presence</a> object for this channel which can be used to access members present on the channel, or participate in presence.</p>
<h2>Methods</h2>
<h6 id="publish"><span lang='default'>publish</span><span lang='csharp'>Publish</span></h6>
<p>There are two overloaded versions of this method:</p>
<blockquote class="definition" id="publish-data">
<p class="definition" id="publish-data"><span lang='default'>publish(String name, Object data, callback(<a href="/realtime/types#error-info">ErrorInfo</a> err))</span><span lang='ruby'><a href="/realtime/types#deferrable">Deferrable</a> publish(String name, Object data) &#8594; yields</span><span lang='java'>void publish(String name, Object data, <a href="#completion-listener">CompletionListener</a> listener)</span><span lang='csharp'>void Publish(string name, object data, Action&lt;bool, ErrorInfo&gt; callback = null, string clientId = null)</span><span lang='objc,swift'>publish(name: String?, data: AnyObject?, callback: ((<a href="/realtime/types#error-info">ARTErrorInfo</a>?) &#8594; Void)?)</span></p>
</blockquote>
<p>Publish a single message on this channel based on a given event name and payload. A <span lang="default">callback</span><span lang="java">listener</span> may optionally be passed in to this call to be notified of success <span lang="default">or failure</span><span lang="ruby"></span> of the operation.</p>
<blockquote class="definition" id="publish-msg-array">
<p class="definition" id="publish-msg-array"><span lang='default'>publish(Object[] messages, callback(<a href="/realtime/types#error-info">ErrorInfo</a> err))</span><span lang='ruby'><a href="/realtime/types#deferrable">Deferrable</a> publish(Message[] messages) &#8594; yields</span><span lang='java'>void publish(Message[] messages, <a href="#completion-listener">CompletionListener</a> listener)</span><span lang='csharp'>void Publish(IEnumerable&lt;<a href="#message">Message</a>&gt; messages, Action&lt;bool, <a href="/realtime/types#error-info">ErrorInfo</a>&gt; callback = null)</span><span lang='objc,swift'>publish(messages: [ <a href="#message">ARTMessage</a> ], callback: ((<a href="/realtime/types#error-info">ARTErrorInfo</a>?) &#8594; Void)?)</span></p>
</blockquote>
<p>Publish several messages on this channel. A <span lang="default">callback</span><span lang="java">listener</span><span lang="ruby">block</span> may optionally be passed in to this call to be notified of success <span lang="default">or failure</span><span lang="ruby"></span> of the operation.</p>
<h4>Parameters</h4>
<dl>
	<dt><div lang="default">name</div></dt>
	<dd>event name for the published message<br><i>Type: <code>String</code></i></dd>
</dl>
<dl>
	<dt><div lang="javascript,nodejs">data</div></dt>
	<dd>data payload for the message. The supported payload types are Strings, JSON objects and arrays, buffers containing arbitrary binary data, and null.<br><i>Type: <code>Object</code></i></dd>
	<dt><div lang="java">data</div></dt>
	<dd>data payload for the message. The supported payload types are Strings, JsonObject, binary data as byte arrays, and null.<br><i>Type: <code>Object</code></i></dd>
	<dt><div lang="csharp">data</div></dt>
	<dd>data payload for the message. The supported payload types are Strings, binary data as byte arrays, any plain c# class that can be serialised to Json, and null.<br><i>Type: <code>Object</code></i></dd>
	<dt><div lang="ruby">data</div></dt>
	<dd>data payload for the message. The supported payload types are Strings, Hash or Array objects that can be serialised to JSON using <code>to_json</code>, binary data as <code>ASCII-8BIT</code> byte arrays, and null.<br><i>Type: <code>Object</code></i></dd>
	<dt><div lang="objc,swift">data</div></dt>
	<dd>data payload for the message. The supported payload types are <span lang="objc"><code>NS</code></span><code>String</code>, <span lang="objc"><code>NS</code></span><code>Dictionary</code> or <span lang="objc"><code>NS</code></span><code>Array</code> objects that can be serialised to JSON, binary data as <code>NSData</code>, and <code>nil</code>.<br><i>Type: <code>Object</code></i></dd>
</dl>
<dl>
	<dt><span lang="default">messages</span></dt>
	<dd>An array of message objects to publish<br><i>Type: <a href="#message"><code>Message []</code></a></i></dd>
</dl>
<dl>
	<dt><div lang="javascript,nodejs">callback</div></dt>
	<dd>is a function of the form <code>function(err)</code> which is called upon completion</dd>
	<dt><div lang="java">listener</div></dt>
	<dd>Listener to be notified on completion<br><i>Type: <a href="#completion-listener"><code>CompletionListener</code></a></i></dd>
	<dt><div lang="csharp">callback</div></dt>
	<dd>is an action of the form <code>Action&lt;bool, ErrorInfo&gt;</code> which is called upon completion</dd>
	<dt><div lang="ruby">&amp;block</div></dt>
	<dd>yields upon successfully publishing the message</dd>
	<dt><div lang="objc,swift">callback</div></dt>
	<dd>called upon publishing the message, or with an error</dd>
</dl>


<div lang="javascript,nodejs,,swift,objc"> <!-- start javascript,nodejs,,swift,objc language block -->
<h4>Callback result</h4>
<p>On successful publish of the message, <code>err</code> is null. On failure to publish the message, <code>err</code> contains an <a href="#error-info"><code>ErrorInfo</code></a> object describing the failure reason.</p>

</div> <!-- /end javascript,nodejs,,swift,objc language block -->



<div lang="csharp"> <!-- start csharp language block -->
<h4>Callback result</h4>
<p>On successful publish of the message, <code>error</code> is null. On failure to publish the message, <code>error</code> contains an <a href="#error-info"><code>ErrorInfo</code></a> object describing the failure reason.</p>

</div> <!-- /end csharp language block -->



<div lang="java"> <!-- start java language block -->
<h4>Listener result</h4>
<p>On successful publish of the message, the <code>onSuccess</code> method of the <a href="#completion-listener">CompletionListener</a> is called. On failure to publish the message, the <code>onError</code> method is called with an <a href="#error-info"><code>ErrorInfo</code></a> argument describing the failure reason.</p>

</div> <!-- /end java language block -->



<div lang="ruby"> <!-- start ruby language block -->
<h4>Returns</h4>
<p>A <a href="/realtime/types#deferrable"><code>Deferrable</code></a> object is returned from the method.</p>
<p>On successful publish of the message, the registered success blocks for the <a href="/realtime/types#deferrable"><code>Deferrable</code></a> and any block provided to the method are executed. On failure to publish the message, the <code>errback</code> callbacks of the <a href="/realtime/types#deferrable"><code>Deferrable</code></a> are called with an <a href="#error-info"><code>ErrorInfo</code></a> argument describing the failure reason.</p>

</div> <!-- /end ruby language block -->

<h6 id="subscribe"><span lang='default'>subscribe</span><span lang='csharp'>Subscribe</span></h6>
<p>There are overloaded versions of this method:</p>
<blockquote class="definition" id="subscribe-listener">
<p class="definition" id="subscribe-listener"><span lang='default'>subscribe(listener(<a href="#message">Message</a>))</span><span lang='java'>void subscribe(<a href="#message-listener">MessageListener</a> listener)</span><span lang='csharp'>void Subscribe(Action&lt;<a href="#message">Message</a>&gt; handler)</span><span lang='ruby'>subscribe â yields <a href="#message">Message</a></span><span lang='objc,swift'>subscribe(callback: (<a href="#message">ARTMessage</a>) &#8594; Void) &#8594; ARTEventListener?</span></p>
</blockquote>
<p>Subscribe to messages on this channel. The caller supplies <span lang="default">a listener function</span><span lang="csharp">a lambda expression</span><span lang="java">an implementation of the <a href="#message-listener">MessageListener</a> interface</span><span lang="ruby">a block</span>, which is called each time one or more messages arrives on the channel.</p>
<blockquote class="definition" id="subscribe-event">
<p class="definition" id="subscribe-event"><span lang='default'>subscribe(String name, listener(<a href="#message">Message</a>))</span><span lang='java'>void subscribe(String name, <a href="#message-listener">MessageListener</a> listener)</span><span lang='csharp'>void Subscribe(string name, Action&lt;<a href="#message">Message</a>&gt; handler)</span><span lang='ruby'>subscribe(String name) â yields <a href="#message">Message</a></span><span lang='objc,swift'>subscribe(name: String, callback: (<a href="#message">ARTMessage</a>) &#8594; Void) &#8594; ARTEventListener?</span></p>
</blockquote>
<p>Subscribe to messages with a given event <code>name</code> on this channel. The caller supplies <span lang="default">a listener function</span><span lang="csharp">a lambda expression</span><span lang="java">an implementation of the <a href="#message-listener">MessageListener</a> interface</span><span lang="ruby">a block</span>, which is called each time one or more matching messages arrives on the channel.</p>
<div lang="objc,swift,csharp"></div><div lang="default">
<blockquote class="definition" id="subscribe-event-array">
<p class="definition" id="subscribe-event-array"><span lang='default'>subscribe(String[] names, listener(<a href="#message">Message</a>))</span><span lang='java'>void subscribe(String[] names, <a href="#message-listener">MessageListener</a> listener)</span><span lang='ruby'>subscribe(String *names) â yields <a href="#message">Message</a></span></p>
</blockquote>
<p>Subscribe a single listener to messages on this channel for multiple event <code>name</code> values.</p>
</div>
<h4>Parameters</h4>
<dl>
	<dt>name</dt>
	<dd>The event name to subscribe to<br><i>Type: <code>String</code></i></dd>
</dl>
<div lang="objc,swift,csharp"></div><div lang="default">
<dl>
	<dt>names</dt>
	<dd>An <span lang="ruby">argument</span> array of event names to subscribe to<br><i>Type: <span lang="default"><code>String[]</code> </span><span lang="ruby"><code>*argument</code></span></i><br />
</div></dd>
</dl>
<dl>
	<dt><div lang="javascript,nodejs">listener</div></dt>
	<dd>is a function of the form <code>function(message)</code> to be called for each message</dd>
	<dt><div lang="java"><a href="#message-listener">MessageListener</a> listener</div></dt>
	<dd>Message listener to be notified for matching messages</dd>
	<dt><div lang="ruby">&amp;block</div></dt>
	<dd>yields each matching message when received on the channel</dd>
	<dt><div lang="swift,objc">callback</div></dt>
	<dd>called with each matching <a href="#message"><code>message</code></a> when received on the channel</dd>
	<dt><div lang="csharp">handler</div></dt>
	<dd>called with each matching <a href="#message"><code>message</code></a> when received on the channel</dd>
</dl>
<h6 id="unsubscribe"><span lang='default'>unsubscribe</span><span lang='csharp'>Unsubscribe</span></h6>
<p>There are three overloaded versions of this method:</p>
<blockquote class="definition" id="unsubscribe-event">
<p class="definition" id="unsubscribe-event"><span lang='default'>unsubscribe(String name, listenerCallback)</span><span lang='java'>void unsubscribe(String name, <a href="#message-listener">MessageListener</a> listener)</span><span lang='csharp'>bool Unsubscribe(string eventName, Action&lt;<a href="#message">Message</a>&gt; handler)</span><span lang='ruby'>unsubscribe(String name, &amp;listener_proc)</span><span lang='objc,swift'>unsubscribe(name: String, listener: ARTEventListener)</span></p>
</blockquote>
<p>Unsubscribe to messages on this channel for the specified event name. This removes an earlier event-specific subscription.</p>
<blockquote class="definition" id="unsubscribe-listener">
<p class="definition" id="unsubscribe-listener"><span lang='default'>unsubscribe(listenerCallback)</span><span lang='java'>void unsubscribe(<a href="#message-listener">MessageListener</a> listener)</span><span lang='csharp'>bool Unsubscribe(Action&lt;<a href="#message">Message</a>&gt; handler)</span><span lang='ruby'>unsubscribe(&amp;listener_proc)</span><span lang='objc,swift'>unsubscribe(listener: ARTEventListener)</span></p>
</blockquote>
<p>Unsubscribe to messages on this channel. This removes an earlier subscription.</p>
<blockquote class="definition" id="unsubscribe-all">
<p class="definition" id="unsubscribe-all"><span lang='default'>unsubscribe()</span><span lang='java'>void unsubscribe()</span><span lang='csharp'>void Unsubscribe()</span><span lang='objc,swift'>unsubscribe()</span></p>
</blockquote>
<p>Unsubscribes all listeners to messages on this channel. This removes all earlier subscriptions.</p>
<h4>Parameters</h4>
<dl>
	<dt>String name</dt>
	<dd>The event name to unsubscribe from</dd>
</dl>
<dl>
	<dt><div lang="javascript,nodejs">listenerCallback</div></dt>
	<dd>is the callback listener function that was previously subscribed</dd>
	<dt><div lang="java">listener</div></dt>
	<dd>previously registered listener<br><i>Type: <a href="#message-listener"><code>MessageListener</code></a></i></dd>
	<dt><div lang="ruby">&amp;listener_block</div></dt>
	<dd>previously registered listener block</dd>
	<dt><div lang="swift,objc">listener</div></dt>
	<dd>previous return value from a <code>subscribe</code> call</dd>
	<dt><div lang="csharp">handler</div></dt>
	<dd>is the lambda expression that was previously subscribed</dd>
</dl>
<h6 id="history"><span lang='default'>history</span><span lang='csharp'>History</span></h6>
<blockquote class="definition">
<p class="definition"><span lang='default'>history(Object options, callback(<a href="/realtime/types#error-info">ErrorInfo</a> err, <a href="#paginated-result">PaginatedResult</a>&lt;<a href="#message">Message</a>&gt; resultPage))</span><span lang='ruby'><a href="/realtime/types#deferrable">Deferrable</a> history(Hash options) &#8594; yields <a href="#paginated-result">PaginatedResult</a>&lt;<a href="#message">Message</a>&gt;</span><span lang='java'><a href="#paginated-result">PaginatedResult</a>&lt;<a href="#message">Message</a>&gt; history(<a href="#param">Param []</a> options)</span><span lang='csharp'>Task&lt;<a href="#paginated-result">PaginatedResult<Message></a>&gt; HistoryAsync(<a href="#data-request-query">DataRequestQuery</a> dataQuery, bool untilAttached = false)</span><span lang='objc,swift'>history(query: ARTRealtimeHistoryQuery?, callback: (<a href="#paginated-result">ARTPaginatedResult</a>&lt;<a href="#message">ARTMessage</a>&gt;?, ARTErrorInfo?) &#8594; Void) throws</span></p>
</blockquote>
<p>Gets a <a href="#paginated-result">paginated</a> set of historical messages for this channel. If the <a href="https://support.ably.io/support/solutions/articles/3000030059-how-long-are-messages-stored-for">channel is configured to persist messages to disk</a>, then message history will <a href="https://support.ably.io/solution/articles/3000030059-how-long-are-messages-stored-for">typically be available for 24 &#8211; 72 hours</a>. If not, messages are only retained in memory by the Ably service for two minutes.</p>
<h4>Parameters</h4>
<dl>
	<dt><span lang="default">options</span><span lang="objc,swift">query</span><span lang="csharp">dataQuery</span></dt>
	<dd><span lang="default">an optional object containing the query parameters</span><span lang="ruby">an optional set of key value pairs containing the query parameters</span>, as specified in the <a href="/realtime/history#channel-history">message history API documentation</a>.<br><i>Type: <span lang="default"><code>Object</code></span><span lang="objc,swift"><code>ARTRealtimeHistoryQuery</code></span><span lang="csharp"><code>DataRequestQuery</code></span><span lang="ruby"><code>Hash</code></span><span lang="java"><a href="#param"><code>Param []</code></a></span></i></dd>
</dl>
<dl>
	<dt><div lang="javascript,nodejs">callback</div></dt>
	<dd>is a function of the form: <code>function(err, resultPage)</code></dd>
	<dt><div lang="ruby">&amp;block</div></dt>
	<dd>yields a <code>PaginatedResult&lt;Message&gt;</code> array</dd>
	<dt><div lang="swift,objc">callback</div></dt>
	<dd>called with a <a href="#paginated-result">ARTPaginatedResult</a>&lt;<a href="#message">ARTMessage</a>&gt; object or an error</dd>
</dl>
<p>Further details of the supported <code>options</code> params, see <a href="/realtime/history#channel-history">message history API documentation</a>.</p>


<div lang="javascript,nodejs,,objc,swift"> <!-- start javascript,nodejs,,objc,swift language block -->
<h4>Callback result</h4>
<p>On success, <code>resultPage</code> contains a <a href="#paginated-result"><code>PaginatedResult</code></a> encapsulating an array of <a href="#message"><code>Message</code></a> objects corresponding to the current page of results. <a href="#paginated-result"><code>PaginatedResult</code></a> supports pagination using <a href="#paginated-result"><code>next()</code></a> and <a href="#paginated-result"><code>first()</code></a> methods.</p>
<p>On failure to retrieve message history, <code>err</code> contains an <a href="#error-info"><code>ErrorInfo</code></a> object with the failure reason.</p>

</div> <!-- /end javascript,nodejs,,objc,swift language block -->



<div lang="java"> <!-- start java language block -->
<h4>Returns</h4>
<p>On success, the returned <a href="#paginated-result"><code>PaginatedResult</code></a> encapsulates an array of <a href="#message"><code>Message</code></a> objects corresponding to the current page of results. <a href="#paginated-result"><code>PaginatedResult</code></a> supports pagination using <a href="#paginated-result"><code>next</code></a> and <a href="#paginated-result"><code>first</code></a> methods.</p>
<p>Failure to retrieve the message history will raise an <a href="/realtime/types/#ably-exception"><code>AblyException</code></a></p>

</div> <!-- /end java language block -->



<div lang="csharp"> <!-- start csharp language block -->
<h4>Returns</h4>
<p>The return value is <code>Task&lt;PaginatedResult&lt;Message&gt;&gt;</code> which needs to be awaited.</p>
<p>On success, the returned <a href="#paginated-result"><code>PaginatedResult</code></a> encapsulates an array of <a href="#message"><code>Message</code></a> objects corresponding to the current page of results. <a href="#paginated-result"><code>PaginatedResult</code></a> supports pagination using <a href="#paginated-result"><code>NextAsync</code></a> and <a href="#paginated-result"><code>FirstAsync</code></a> methods.</p>
<p>Failure to retrieve the message history will raise an <a href="/realtime/types/#ably-exception"><code>AblyException</code></a></p>

</div> <!-- /end csharp language block -->



<div lang="ruby"> <!-- start ruby language block -->
<h4>Returns</h4>
<p>A <a href="/realtime/types#deferrable"><code>Deferrable</code></a> object is returned from the method.</p>
<p>On success, the registered success blocks for the <a href="/realtime/types#deferrable"><code>Deferrable</code></a> and any block provided to the method yield a <a href="#paginated-result">PaginatedResult</a> that encapsulates an array of <a href="#message"><code>Message</code></a> objects corresponding to the current page of results. <a href="#paginated-result"><code>PaginatedResult</code></a> supports pagination using <a href="#paginated-result"><code>next()</code></a> and <a href="#paginated-result"><code>first()</code></a> methods.</p>
<p>Failure to retrieve the message history will trigger the <code>errback</code> callbacks of the <a href="/realtime/types#deferrable"><code>Deferrable</code></a> with an <a href="#error-info"><code>ErrorInfo</code></a> object with the failure reason.</p>

</div> <!-- /end ruby language block -->

<h6 id="attach"><span lang='default'>attach</span><span lang='csharp'>Attach</span></h6>
<blockquote class="definition">
<p class="definition"><span lang='default'>attach(callback(<a href="/realtime/types#error-info">ErrorInfo</a> err))</span><span lang='java'>void attach()</span><span lang='csharp'>void Attach(Action&lt;TimeSpan, <a href="/realtime/types#error-info">ErrorInfo</a>?&gt; callback = null)</span><span lang='ruby'><a href="/realtime/types#deferrable">Deferrable</a> attach &#8594; yields</span><span lang='objc,swift'>attach(callback: ((<a href="/realtime/types#error-info">ARTErrorInfo</a>?) &#8594; Void)?)</span></p>
</blockquote>
<p>Attach to this channel ensuring the channel is created in the Ably system and all messages published on the channel will be received by any channel listeners registered using <span lang="default"><code>subscribe()</code></span><span lang="csharp"><code>Subscribe()</code></span><span lang="ruby"><code>subscribe</code></span>. Any resulting channel state change will be emitted to any listeners registered using the <a href="#on"><span lang="default"><code>on</code></span><span lang="csharp"><code>On</code></span></a> or <a href="#once"><span lang="default"><code>once</code></span><span lang="csharp"><code>Once</code></span></a> methods.</p>
<p>As a convenience, <span lang="default"><code>attach()</code></span><span lang="csharp"><code>Attach()</code></span><span lang="ruby"><code>attach</code></span> will be called implicitly if either <a href="#publish"><span lang="default"><code>publish()</code></span><span lang="csharp"><code>Publish()</code></span><span lang="ruby"><code>publish</code></span></a> or <a href="#subscribe"><span lang="default"><code>subscribe()</code></span><span lang="csharp"><code>Subscribe()</code></span><span lang="ruby"><code>subscribe</code></span></a> for the <code>Channel</code> is called, or <a href="/realtime/presence#enter"><span lang="default"><code>enter()</code></span><span lang="csharp"><code>Enter()</code></span><span lang="ruby"><code>enter</code></span></a> or <a href="/realtime/presence#subscribe"><span lang="default"><code>subscribe()</code></span><span lang="csharp"><code>Subscribe()</code></span><span lang="ruby"><code>subscribe</code></span></a> is called on the <a href="/realtime/presence"><code>Presence</code></a> for this <code>Channel</code>.</p>
<h4>Parameters</h4>
<dl>
	<dt><div lang="javascript,nodejs">callback</div></dt>
	<dd>is a function of the form <code>function(err)</code> and is called once the channel attach succeeds or fails</dd>
	<dt><div lang="ruby">&amp;block</div></dt>
	<dd>yields once the channel becomes attached</dd>
	<dt><div lang="csharp">callback</div></dt>
	<dd>is a lambda expression of the form <code>Action&lt;TimeSpan, ErrorInfo&gt;</code> and is called once the channel attach succeds or fails</dd>
	<dt><div lang="swift,objc">callback</div></dt>
	<dd>called once the channel becomes attached or if an error occurs</dd>
</dl>


<div lang="ruby"> <!-- start ruby language block -->
<h4>Returns</h4>
<p>A <a href="/realtime/types#deferrable"><code>Deferrable</code></a> object is returned from the attach method.</p>
<p>On successful attachment, the success callbacks for the <a href="/realtime/types#deferrable"><code>Deferrable</code></a> are called and any block provided to the method is yielded. Failure to attach will trigger the <code>errback</code> callbacks of the <a href="/realtime/types#deferrable"><code>Deferrable</code></a> with an <a href="#error-info"><code>ErrorInfo</code></a> object with the failure reason.</p>

</div> <!-- /end ruby language block -->

<h6 id="detach"><span lang='default'>detach</span><span lang='csharp'>Detach</span></h6>
<blockquote class="definition">
<p class="definition"><span lang='default'>detach(callback(<a href="/realtime/types#error-info">ErrorInfo</a> err))</span><span lang='java'>void detach()</span><span lang='csharp'>void Detach(Action&lt;TimeSpan, ErrorInfo&gt; callback = null)</span><span lang='ruby'><a href="/realtime/types#deferrable">Deferrable</a> detach &#8594; yields</span><span lang='objc,swift'>detach(callback: ((<a href="/realtime/types#error-info">ARTErrorInfo</a>?) &#8594; Void)?)</span></p>
</blockquote>
<p>Detach from this channel. Any resulting channel state change will be emitted to any listeners registered using the <a href="#on"><span lang="default"><code>on</code></span><span lang="csharp"><code>On</code></span></a> or <a href="#once"><span lang="default"><code>once</code></span><span lang="csharp"><code>Once</code></span></a> methods.</p>
<p>Please note: Once all clients globally have detached from the channel, the channel will be released in the Ably service within two minutes.</p>
<h4>Parameters</h4>
<dl>
	<dt><div lang="javascript,nodejs">callback</div></dt>
	<dd>is a function of the form <code>function(err)</code> and is called once the channel detach succeeds or fails</dd>
	<dt><div lang="csharp">callback</div></dt>
	<dd>is a lambda expression in the form <code>Action&lt;TimeSpan, ErrorInfo&gt;</code> and is called once the channel detach succeeds or fails</dd>
	<dt><div lang="ruby">&amp;block</div></dt>
	<dd>yields once the channel becomes detached</dd>
	<dt><div lang="swift,objc">callback</div></dt>
	<dd>called once the channel becomes detached or if an error occurs</dd>
</dl>


<div lang="ruby"> <!-- start ruby language block -->
<h4>Returns</h4>
<p>A <a href="/realtime/types#deferrable"><code>Deferrable</code></a> object is returned from the detach method.</p>
<p>On successful detachment, the registered success blocks for the <a href="/realtime/types#deferrable"><code>Deferrable</code></a> and any block provided to the method are executed. Failure to detach will trigger the <code>errback</code> callbacks of the <a href="/realtime/types#deferrable"><code>Deferrable</code></a> with an <a href="#error-info"><code>ErrorInfo</code></a> object with the failure reason.</p>

</div> <!-- /end ruby language block -->

<h6 id="on"><span lang='default'>on</span><span lang='csharp'>On</span></h6>
<p>There are two overloaded versions of this method:</p>
<blockquote class="definition" id="on-state-listener">
<p class="definition" id="on-state-listener"><span lang='default'>on(String state, listener())</span><span lang='ruby'>on(<a href="#channel-state">ChannelState</a> *state) &#8594; yields <a href="#channel-state-change">ChannelStateChange</a></span><span lang='java'>void on(<a href="#channel-state">ChannelState</a> state, <a href="#channel-state-listener">ChannelStateListener</a> listener)</span><span lang='csharp'>void On(<a href="#channel-state">ChannelState</a> event, Action<ChannelStateChangedEventArgs> action)</span><span lang='objc,swift'>on(event: <a href="#channel-event">ARTChannelEvent</a>, call: (<a href="#error-info">ARTErrorInfo</a>?) &#8594; Void) &#8594; ARTEventListener</span></p>
</blockquote>
<p>Register the given listener <span lang="ruby">block</span><span lang="swift,objc">function</span> for the specified <a href="#channel-state">ChannelState</a> <span lang="default"><code>state</code></span><span lang="ruby"><code>state(s)</code></span> changes on the <code>Channel</code>.<br />
<span class="default">The listener is passed the current state<span lang="javascript,nodejs"> as the <code>event</code> property of <code>this</code></span></span><span lang="ruby">The listener is passed a <a href="#channel-state">ChannelState</a> object that contains the current state, previous state, and an optional reason for the state change</span><span lang="objc,swift">The listener is passed an optional reason for the state change</span>.</p>
<blockquote class="definition" id="on-listener">
<p class="definition" id="on-listener"><span lang='default'>on(listener())</span><span lang='ruby'>on &#8594; yields <a href="#channel-state-change">ChannelStateChange</a></span><span lang='csharp'>void On(Action<ChannelStateChangedEventArgs> listener)</span><span lang='java'>void on(<a href="#channel-state-listener">ChannelStateListener</a> listener)</span><span lang='objc,swift'>on(call: (ARTErrorInfo?) &#8594; Void) &#8594; ARTEventListener</span></p>
</blockquote>
<p>Register the given listener <span lang="ruby">block</span><span lang="swift,objc">function</span><span lang="csharp">lambda expression</span> for all <a href="#channel-state">ChannelState</a> changes on the <code>Channel</code>, plus when an error happens when attaching, detaching, or encoding or decoding a message.<br />
<span class="default">The listener is passed the current state<span lang="javascript,nodejs"> as the <code>event</code> property of <code>this</code></span>.</span><span lang="ruby">The listener is passed a <a href="#channel-state">ChannelState</a> object that contains the current state, previous state, and an optional reason for the state change</span><span lang="objc,swift">The callback is passed an optional reason for the state change or error</span>.</p>
<h4>Parameters</h4>
<dl>
	<dt><div lang="javascript,nodejs">state</div></dt>
	<dd>the channel state to subscribe to, see <a href="#channel-state">ChannelState</a> for supported channel states<br><i>Type: <code>String</code></i></dd>
	<dt><div lang="java">state</div></dt>
	<dd>the channel state to subscribe to<br><i>Type: <a href="#channel-state"><code>ChannelState</code></a></i></dd>
	<dt><div lang="csharp">event</div></dt>
	<dd>the channel state to subscribe to<br><i>Type: <a href="#channel-state"><code>ChannelState</code></a></i></dd>
	<dt><div lang="ruby">state</div></dt>
	<dd>the channel state as a Symbol such as <code>:attached</code> or a <code>ChannelState</code> object to subscribe to<br><i>Type: <a href="#channel-state"><code>ChannelState</code></a></i></dd>
	<dt><div lang="swift,objc">event</div></dt>
	<dd>either a channel state to subscribe to, or <a href="#channel-event"><code>ARTChannelEventError</code></a> to subscribe to errors not related to state changes<br><i>Type: <a href="#channel-event"><code>ARTChannelEvent</code></a></i></dd>
</dl>
<dl>
	<dt><div lang="javascript,nodejs">listener</div></dt>
	<dd>is a function of the form <code>function()</code> to be notified for matching state changes. The current state is available as <code>this.event</code></dd>
	<dt><div lang="java">listener</div></dt>
	<dd>listener to be notified for matching state changes<br><i>Type: <a href="#channel-state-listener"><code>ChannelStateListener</code></a></i></dd>
	<dt><div lang="csharp">action</div></dt>
	<dd>lambda expression to be notified for matching state changes<br><i>Type: <a href="#channel-state-listener"><code>ChannelStateChangedEventArgs</code></a></i></dd>
	<dt><div lang="ruby">&amp;block</div></dt>
	<dd>listener block that is yielded to for matching state changes</dd>
	<dt><div lang="swift,objc">call</div></dt>
	<dd>called possibly with an <a href="#error-info"><code>ErrorInfo</code></a></dd>
</dl>
<h4>Example</h4>
<p><a href="https://jsbin.ably.io:443/aqotuc/1/edit?javascript,live" target="_blank">Browser <code>ChannelState</code> change example</a></p>
<h6 id="once"><span lang='default'>once</span><span lang='csharp'>Once</span></h6>
<p>There are two overloaded versions of this method:</p>
<blockquote class="definition" id="once-state-listener">
<p class="definition" id="once-state-listener"><span lang='default'>once(String state, listener())</span><span lang='ruby'>once(<a href="#channel-state">ChannelState</a> *state) &#8594; yields <a href="#channel-state-change">ChannelStateChange</a></span><span lang='java'>void once(<a href="#channel-state">ChannelState</a> state, <a href="#channel-state-listener">ChannelStateListener</a> listener)</span><span lang='csharp'>void Once(<a href="#channel-state">ChannelState</a> event, Action<ChannelStateChangedEventArgs> action)</span><span lang='objc,swift'>once(event: <a href="#channel-event">ARTChannelEvent</a>, call: (<a href="#error-info">ARTErrorInfo</a>?) &#8594; Void) &#8594; ARTEventListener</span></p>
</blockquote>
<p>Register the given listener <span lang="ruby">block</span><span lang="swift,objc">function</span><span lang="csharp">lambda expression</span> for a single occurence of the specified <a href="#channel-state">ChannelState</a> <span lang="default"><code>state</code></span><span lang="ruby"><code>state(s)</code></span><span lang="java"><code>state</code></span> change on the <code>Channel</code>. Once the listener has been called, it is removed as a registered listener and will not be called again.<br />
<span class="default">The listener is passed the current state<span lang="javascript,nodejs"> as the <code>event</code> property of <code>this</code></span></span><span lang="ruby">The listener is passed a <a href="#channel-state">ChannelState</a> object that contains the current state, previous state, and an optional reason for the state change</span><span lang="objc,swift">The listener is passed an optional reason for the state change</span>.</p>
<blockquote class="definition" id="once-listener">
<p class="definition" id="once-listener"><span lang='default'>once(listener())</span><span lang='ruby'>once &#8594; yields <a href="#channel-state-change">ChannelStateChange</a></span><span lang='java'>void once(<a href="#channel-state-listener">ChannelStateListener</a> listener)</span><span lang='csharp'>void Once(Action<ChannelStateChangedEventArgs> listener)</span><span lang='objc,swift'>once(call: (ARTErrorInfo?) &#8594; Void) &#8594; ARTEventListener</span></p>
</blockquote>
<p>Register the given listener <span lang="ruby">block</span><span lang="swift,objc">function</span><span lang="csharp">lambda expression</span> for a single occurence of any <a href="#channel-state">ChannelState</a> change on the <code>Channel</code>. Once the listener has been called, it is removed as a registered listener and will not be called again.<br />
<span class="default">The listener is passed the current state<span lang="javascript,nodejs"> as the <code>event</code> property of <code>this</code></span></span><span lang="ruby">The listener is passed a <a href="#channel-state">ChannelState</a> object that contains the current state, previous state, and an optional reason for the state change</span><span lang="objc,swift">The listener is passed an optional reason for the state change</span>.</p>
<h4>Parameters</h4>
<dl>
	<dt><div lang="javascript,nodejs">state</div></dt>
	<dd>the channel state to subscribe to, see <a href="#channel-state">ChannelState</a> for supported channel states<br><i>Type: <code>String</code></i></dd>
	<dt><div lang="java">state</div></dt>
	<dd>the channel state to subscribe to<br><i>Type: <a href="#channel-state"><code>ChannelState</code></a></i></dd>
	<dt><div lang="csharp">event</div></dt>
	<dd>the channel state to subscribe to<br><i>Type: <a href="#channel-state"><code>ChannelState</code></a></i></dd>
	<dt><div lang="ruby">state</div></dt>
	<dd>the channel state as a Symbol such as <code>:attached</code> or a <code>ChannelState</code> object to subscribe to<br><i>Type: <a href="#channel-state"><code>ChannelState</code></a></i></dd>
	<dt><div lang="swift,objc">event</div></dt>
	<dd>either a channel state to subscribe to, or <a href="#channel-event"><code>ARTChannelEventError</code></a> to subscribe to errors not related to state changes<br><i>Type: <a href="#channel-event"><code>ARTChannelEvent</code></a></i></dd>
</dl>
<dl>
	<dt><div lang="javascript,nodejs">listener</div></dt>
	<dd>is a function of the form <code>function()</code> to be notified for a single occurence of a matching state change. The current state is available as <code>this.event</code></dd>
	<dt><div lang="java">listener</div></dt>
	<dd>listener to be notified for a single occurence of a matching state change<br><i>Type: <a href="#channel-state-listener"><code>ChannelStateListener</code></a></i></dd>
	<dt><div lang="ruby">&amp;block</div></dt>
	<dd>listener block that is yielded to for a single occurence of a matching state change</dd>
	<dt><div lang="csharp">listener</div></dt>
	<dd>listener lambda expression that is notified only once for a matching state change</dd>
	<dt><div lang="swift,objc">call</div></dt>
	<dd>called possibly with an <a href="#error-info"><code>ErrorInfo</code></a></dd>
</dl>
<h6 id="off"><span lang='default'>off</span><span lang='csharp'>Off</span></h6>
<p>There are two overloaded versions of this method:</p>
<blockquote class="definition" id="off-state-listener">
<p class="definition" id="off-state-listener"><span lang='default'>off(String state, listener)</span><span lang='ruby'>off(<a href="#channel-state">ChannelState</a> *state, &amp;block)</span><span lang='java'>void off(<a href="#channel-state">ChannelState</a> state, <a href="#channel-state-listener">ChannelStateListener</a> listener)</span><span lang='csharp'>void Off(<a href="#channel-state">ChannelState</a> event, Action<ChannelStateChangedEventArgs> listener)</span><span lang='objc,swift'>off(event: <a href="#channel-event">ARTChannelEvent</a>, listener: ARTEventListener)</span></p>
</blockquote>
<p>Remove the given listener <span lang="ruby">block</span> for the <a href="#channel-state">ChannelState</a> <span lang="default"><code>state</code></span><span lang="ruby"><code>state(s)</code></span>.</p>
<blockquote class="definition" id="off-listener">
<p class="definition" id="off-listener"><span lang='default'>off(listener)</span><span lang='ruby'>off(&amp;block)</span><span lang='java'>void off(<a href="#channel-state-listener">ChannelStateListener</a> listener)</span><span lang='csharp'>void Off(Action<ChannelStateChangedEventArgs> listener)</span><span lang='objc,swift'>off(listener: ARTEventListener)</span></p>
</blockquote>
<p>Remove the given listener <span lang="ruby">block</span> for all <a href="#channel-state">ChannelState</a> states.</p>
<h4>Parameters</h4>
<dl>
	<dt><div lang="javascript,nodejs">state</div></dt>
	<dd>the channel state to unsubscribe from<br><i>Type: <code>String</code></i></dd>
	<dt><div lang="java">state</div></dt>
	<dd>the channel state to unsubscribe from<br><i>Type: <a href="#channel-state"><code>ChannelState</code></a></i></dd>
	<dt><div lang="csharp">event</div></dt>
	<dd>the channel state to unsubscribe from<br><i>Type: <a href="#channel-state"><code>ChannelState</code></a></i></dd>
	<dt><div lang="ruby">state</div></dt>
	<dd>the channel state as a Symbol such as <code>:detached</code> or a <code>ChannelState</code> object to unsubscribe from<br><i>Type: <a href="#channel-state"><code>ChannelState</code></a></i></dd>
	<dt><div lang="swift,objc">event</div></dt>
	<dd>either a channel to unsubscribe from, or <a href="#channel-event"><code>ARTChannelEventError</code></a> to unsubscribe from errors not related to state changes<br><i>Type: <a href="#channel-event"><code>ARTChannelEvent</code></a></i></dd>
</dl>
<dl>
	<dt><div lang="javascript,nodejs">listener</div></dt>
	<dd>is the listener function to be removed</dd>
	<dt><div lang="java">listener</div></dt>
	<dd>is the listener to be removed<br><i>Type: <a href="#channel-state-listener">@ChannelStateListener</a></i></dd>
	<dt><div lang="csharp">listener</div></dt>
	<dd>is the listener function to be removed</dd>
	<dt><div lang="ruby">&amp;block</div></dt>
	<dd>is the listener block to be removed</dd>
	<dt><div lang="swift,objc">listener</div></dt>
	<dd>previous return value from a <code>on</code> or <code>once</code> call</dd>
</dl>
<h2 id="related-types">Related types</h2>
<h3 id="channel-state"><span lang='default'>ChannelState</span><span lang='objc,swift'>ARTRealtimeChannelState</span><span lang='ruby'>Channel::STATE Enum</span><span lang='java'>io.ably.lib.realtime.ChannelState Enum</span><span lang='csharp'>IO.Ably.Realtime.ChannelState Enum</span></h3>


<div lang="javascript,nodejs"> <!-- start javascript,nodejs language block -->
<p><code>ChannelState</code> is a String with a value matching any of the <a href="/realtime/channel#channel-states"><code>Realtime Channel</code> states</a>.</p>
<pre lang="javascript"><code lang="javascript">var allChannelStates = [
  'initialized',
  'attaching',
  'attached',
  'detaching',
  'detached',
  'failed'
]</code></pre>

</div> <!-- /end javascript,nodejs language block -->



<div lang="java"> <!-- start java language block -->
<p><code>io.ably.lib.realtime.ChannelState</code> is an enum representing all the <a href="/realtime/channel#channel-states"><code>Realtime Channel</code> states</a>.</p>
<pre lang="java"><code lang="java">public enum ChannelState {
  initialized,  // 0
  attaching,    // 1
  attached,     // 2
  detaching,    // 3
  detached,     // 4
  failed        // 5
}</code></pre>

</div> <!-- /end java language block -->



<div lang="csharp"> <!-- start csharp language block -->
<p><code>IO.Ably.Realtime.ChannelState</code> is an enum representing all the <a href="/realtime/channel#channel-states"><code>Realtime Channel</code> states</a>.</p>
<pre lang="csharp"><code lang="csharp">public enum ChannelState
{
    Initialized = 0,
    Attaching = 1,
    Attached = 2,
    Detaching= 3,
    Detached = 4,
    Failed = 5
};</code></pre>

</div> <!-- /end csharp language block -->



<div lang="ruby"> <!-- start ruby language block -->
<p><code>Ably::Realtime::Channel::STATE</code> is an enum-like value representing all the <a href="/realtime/channel#channel-states"><code>Realtime Channel</code> states</a>. <code>STATE</code> can be represented interchangeably as either symbols or constants.</p>
<h4>Symbol states</h4>
<pre lang="ruby"><code lang="ruby">:initialized # =&gt; 0
:attaching # =&gt;   1
:attached # =&gt;    2
:detaching # =&gt;   3
:detached # =&gt;    4
:failed # =&gt;      5</code></pre>
<h4>Constant states</h4>
<pre lang="ruby"><code lang="ruby">Connection::STATE.Initialized # =&gt; 0
Connection::STATE.Attaching # =&gt;   1
Connection::STATE.Attached # =&gt;    2
Connection::STATE.Detaching # =&gt;   3
Connection::STATE.Detached # =&gt;    4
Connection::STATE.Failed # =&gt;      5</code></pre>
<h4>Example usage</h4>
<pre lang="ruby"><code lang="ruby"># Example with symbols
channel.on(:attached) { ... }

# Example with constants
channel.on(Ably::Realtime::Channel::STATE.Attached) { ... }

# Interchangeable
Ably::Realtime::Channel::STATE.Attached == :attached # =&gt; true</code></pre>

</div> <!-- /end ruby language block -->



<div lang="objc,swift"> <!-- start objc,swift language block -->
<p><code>ARTRealtimeChannelState</code> is an enum representing all the <a href="/realtime/channel#channel-states"><code>Realtime Channel</code> states</a>.</p>
<pre lang="objc"><code lang="objc">typedef NS_ENUM(NSUInteger, ARTRealtimeChannelState) {
    ARTRealtimeChannelInitialized,
    ARTRealtimeChannelAttaching,
    ARTRealtimeChannelAttached,
    ARTRealtimeChannelDetaching,
    ARTRealtimeChannelDetached,
    ARTRealtimeChannelFailed
};</code></pre>
<pre lang="swift"><code lang="swift">public enum ARTRealtimeChannelState : UInt {
    case Initialized
    case Attaching
    case Attached
    case Detaching
    case Detached
    case Failed
}</code></pre>

</div> <!-- /end objc,swift language block -->

<h3 id="message"><span lang='default'>Message</span><span lang='objc,swift'>ARTMessage</span><span lang='ruby'>Ably::Models::Message</span><span lang='java'>io.ably.lib.types.Message</span><span lang='csharp'>IO.Ably.Message</span></h3>
<p>A <code>Message</code> represents an individual message that is sent to or received from Ably.</p>
<h4><span lang='default'>Properties</span><span lang='java'>Members</span><span lang='ruby'>Attributes</span><span lang='python'>Attributes</span></h4>
<dl>
	<dt>name</dt>
	<dd>Event name, if provided<br><i>Type: <code>String</code></i></dd>
</dl>
<dl>
	<dt><div lang="default">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>String</code>, <code>StringBuffer</code>, <code>JSON Object</code></i></dd>
	<dt><div lang="java">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>String</code>, <code>ByteArray</code>, <code>JSONObject</code>, <code>JSONArray</code></i></dd>
	<dt><div lang="csharp">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>String</code>, <code>byte[]</code>, plain C# object that can be serialized to Json</i></dd>
	<dt><div lang="ruby">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>String</code>, <code>Binary</code> (ASCII-8BIT String), <code>Hash</code>, <code>Array</code></i></dd>
	<dt><div lang="python">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>String</code>, <code>Bytearray</code>, <code>Dict</code>, <code>List</code></i></dd>
	<dt><div lang="php">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>String</code>, <code>Binary String</code>, <code>Associative Array</code>, <code>Array</code></i></dd>
	<dt><div lang="objc">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>NSString *</code>, <code>NSData *</code>, <code>NSDictionary *</code>, <code>NSArray *</code></i></dd>
	<dt><div lang="swift">data</div></dt>
	<dd>The message payload, if provided<br><i>Type: <code>String</code>, <code>NSData</code>, <code>Dictionary</code>, <code>Array</code></i></dd>
</dl>
<dl>
	<dt>id</dt>
	<dd>Unique ID assigned by Ably to this message<br><i>Type: <code>String</code></i></dd>
</dl>
<dl>
	<dt><span lang="default">clientId</span><span lang="ruby,python">client_id</span></dt>
	<dd>The client ID of the publisher of this message<br><i>Type: <code>String</code></i></dd>
</dl>
<dl>
	<dt><span lang="default">connectionId</span><span lang="ruby,python">connection_id</span></dt>
	<dd>The connection ID of the publisher of this message<br><i>Type: <code>String</code></i></dd>
</dl>
<dl>
	<dt>timestamp</dt>
	<dd>Timestamp when the presence update was received by the Ably the realtime service, as <span lang="default">milliseconds since the epoch</span><span lang="ruby">a <code>Time</code> object</span><br><i>Type: <span lang="default"><code>Integer</code></span><span lang="java"><code>Long Integer</code></span><span lang="csharp"><code>DateTimeOffset</code></span><span lang="ruby"><code>Time</code></span><span lang="objc,swift"><code>NSDate</code></span></i></dd>
</dl>
<dl>
	<dt>encoding</dt>
	<dd>This will typically be empty as all messages received from Ably are automatically decoded client-side using this value. However, if the message encoding cannot be processed, this attribute will contain the remaining transformations not applied to the <code>data</code> payload<br><i>Type: <code>String</code></i></dd>
</dl>
<h3 id="channel-options"><span lang='default'>ChannelOptions Object</span><span lang='objc,swift'>ARTChannelOptions</span><span lang='ruby'>ChannelOptions Hash</span><span lang='java'>io.ably.lib.types.ChannelOptions</span><span lang='csharp'>IO.Ably.Rest.ChannelOptions</span></h3>
<p>Currently the supported channel options are only used for <a href="/realtime/encryption">configuring encryption</a>.</p>


<div lang="javascript,nodejs"> <!-- start javascript,nodejs language block -->
<p><code>ChannelOptions</code>, a plain Javascript object, may optionally be specified when instancing a <a href="/realtime/channels-messages"><code>Channel</code></a>, and this may be used to specify channel-specific options. The following attributes can be defined on the object:</p>

</div> <!-- /end javascript,nodejs language block -->



<div lang="ruby"> <!-- start ruby language block -->
<p><code>ChannelOptions</code>, a Hash object, may optionally be specified when instancing a <a href="/realtime/channels-messages"><code>Channel</code></a>, and this may be used to specify channel-specific options. The following key symbol values can be added to the Hash:</p>

</div> <!-- /end ruby language block -->



<div lang="php"> <!-- start php language block -->
<p><code>ChannelOptions</code>, an Associative Array, may optionally be specified when instancing a <a href="/realtime/channels-messages"><code>Channel</code></a>, and this may be used to specify channel-specific options. The following named keys and values can be added to the Associated Array:</p>

</div> <!-- /end php language block -->



<div lang="java,swift,objc"> <!-- start java,swift,objc language block -->
<p><span lang="swift,objc"><code>ART</code></span><span lang="java"><code>io.ably.lib.types.</code></span><code>ChannelOptions</code> may optionally be specified when instancing a <a href="/realtime/channels-messages"><code>Channel</code></a>, and this may be used to specify channel-specific options.</p>

</div> <!-- /end java,swift,objc language block -->



<div lang="csharp"> <!-- start csharp language block -->
<p><code>IO.Ably.ChannelOptions</code> may optionally be specified when instancing a <a href="/realtime/channels-messages"><code>Channel</code></a>, and this may be used to specify channel-specific options.</p>

</div> <!-- /end csharp language block -->

<h4><span lang='default'>Properties</span><span lang='java'>Members</span><span lang='ruby'>Attributes</span></h4>
<dl>
	<dt><span lang="default">cipher</span><span lang="ruby">:cipher</span><span lang="csharp">CipherParams</span></dt>
	<dd>Requests encryption for this channel when not null, and specifies encryption-related parameters (such as algorithm, chaining mode, key length and key). See <a href="/realtime/encryption#getting-started">an example</a><br><i>Type: <a href="/realtime/encryption#cipher-params"><code>CipherParams</code></a><span lang="javascript,nodejs,,java,ruby,php"> or <span lang="javascript,nodejs">an options object</span><span lang="java">a <code>Param[]</code> list</span><span lang="ruby">an options hash</span><span lang="php">an Associative Array</span> containing at a minimum a <code>key</code></span></i></dd>
</dl>


<div lang="java"> <!-- start java language block -->
<h4>Static methods</h4>
<h6 id="with-cipher-key">withCipherKey</h6>
<blockquote class="definition">
<p class="definition">static ChannelOptions.withCipherKey(Byte[] or String key)</p>
</blockquote>
<p>A helper method to generate a <code>ChannelOptions</code> for the simple case where you only specify a key.</p>
<h4>Parameters</h4>
<dl>
	<dt>key</dt>
	<dd>A binary <code>Byte[]</code> array or a base64-encoded <code>String</code>.</dd>
</dl>
<h4>Returns</h4>
<p>On success, the method returns a complete <code>ChannelOptions</code> object. Failure will raise an <a href="/realtime/types/#ably-exception"><code>AblyException</code></a>.</p>

</div> <!-- /end java language block -->

<h3 id="channel-state-change"><span lang='ruby'>ChannelStateChange</span></h3>


<div lang="ruby"> <!-- start ruby language block -->
<p>A <code>Ably::Models::ChannelStateChange</code> is a type encapsulating state change information emitted by the <a href="/realtime/channels-messages"><code>Channel</code></a> object. See <a href="/realtime/channels-messages#on"><code>Channel#on</code></a> to register a listener for one or more events.</p>
<h4>Attributes</h4>
<dl>
	<dt>previous</dt>
	<dd>the previous state<br><i>Type: <a href="/realtime/types#channel-state"><code>Channel::STATE</code></a></i></dd>
	<dt>current</dt>
	<dd>the new state<br><i>Type: <a href="/realtime/types#channel-state"><code>Channel::STATE</code></a></i></dd>
	<dt>reason</dt>
	<dd>an <a href="#error-info"><code>ErrorInfo</code></a> containing any information relating to the transition<br><i>Type: <a href="/realtime/types#error-info"><code>ErrorInfo</code></a></i></dd>
</dl>

</div> <!-- /end ruby language block -->

<h3 id="channel-event"><span lang='swift,objc'>ARTChannelEvent</span></h3>


<div lang="objc,swift"> <!-- start objc,swift language block -->
<p><code>ARTChannelEvent</code> is the enum emitted as the event in <code>ARTRealtimeChannel.on</code>. The variants correspond to <a href="/realtime/channels-messages/#channel-state"><code>Realtime Channel</code> state</a> changes, plus an arbitary <code>Error</code>.</p>
<pre lang="objc"><code lang="objc">typedef NS_ENUM(NSUInteger, ARTChannelEvent) {
    ARTChannelEventInitialized,
    ARTChannelEventAttaching,
    ARTChannelEventAttached,
    ARTChannelEventDetaching,
    ARTChannelEventDetached,
    ARTChannelEventFailed,
    ARTChannelEventError
};</code></pre>
<pre lang="swift"><code lang="swift">enum ARTChannelEvent : UInt {
    case Initialized
    case Attaching
    case Attached
    case Detaching
    case Detached
    case Failed
    case Error
}</code></pre>

</div> <!-- /end objc,swift language block -->

<h3 id="channel-state-listener"><span lang='java'>io.ably.lib.realtime.ChannelStateListener</span></h3>


<div lang="java"> <!-- start java language block -->
<p>A <span lang="java"><code>io.ably.lib.realtime.ChannelStateListener</code></span> is an interface allowing a client to be notified of state changes for a <a href="/realtime/channels-messages#channel"><code>Channel</code></a></p>
<pre lang="java"><code lang="java">public interface ChannelStateListener {
  // Called when the channel state changes
  public void onChannelStateChanged(ChannelState state, ErrorInfo reason);
}</code></pre>

</div> <!-- /end java language block -->

<h3 id="completion-listener"><span lang='java'>io.ably.lib.realtime.CompletionListener</span></h3>


<div lang="java"> <!-- start java language block -->
<p>A <span lang="java"><code>io.ably.lib.realtime.CompletionListener</code></span> is an interface allowing a client to be notified of the outcome of an asynchronous operation.</p>
<pre lang="java"><code lang="java">public interface CompletionListener {
  // Called when the associated operation completes successfully,
  public void onSuccess();

  // Called when the associated operation completes with an error.
  public void onError(ErrorInfo reason);
}</code></pre>

</div> <!-- /end java language block -->

<h3 id="data-request-query"><span lang='csharp'>DataRequestQuery</span></h3>


<div lang="csharp"> <!-- start csharp language block -->
<p><code>DataRequestQuery</code> is a type that encapsulates the parameters for a history queries. For example usage see <a href="/realtime/history#channel-history"><span lang="default"><code>Channel#history</code></span><span lang="csharp"><code>Channel#History</code></span></a>.</p>
<h4>Members</h4>
<dl>
	<dt>Start</dt>
	<dd><em>null</em> The start of the queried interval<br><i>Type: <code>DateTimeOffset</code></i></dd>
	<dt>End</dt>
	<dd><em>null</em> The end of the queried interval<br><i>Type: <code>DateTimeOffset</code></i></dd>
	<dt>Limit</dt>
	<dd><em>null</em> By default it is null. Limits the number of items returned by history or stats<br><i>Type: <code>Integer</code></i></dd>
	<dt>Direction</dt>
	<dd><em>Backwards</em> Enum which is either <code>Forwards</code> or <code>Backwards</code><br><i>Type: <code>Direction</code> enum</i></dd>
	<dt>ExtraParameters</dt>
	<dd>Optionally any extra query parameters that may be passed to the query. This is mainly used internally by the library to manage paging.<br><i>Type: <code>Dictionary&lt;string, string&gt;</code></i></dd>
</dl>

</div> <!-- /end csharp language block -->

<h3 id="message-listener"><span lang='java'>io.ably.lib.realtime.Channel.MessageListener</span></h3>


<div lang="java"> <!-- start java language block -->
<p>A <span lang="java"><code>io.ably.lib.realtime.Channel.MessageListener</code></span> is an interface allowing a client to be notified when messages are received on a channel using a <a href="/realtime/channels-messages#message-subscription">channel subscription</a>.</p>
<pre lang="java"><code lang="java">public interface MessageListener {
  // Called when one or more messages are received
  public void onMessage(Message message);
}</code></pre>

</div> <!-- /end java language block -->

<h3 id="paginated-result"><span lang='default'>PaginatedResult</span><span lang='objc,swift'>ARTPaginatedResult</span><span lang='ruby'>Ably::Models::PaginatedResult</span><span lang='java'>io.ably.lib.types.PaginatedResult</span><span lang='csharp'>IO.Ably.PaginatedResult</span></h3>
<p>A <code>PaginatedResult</code> is a type that represents a page of results for all message and presence history, stats and REST presence requests. The response from a <a href="/rest-api/#pagination">Ably REST API paginated query</a> is accompanied by metadata that indicates the relative queries available to the <code>PaginatedResult</code> object.</p>
<h4><span lang='default'>Properties</span><span lang='java'>Members</span><span lang='ruby'>Attributes</span><span lang='python'>Attributes</span></h4>
<dl>
	<dt><span lang="default">items</span><span lang="csharp">Items</span></dt>
	<dd>contains a page of results (for example an Array of <a href="#message"><code>Message</code></a> or <a href="#presence-message"><code>PresenceMessage</code></a> objects for a channel history request)<br><span lang="default"><i>Type: <code>Array &lt;Message, Presence, Stats&gt;</code></i></span><span lang="python"><i>Type: <code>List &lt;Message, Presence, Stats&gt;</code></i></span></dd>
</dl>
<dl>
	<dt><div lang="javascript,nodejs,java,swift,objc">isLast</div></dt>
	<dd><code>true</code> if this page is the last page<br><i>Type: <code>Boolean</code></i></dd>
	<dt><div lang="ruby">last?</div></dt>
	<dd><code>true</code> if this page is the last page<br><i>Type: <code>Boolean</code></i></dd>
	<dt><div lang="php">isLast()</div></dt>
	<dd><code>true</code> if this page is the last page<br><i>Type: <code>Boolean</code></i></dd>
	<dt><div lang="python">is_last()</div></dt>
	<dd><code>True</code> if this page is the last page<br><i>Type: <code>Boolean</code></i></dd>
	<dt><div lang="default">hasNext</div></dt>
	<dd><code>true</code> if there are further pages<br><i>Type: <code>Boolean</code></i></dd>
	<dt><div lang="csharp">HasNext</div></dt>
	<dd><code>true</code> if there are further pages<br><i>Type: <code>Boolean</code></i></dd>
	<dt><div lang="ruby">has_next?</div></dt>
	<dd><code>true</code> if there are further pages<br><i>Type: <code>Boolean</code></i></dd>
	<dt><div lang="php">hasNext()</div></dt>
	<dd><code>true</code> if there are further pages<br><i>Type: <code>Boolean</code></i></dd>
	<dt><div lang="python">has_next()</div></dt>
	<dd><code>True</code> if there are further pages<br><i>Type: <code>Boolean</code></i></dd>
</dl>
<h4>Methods</h4>
<h6><span lang='default'>first</span><span lang='csharp'>First</span></h6>
<blockquote class="definition">
<p class="definition"><span lang='default'>first(callback(<a href="/realtime/types#error-info">ErrorInfo</a> err, <a href="/realtime/types#paginated-result">PaginatedResult</a> resultPage))</span><span lang='ruby'><a href="/realtime/types#paginated-result">PaginatedResult</a> first</span><span lang='php'><a href="/realtime/types#paginated-result">PaginatedResult</a> first()</span><span lang='python'><a href="/realtime/types#paginated-result">PaginatedResult</a> first()</span><span lang='csharp'>Task&lt;PaginatedResult<T>&gt; FirstAsync()</span><span lang='java'><a href="/realtime/types#paginated-result">PaginatedResult</a> first()</span><span lang='swift,objc'>first(callback: (ARTPaginatedResult?, ARTErrorInfo?) &#8594; Void)</span></p>
</blockquote>
<p>Returns a new <code>PaginatedResult</code> for the first page of results. <span lang="ruby">When using the Realtime library, the <code>first</code> method returns a <a href="/realtime/types#deferrable">Deferrable</a> and yields a <a href="/realtime/types#paginated-result">PaginatedResult</a>.</span><span lang="csharp">The method is asyncronous and returns a Task which needs to be awaited to get the <a href="/realtime/types#paginated-result">PaginatedResult</a>.</span></p>
<h6><span lang='default'>items</span><span lang='csharp'>Items</span></h6>
<blockquote class="definition">
<p class="definition"><span lang='default'>Object[] items()</span><span lang='python'>List items()</span><span lang='ruby'>Object[] items</span><span lang='java'>Object[] items()</span><span lang='csharp'>List<T> Items</span><span lang='swift, objc'>items: [AnyObject]</span></p>
</blockquote>
<p>Returns the current page of results as <span lang="default">an Array</span><span lang="csharp">a List</span><span lang="python">a <code>List</code></span>. The type of the objects in the <span lang="default">array</span><span lang="python,csharp">list</span> is determined by the operation that provided the <code>PaginatedResult</code>. For example, a <a href="/realtime/channels-messages#history"><span lang="default">Message.history()</span><span lang="csharp">Message.History()</span></a> request will return <span lang="default">an array</span><span lang="python,csharp">a list</span> of <code>Message</code> objects.</p>
<h6><span lang='default'>next</span><span lang='csharp'>Next</span></h6>
<blockquote class="definition">
<p class="definition"><span lang='default'>next(callback(<a href="/realtime/types#error-info">ErrorInfo</a> err, <a href="/realtime/types#paginated-result">PaginatedResult</a> resultPage))</span><span lang='ruby'><a href="/realtime/types#paginated-result">PaginatedResult</a> next</span><span lang='php'><a href="/realtime/types#paginated-result">PaginatedResult</a> next()</span><span lang='python'><a href="/realtime/types#paginated-result">PaginatedResult</a> next()</span><span lang='csharp'>Task&lt;<a href="/realtime/types#paginated-result">PaginatedResult</a><T>&gt; NextAsync()</span><span lang='java'><a href="/realtime/types#paginated-result">PaginatedResult</a> next()</span><span lang='swift,objc'>next(callback: (ARTPaginatedResult?, ARTErrorInfo?) &#8594; Void)</span></p>
</blockquote>
<p>Returns a new <code>PaginatedResult</code> loaded with the next page of results. If there are no further pages, then <span lang="default"><code>null</code></span><span lang="csharp">a blank PaginatedResult will be returned</span><span lang="java"><code>Null</code></span><span lang="python"><code>None</code></span><span lang="ruby,objc,swift"><code>nil</code></span> is returned. <span lang="csharp">The method is asyncronous and return a Task which needs to be awaited to get the <code>PaginatedResult</code></span><span lang="ruby">When using the Realtime library, the <code>first</code> method returns a <a href="/realtime/types#deferrable">Deferrable</a> and yields a <a href="/realtime/types#paginated-result">PaginatedResult</a>.</span></p>
<h4>Example</h4>
<pre lang="javascript"><code lang="javascript">channel.history(function(err, paginatedResult) {
  console.log('Page 0 item 0:' + paginatedResult.items[0].data);
  paginatedResult.next(function(err, nextPage) {
    console.log('Page 1 item 1: ' + nextPage.items[1].data);
    console.log('Last page?: ' + nextPage.isLast;
  });
});</code></pre>
<pre lang="nodejs"><code lang="nodejs">channel.history(function(err, paginatedResult) {
  console.log('Page 0 item 0:' + paginatedResult.items[0].data);
  paginatedResult.next(function(err, nextPage) {
    console.log('Page 1 item 1: ' + nextPage.items[1].data);
    console.log('Last page?: ' + nextPage.isLast;
  });
});</code></pre>
<pre lang="java"><code lang="java">PaginatedResult firstPage = channel.history();
System.out.println("Page 0 item 0:" + firstPage.items[0].data);
if (firstPage.hasNext) {
  PaginatedResult nextPage = firstPage.next();
  System.out.println("Page 1 item 1:" + nextPage.items[1].data);
  System.out.println("More pages?:" + Strong.valueOf(nextPage.hasNext()));
};</code></pre>
<pre lang="csharp"><code lang="csharp">PaginatedResult&lt;Message&gt; firstPage = await channel.HistoryAsync(null);
Message firstMessage = firstPage.Items[0];
Console.WriteLine("Page 0 item 0: " + firstMessage.data);
if (firstPage.HasNext)
{
    var nextPage = await firstPage.NextAsync();
    Console.WriteLine("Page 1 item 1:" + nextPage.Items[1].data);
    Console.WriteLine("More pages?: " + nextPage.HasNext);
}</code></pre>
<pre lang="ruby"><code lang="ruby"># When using the REST sync library
first_page = channel.history
puts "Page 0 item 0: #{first_page.items[0].data}"
if first_page.has_next?
  next_page = first_page.next
  puts "Page 1 item 1: #{next_page.items[1].data}"
  puts "Last page?: #{next_page.is_last?}"
end

# When using the Realtime EventMachine library
channel.history do |first_page|
  puts "Page 0 item 0: #{first_page.items[0].data}"
  if first_page.has_next?
    first_page.next do |next_page|
      puts "Page 1 item 1: #{next_page.items[1].data}"
      puts "Last page?: #{next_page.is_last?}"
    end
  end
end</code></pre>
<pre lang="python"><code lang="python">result_page = channel.history()
print 'Page 0 item 0: ' + str(result_page.items[0].data)
if result_page.has_next():
  next_page = result_page.next()
  print 'Page 1 item 1: ' + str(next_page.items[1].data)
  print 'Last page?: ' + str(next_page.is_last())</code></pre>
<pre lang="php"><code lang="php">$firstPage = $channel.history();
echo("Page 0 item 0: " . $firstPage-&gt;items[0]-&gt;data);
if ($firstPage-&gt;hasNext()) {
  $nextPage = $firstPage-&gt;next();
  echo("Page 1 item 1: " . $nextPage-&gt;items[1]-&gt;data);
  echo("Last page?: " . $nextPage-&gt;isLast());
}</code></pre>
<pre lang="objc"><code lang="objc">[channel history:^(ARTPaginatedResult&lt;ARTMessage *&gt; *paginatedResult, ARTErrorInfo *error) {
    NSLog(@"Page 0 item 0: %@", paginatedResult.items[0].data);
    [paginatedResult next:^(ARTPaginatedResult&lt;ARTMessage *&gt; *nextPage, ARTErrorInfo *error) {
        NSLog(@"Page 1 item 1: %@", nextPage.items[1].data);
        NSLog(@"Last page?: %d", nextPage.isLast);
    }];
}];</code></pre>
<pre lang="swift"><code lang="swift">channel.history { paginatedResult, error in
    let paginatedResult = paginatedResult!
    print("Page 0 item 0: \((paginatedResult.items[0] as! ARTMessage).data)")
    paginatedResult.next { nextPage, error in
        let nextPage = nextPage!
        print("Page 0 item 0: \((nextPage.items[1] as! ARTMessage).data)")
        print("Last page? \(nextPage.isLast)")
    }
}</code></pre>
<h3 id="param"><span lang='java'>io.ably.lib.types.Param</span></h3>


<div lang="java"> <!-- start java language block -->
<p><code>Param</code> is a type encapsulating a key/value pair. This type is used frequently in method parameters allowing key/value pairs to be used more flexible, see <a href="/realtime/history#channel-history"><code>Channel#history</code></a> for an example.</p>
<p>Please note that <code>key</code> and <code>value</code> attributes are always strings. If an <code>Integer</code> or other value type is expected, then you must coerce that type into a <code>String</code>.</p>
<h4><span lang='java'>Members</span></h4>
<dl>
	<dt>key</dt>
	<dd>The key value<br><i>Type: <code>String</code></i></dd>
	<dt>value</dt>
	<dd>The value associated with the <code>key</code><br><i>Type: <code>String</code></i></dd>
</dl>

</div> <!-- /end java language block -->


    </article>
    <hr class="back">
    <a href="#documentation">Back to top</a>
  </div>
  <div id="sidebar">
  <a href="/" title="API Documentation Home"><img src="/images/ably-logo.png" class="ably-logo" title="API Documentation Home"></a>
  <ul>
<li class=''><a href='/quick-start-guide/'>Quickstart Guide</a></li>
<li class=''><a href='/how-ably-works/'>How Ably works</a></li>
</ul>
  <h2><a href="/realtime/">Realtime client lib</a></h2>
<ul>
<li class=''><a href='/realtime/usage/'>Using the Realtime library</a></li>
<li class=''><a href='/realtime/connection/'>Connection</a></li>
<li class='selected'><a href='/realtime/channels-messages/'>Channels and Messages</a></li>
<li class=''><a href='/realtime/presence/'>Presence</a></li>
<li class=''><a href='/realtime/authentication/'>Authentication</a></li>
<li class=''><a href='/realtime/history/'>History</a></li>
<li class=''><a href='/realtime/encryption/'>Encryption</a></li>
<li class=''><a href='/realtime/statistics/'>Statistics</a></li>
<li class=''><a href='/realtime/types/'>Types</a></li>
</ul>
  <h2><a href="/rest/">REST client lib</a></h2>
<ul>
<li class=''><a href='/rest/usage/'>Using the REST library</a></li>
<li class=''><a href='/rest/channels-messages/'>Channels and Messages</a></li>
<li class=''><a href='/rest/presence/'>Presence</a></li>
<li class=''><a href='/rest/authentication/'>Authentication</a></li>
<li class=''><a href='/rest/history/'>History</a></li>
<li class=''><a href='/rest/encryption/'>Encryption</a></li>
<li class=''><a href='/rest/statistics/'>Statistics</a></li>
<li class=''><a href='/rest/types/'>Types</a></li>
</ul>
  <h2><a href="/rest-api/">REST API</a></h2>
<ul>
</ul>
  <h2>General</h2>
<ul>
<li class=''><a href='/general/authentication/'>Authentication</a></li>
<li class=''><a href='/general/channel-rules-namespaces/'>Channel Rules and Namespaces</a></li>
<li class=''><a href='/general/push-notifications/'>Mobile push notifications</a></li>
<li class=''><a href='/general/queues/'>Message Queues</a></li>
<li class=''><a href='/general/webhooks/'>Receiving WebHooks</a></li>
<li class=''><a href='/general/statistics/'>Application Statistics</a></li>
</ul>
  <h2><a href="/client-lib-development-guide/">Library Development</a></h2>
<ul>
<li class=''><a href='/client-lib-development-guide/features/'>Features spec v0.9</a></li>
<li class=''><a href='/client-lib-development-guide/feature-prioritisation/'>Feature prioritisation</a></li>
<li class=''><a href='/client-lib-development-guide/protocol/'>Realtime Protocol Definition</a></li>
<li class=''><a href='/client-lib-development-guide/rest-api/'>REST API Definition</a></li>
<li class=''><a href='/client-lib-development-guide/test-api/'>Sandbox Test API</a></li>
<li class=''><a href='/client-lib-development-guide/encryption/'>Encryption</a></li>
<li class=''><a href='/client-lib-development-guide/websocket/'>WebSocket Transport</a></li>
<li class=''><a href='/client-lib-development-guide/comet/'>Comet Transport</a></li>
<li class=''><a href='/client-lib-development-guide/connection-recovery/'>Connection Recovery</a></li>
<li class=''><a href='/client-lib-development-guide/connection-manager/'>Connection Manager</a></li>
<li class=''><a href='/client-lib-development-guide/connection-fallback/'>Connection host fallback</a></li>
<li class=''><a href='/client-lib-development-guide/documentation-formatting-guide/'>Documentation Formatting Guide</a></li>
<li class=''><a href='/code-index/'>Code Examples List</a></li>
</ul>
  <ul>
<li><a href="https://www.ably.io">Visit Ably.io</a></li>
</ul>
</div>

</body>
</html>
